[
  {
    "id": 1,
    "title": "Simple I/O and Arithmetic",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that prompts the user to enter two integers, calculates their sum and product, and prints the results.",
    "inputFormat": "The program should prompt the user for two integers.",
    "outputFormat": "The program must print the sum and the product of the two numbers with descriptive labels.",
    "solution": {
      "explanation": "This problem uses the fundamental C input/output functions. First, we declare variables to hold the two input numbers, their sum, and their product. We use `printf()` to display prompts to the user. Input is read using `scanf(\"%d\", &num)` where `%d` specifies reading an integer and `&num` is the address-of operator, directing the input into the corresponding variable. Finally, simple addition (`+`) and multiplication (`*`) operations calculate the results, which are then printed using `printf()`, ensuring descriptive labels as required.",
      "code": "#include <stdio.h>\n\nint main() {\n    int num1, num2;\n    int sum, product;\n\n    // Prompt and read the two integers\n    printf(\"Enter first integer: \");\n    scanf(\"%d\", &num1);\n    printf(\"Enter second integer: \");\n    scanf(\"%d\", &num2);\n\n    // Calculate sum and product\n    sum = num1 + num2;\n    product = num1 * num2;\n\n    // Print the results\n    printf(\"\\nSum: %d\\n\", sum);\n    printf(\"Product: %d\\n\", product);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter first integer: 15\nEnter second integer: 7",
        "expected": "\nSum: 22\nProduct: 105\n"
      },
      {
        "input": "Enter first integer: 100\nEnter second integer: 200",
        "expected": "\nSum: 300\nProduct: 20000\n"
      },
      {
        "input": "Enter first integer: -5\nEnter second integer: 10",
        "expected": "\nSum: 5\nProduct: -50\n"
      }
    ]
  },
  {
    "id": 2,
    "title": "Even/Odd Check",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes an integer input from the user and determines whether the number is even or odd.",
    "inputFormat": "The program should prompt the user to enter a single integer.",
    "outputFormat": "The program must print whether the number is \"Even\" or \"Odd\".",
    "solution": {
      "explanation": "The mathematical definition of an even number is one that is perfectly divisible by 2. This is implemented in C using the **modulus operator** (`%`). If a number $n$ divided by 2 has a remainder of 0 ($n \\% 2 == 0$), the number is even; otherwise, it is odd. An `if-else` statement is used to execute the correct output based on this condition, handling both positive, negative, and zero inputs.",
      "code": "#include <stdio.h>\n\nint main() {\n    int num;\n\n    // Prompt and read the integer\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &num);\n\n    // Check if the number is even or odd using the modulus operator\n    if (num % 2 == 0) {\n        printf(\"The number %d is Even.\\n\", num);\n    } else {\n        printf(\"The number %d is Odd.\\n\", num);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter an integer: 42",
        "expected": "The number 42 is Even.\n"
      },
      {
        "input": "Enter an integer: 7",
        "expected": "The number 7 is Odd.\n"
      },
      {
        "input": "Enter an integer: 0",
        "expected": "The number 0 is Even.\n"
      },
      {
        "input": "Enter an integer: -11",
        "expected": "The number -11 is Odd.\n"
      }
    ]
  },
  {
    "id": 3,
    "title": "Max of 3 Numbers",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes three integers as input from the user and finds the largest among them.",
    "inputFormat": "The program should prompt the user for three separate integers.",
    "outputFormat": "The program must print the largest of the three numbers.",
    "solution": {
      "explanation": "This problem is solved by using a temporary variable, `max`, to keep track of the largest number found so far. We initialize `max` with the first input number (`a`). Then, we use two sequential `if` statements to compare the remaining numbers (`b` and `c`) with the current `max`. If a larger number is found, `max` is updated. This approach avoids deeply nested `if-else` logic and is generally clearer.",
      "code": "#include <stdio.h>\n\nint main() {\n    int a, b, c;\n\n    // Prompt and read the three integers\n    printf(\"Enter three integers (separated by spaces): \");\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    int max = a; // Assume 'a' is the largest initially\n\n    // Compare 'b' with 'max'\n    if (b > max) {\n        max = b;\n    }\n\n    // Compare 'c' with the current 'max'\n    if (c > max) {\n        max = c;\n    }\n\n    // Print the result\n    printf(\"The maximum number is: %d\\n\", max);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter three integers: 10 25 18",
        "expected": "The maximum number is: 25\n"
      },
      {
        "input": "Enter three integers: 5 5 5",
        "expected": "The maximum number is: 5\n"
      },
      {
        "input": "Enter three integers: -1 -5 -10",
        "expected": "The maximum number is: -1\n"
      },
      {
        "input": "Enter three integers: 99 1 50",
        "expected": "The maximum number is: 99\n"
      }
    ]
  },
  {
    "id": 4,
    "title": "Factorial (Iterative)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that calculates the factorial of a non-negative integer entered by the user. The calculation must be done iteratively using a loop (not recursion).",
    "inputFormat": "The program should prompt the user to enter a single non-negative integer.",
    "outputFormat": "The program must print the factorial of the input number.",
    "solution": {
      "explanation": "The factorial of $n$ ($n!$) is the product of all positive integers less than or equal to $n$. Since the result grows very quickly, we use the `long long` data type to store the `factorial` result to avoid overflow for inputs greater than 12. We initialize `factorial` to 1, as $0! = 1$. \n\nWe use a `for` loop that iterates from $i=1$ up to $n$. In each iteration, the current value of $i$ is multiplied by the running `factorial` total (`factorial *= i`). This iterative process builds the product sequentially until $n!$ is calculated.",
      "code": "#include <stdio.h>\n\nint main() {\n    int n, i;\n    long long factorial = 1; // Use long long for larger factorials\n\n    // Prompt and read the integer\n    printf(\"Enter a non-negative integer: \");\n    scanf(\"%d\", &n);\n\n    // Handle invalid input (negative number)\n    if (n < 0) {\n        printf(\"Factorial is not defined for negative numbers.\\n\");\n        return 1;\n    }\n\n    // Calculate factorial iteratively\n    for (i = 1; i <= n; i++) {\n        factorial *= i; // Same as factorial = factorial * i;\n    }\n\n    // Print the result\n    printf(\"Factorial of %d is %lld\\n\", n, factorial);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter a non-negative integer: 5",
        "expected": "Factorial of 5 is 120\n"
      },
      {
        "input": "Enter a non-negative integer: 0",
        "expected": "Factorial of 0 is 1\n"
      },
      {
        "input": "Enter a non-negative integer: 1",
        "expected": "Factorial of 1 is 1\n"
      },
      {
        "input": "Enter a non-negative integer: 7",
        "expected": "Factorial of 7 is 5040\n"
      }
    ]
  },
  {
    "id": 5,
    "title": "Prime Number Check (Simple)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes a positive integer as input and determines if it is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.",
    "inputFormat": "The program should prompt the user to enter a positive integer.",
    "outputFormat": "The program must print whether the number is \"Prime\" or \"Not Prime\".",
    "solution": {
      "explanation": "A prime number is a natural number greater than 1 that has no divisors other than 1 and itself. The algorithm initializes a boolean flag `isPrime` to `true` (assuming it is prime) and handles edge cases $n \\le 1$. \n\nThe core logic uses a `for` loop to check for divisibility by integers starting from $i=2$. We iterate up to $n-1$. If, at any point, the remainder of $n \\% i$ is 0, a divisor is found, the number is marked as not prime (`isPrime = false`), and the loop is immediately exited using `break`. If the loop completes without finding any divisors, the number remains marked as prime.",
      "code": "#include <stdio.h>\n#include <stdbool.h> // For using the bool type\n\nint main() {\n    int n, i;\n    bool isPrime = true; // Assume it's prime initially\n\n    // Prompt and read the integer\n    printf(\"Enter a positive integer: \");\n    scanf(\"%d\", &n);\n\n    // Handle edge cases: 0, 1, and negative numbers are not prime\n    if (n <= 1) {\n        isPrime = false;\n    } else {\n        // Loop from 2 up to n-1 (or up to sqrt(n) for optimization)\n        for (i = 2; i < n; i++) {\n            if (n % i == 0) { // If a divisor is found\n                isPrime = false;\n                break; // No need to check further\n            }\n        }\n    }\n\n    // Print the result\n    if (isPrime) {\n        printf(\"%d is a Prime number.\\n\", n);\n    } else {\n        printf(\"%d is Not Prime.\\n\", n);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter a positive integer: 13",
        "expected": "13 is a Prime number.\n"
      },
      {
        "input": "Enter a positive integer: 1",
        "expected": "1 is Not a Prime number.\n"
      },
      {
        "input": "Enter a positive integer: 4",
        "expected": "4 is Not a Prime number.\n"
      },
      {
        "input": "Enter a positive integer: 2",
        "expected": "2 is a Prime number.\n"
      }
    ]
  },
  {
    "id": 6,
    "title": "GCD/LCM Calculation",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes two positive integers as input and calculates their Greatest Common Divisor (GCD) and Least Common Multiple (LCM).",
    "inputFormat": "The program should prompt the user to enter two positive integers.",
    "outputFormat": "The program must print both the GCD and the LCM of the two numbers.",
    "solution": {
      "explanation": "The GCD (Greatest Common Divisor) is calculated using the **Euclidean Algorithm**, which iteratively replaces the larger number with the remainder of the division of the two numbers until the remainder is 0. The last non-zero remainder is the GCD. The LCM (Least Common Multiple) is then derived using the relationship: $LCM(a,b) = \\frac{|a \\times b|}{GCD(a,b)}$",
      "code": "#include <stdio.h>\n\nint main() {\n    int num1, num2, a, b, temp, gcd, lcm;\n\n    // Prompt and read the two integers\n    printf(\"Enter two positive integers: \");\n    scanf(\"%d %d\", &num1, &num2);\n\n    // Make copies for GCD calculation\n    a = num1;\n    b = num2;\n\n    // --- GCD Calculation (Euclidean Algorithm) ---\n    while (b != 0) {\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n    gcd = a; // GCD is stored in 'a'\n\n    // --- LCM Calculation ---\n    // Formula: LCM(a, b) = (|a * b|) / GCD(a, b)\n    lcm = (num1 * num2) / gcd;\n\n    // Print the results\n    printf(\"\\nGCD of %d and %d is %d\\n\", num1, num2, gcd);\n    printf(\"LCM of %d and %d is %d\\n\", num1, num2, lcm);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter two positive integers: 12 18",
        "expected": "\nGCD of 12 and 18 is 6\nLCM of 12 and 18 is 36\n"
      },
      {
        "input": "Enter two positive integers: 10 15",
        "expected": "\nGCD of 10 and 15 is 5\nLCM of 10 and 15 is 30\n"
      },
      {
        "input": "Enter two positive integers: 7 5",
        "expected": "\nGCD of 7 and 5 is 1\nLCM of 7 and 5 is 35\n"
      },
      {
        "input": "Enter two positive integers: 4 20",
        "expected": "\nGCD of 4 and 20 is 4\nLCM of 4 and 20 is 20\n"
      }
    ]
  },
  {
    "id": 7,
    "title": "Array Sum/Average",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that initializes an array of 5 integers, calculates the sum of all elements, and determines the average.",
    "inputFormat": "The program should prompt the user to enter 5 integers one by one.",
    "outputFormat": "The program must print both the total sum and the calculated average (as a floating-point number).",
    "solution": {
      "explanation": "We use a `for` loop to iterate through the array, accumulating the sum of all elements. To calculate the average accurately, it is crucial to perform **type casting** of the integer `sum` to a `float` before dividing by the integer `array_size`. This ensures that the division is performed in floating-point arithmetic, yielding a precise average.",
      "code": "#include <stdio.h>\n\nint main() {\n    int numbers[5];\n    int sum = 0;\n    float average;\n    int i;\n    int array_size = 5;\n\n    // Read the 5 integers from the user\n    printf(\"Enter %d integers:\\n\", array_size);\n    for (i = 0; i < array_size; i++) {\n        printf(\"Enter number %d: \", i + 1);\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    // Calculate the sum of the elements\n    for (i = 0; i < array_size; i++) {\n        sum += numbers[i];\n    }\n\n    // Calculate the average (must cast sum or size to float)\n    average = (float)sum / array_size;\n\n    // Print the results\n    printf(\"\\nSum of elements: %d\\n\", sum);\n    printf(\"Average of elements: %.2f\\n\", average);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter 5 integers:\nEnter number 1: 10\nEnter number 2: 20\nEnter number 3: 30\nEnter number 4: 40\nEnter number 5: 50",
        "expected": "\nSum of elements: 150\nAverage of elements: 30.00\n"
      },
      {
        "input": "Enter 5 integers:\nEnter number 1: -1\nEnter number 2: 0\nEnter number 3: 1\nEnter number 4: 2\nEnter number 5: 3",
        "expected": "\nSum of elements: 5\nAverage of elements: 1.00\n"
      },
      {
        "input": "Enter 5 integers:\nEnter number 1: 5\nEnter number 2: 5\nEnter number 3: 5\nEnter number 4: 5\nEnter number 5: 5",
        "expected": "\nSum of elements: 25\nAverage of elements: 5.00\n"
      }
    ]
  },
  {
    "id": 8,
    "title": "Linear Search in Array",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that performs a Linear Search on a predefined array of integers. The user will input the target number, and the program will report if the number is found and at which index.",
    "inputFormat": "The program should prompt the user to enter a single integer to search for.",
    "outputFormat": "If the number is found, print the index where it was first located. If not found, print a message indicating it's not in the array.",
    "solution": {
      "explanation": "Linear search checks every element in the array sequentially. A `for` loop iterates from the beginning. If the element `arr[i]` matches the `target`, the index `i` is recorded, and the search is terminated immediately using `break`. We use a flag variable (`found_index` initialized to -1) to check if the loop completed without finding a match, indicating the element is not present.",
      "code": "#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50, 60};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int target;\n    int i;\n    int found_index = -1; // Use -1 to indicate not found\n\n    // Prompt and read the target\n    printf(\"Enter the number to search: \");\n    scanf(\"%d\", &target);\n\n    // --- Linear Search ---\n    for (i = 0; i < size; i++) {\n        if (arr[i] == target) {\n            found_index = i; // Store the index\n            break;          // Exit the loop immediately\n        }\n    }\n\n    // Print the result\n    if (found_index != -1) {\n        printf(\"Element %d found at index %d.\\n\", target, found_index);\n    } else {\n        printf(\"Element %d not found in the array.\\n\", target);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter the number to search: 30",
        "expected": "Element 30 found at index 2.\n"
      },
      {
        "input": "Enter the number to search: 10",
        "expected": "Element 10 found at index 0.\n"
      },
      {
        "input": "Enter the number to search: 60",
        "expected": "Element 60 found at index 5.\n"
      },
      {
        "input": "Enter the number to search: 100",
        "expected": "Element 100 not found in the array.\n"
      }
    ]
  },
  {
    "id": 9,
    "title": "Reverse Array (In-place)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that reverses the elements of a given array in-place (without using a second array). The program should print the array before and after reversal.",
    "inputFormat": "The array is pre-defined in the code.",
    "outputFormat": "Print the elements of the array before and after the in-place reversal.",
    "solution": {
      "explanation": "To reverse an array **in-place**, we only need to iterate up to the **midpoint** of the array ($size / 2$). In each iteration, we swap the element at the current index $i$ with the element at the corresponding opposite index, $size - 1 - i$. A temporary variable (`temp`) is essential for holding the value during the three-step swap process to ensure data is not lost.",
      "code": "#include <stdio.h>\n\nvoid print_array(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int temp;\n    int i;\n\n    printf(\"Original array: \");\n    print_array(arr, size);\n\n    // --- In-place Reversal ---\n    // Loop only up to the midpoint\n    for (i = 0; i < size / 2; i++) {\n        // Swap arr[i] with arr[size - 1 - i]\n        temp = arr[i];\n        arr[i] = arr[size - 1 - i];\n        arr[size - 1 - i] = temp;\n    }\n\n    // Print the reversed array\n    printf(\"Reversed array: \");\n    print_array(arr, size);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Original array: 1 2 3 4 5\nReversed array: 5 4 3 2 1",
        "expected": "Original array: 1 2 3 4 5 \nReversed array: 5 4 3 2 1 \n"
      },
      {
        "input": "Original array: 10 20 30 40\nReversed array: 40 30 20 10",
        "expected": "Original array: 10 20 30 40 \nReversed array: 40 30 20 10 \n"
      },
      {
        "input": "Original array: 100\nReversed array: 100",
        "expected": "Original array: 100 \nReversed array: 100 \n"
      }
    ]
  },
  {
    "id": 10,
    "title": "Find Duplicates (Brute Force)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that finds and prints all duplicate elements in a given integer array using a brute force (nested loop) approach.",
    "inputFormat": "The array is pre-defined in the code.",
    "outputFormat": "Print a list of the duplicate elements found.",
    "solution": {
      "explanation": "The brute force method uses a **nested loop** to find duplicates. The outer loop selects an element at index $i$. The inner loop iterates over all subsequent elements (index $j=i+1$ to $size-1$) to check for a match. If `arr[i] == arr[j]`, a duplicate is found, it is printed, and the inner loop breaks to ensure the same duplicate isn't re-checked against $arr[i]$ in that pass. Note that for arrays with many duplicates (e.g., three '20's), this implementation will only report the first instance of '20' as a duplicate.",
      "code": "#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50, 20, 60, 40};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int i, j;\n    \n    printf(\"Original array: \");\n    for (i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Duplicate elements are: \");\n    // Outer loop selects an element\n    for (i = 0; i < size; i++) {\n        // Inner loop compares with all subsequent elements\n        for (j = i + 1; j < size; j++) {\n            if (arr[i] == arr[j]) {\n                printf(\"%d \", arr[i]);\n                // A key refinement for a proper solution would be to track printed duplicates\n                // For simplicity here, we just print the first match found.\n                break; // Once a duplicate is found for arr[i], move to the next outer element\n            }\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Original array: 10 20 30 40 50 20 60 40",
        "expected": "Original array: 10 20 30 40 50 20 60 40 \nDuplicate elements are: 20 40 \n"
      },
      {
        "input": "Original array: 1 1 2 3 3 4",
        "expected": "Original array: 1 1 2 3 3 4 \nDuplicate elements are: 1 3 \n"
      },
      {
        "input": "Original array: 1 2 3 4 5",
        "expected": "Original array: 1 2 3 4 5 \nDuplicate elements are: \n"
      }
    ]
  },
  {
    "id": 11,
    "title": "Count Element Frequency",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that counts the frequency of each unique element in a given integer array.",
    "inputFormat": "The array is pre-defined in the code.",
    "outputFormat": "Print each unique element and the number of times it appears in the array.",
    "solution": {
      "explanation": "This solution uses a separate `freq` array to mark elements that have already been processed to avoid redundant counting. The outer loop iterates through the array. If an element is unprocessed, the inner loop counts all subsequent occurrences, marking them in the `freq` array. This ensures that the frequency is calculated only once for each unique element.",
      "code": "#include <stdio.h>\n\n#define MAX_SIZE 100\n\nint main() {\n    int arr[] = {10, 20, 20, 30, 10, 20, 40};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    int freq[MAX_SIZE]; // Array to store frequencies (must be sized appropriately)\n    int i, j, count;\n\n    // Initialize all elements of the frequency array to 0 or another marker\n    for (i = 0; i < size; i++) {\n        freq[i] = 0;\n    }\n\n    for (i = 0; i < size; i++) {\n        count = 1;\n        // Check if the element hasn't been counted already (marked by 1)\n        if (freq[i] == 1) { \n            continue;\n        }\n        \n        // Inner loop checks subsequent elements\n        for (j = i + 1; j < size; j++) {\n            if (arr[i] == arr[j]) {\n                count++;\n                freq[j] = 1; // Mark the duplicate element as counted\n            }\n        }\n        \n        // Print the result for the current unique element\n        printf(\"Element %d occurs %d time(s).\\n\", arr[i], count);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Original array: 10 20 20 30 10 20 40",
        "expected": "Element 10 occurs 2 time(s).\nElement 20 occurs 3 time(s).\nElement 30 occurs 1 time(s).\nElement 40 occurs 1 time(s).\n"
      },
      {
        "input": "Original array: 1 1 1 2 2 3",
        "expected": "Element 1 occurs 3 time(s).\nElement 2 occurs 2 time(s).\nElement 3 occurs 1 time(s).\n"
      },
      {
        "input": "Original array: 5 5 5 5 5",
        "expected": "Element 5 occurs 5 time(s).\n"
      }
    ]
  },
  {
    "id": 12,
    "title": "String Length Calculation",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes a string as input and manually calculates its length (number of characters) without using the standard library function strlen().",
    "inputFormat": "The program should prompt the user to enter a string (assume no spaces).",
    "outputFormat": "The program must print the calculated length of the string.",
    "solution": {
      "explanation": "A C string is an array of characters terminated by the **null character** (\\text{\\textbackslash} 0). To manually calculate the length, we use a `while` loop that increments a counter (`length`) as long as the current character `str[i]` is not the null terminator. The loop stops just before the terminator, giving the correct length of the string contents.",
      "code": "#include <stdio.h>\n\nint main() {\n    char str[100];\n    int length = 0;\n    int i = 0;\n\n    // Prompt and read the string\n    printf(\"Enter a string: \");\n    scanf(\"%s\", str); // Read string (stops at first whitespace)\n\n    // --- Manual String Length Calculation ---\n    // Iterate until the null terminator is reached\n    while (str[i] != '\\0') {\n        length++; // Increment the length counter\n        i++;      // Move to the next character\n    }\n    // --- End of Manual String Length Calculation ---\n\n    // Print the result\n    printf(\"The length of \\\"%s\\\" is %d\\n\", str, length);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter a string: Hello",
        "expected": "The length of \"Hello\" is 5\n"
      },
      {
        "input": "Enter a string: CProgramming",
        "expected": "The length of \"CProgramming\" is 12\n"
      },
      {
        "input": "Enter a string: a",
        "expected": "The length of \"a\" is 1\n"
      }
    ]
  },
  {
    "id": 13,
    "title": "Palindrome Check (Manual Loop)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes a string (e.g., a word like 'madam') and checks if it is a palindrome by manually comparing characters using a loop. A palindrome reads the same forwards and backwards.",
    "inputFormat": "The program should prompt the user to enter a string (word).",
    "outputFormat": "The program must print whether the entered string is a \"Palindrome\" or \"Not a Palindrome\".",
    "solution": {
      "explanation": "We check for a palindrome by comparing characters from the outside inward. First, the string's length is calculated. Then, a `for` loop iterates only up to the **midpoint** ($length / 2$). In each step, it compares the character at index $i$ (from the start) with the character at $length - 1 - i$ (from the end). If any pair mismatches, a boolean flag is set to `false`, and the loop is exited.",
      "code": "#include <stdio.h>\n#include <stdbool.h> \n\n// Helper function to calculate length manually\nint string_length(char *s) {\n    int length = 0;\n    while (s[length] != '\\0') {\n        length++;\n    }\n    return length;\n}\n\nint main() {\n    char str[100];\n    int length, i;\n    bool isPalindrome = true;\n\n    // Prompt and read the string\n    printf(\"Enter a word: \");\n    scanf(\"%s\", str);\n\n    length = string_length(str);\n\n    // --- Palindrome Check ---\n    // Loop only up to the middle of the string\n    for (i = 0; i < length / 2; i++) {\n        // Compare the character at index i with the character at the corresponding end index\n        if (str[i] != str[length - 1 - i]) {\n            isPalindrome = false;\n            break; // Not a palindrome, stop checking\n        }\n    }\n    // --- End of Palindrome Check ---\n\n    // Print the result\n    if (isPalindrome) {\n        printf(\"\\\"%s\\\" is a Palindrome.\\n\", str);\n    } else {\n        printf(\"\\\"%s\\\" is Not a Palindrome.\\n\", str);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter a word: rotor",
        "expected": "\"rotor\" is a Palindrome.\n"
      },
      {
        "input": "Enter a word: level",
        "expected": "\"level\" is a Palindrome.\n"
      },
      {
        "input": "Enter a word: code",
        "expected": "\"code\" is Not a Palindrome.\n"
      },
      {
        "input": "Enter a word: madam",
        "expected": "\"madam\" is a Palindrome.\n"
      }
    ]
  },
  {
    "id": 14,
    "title": "Copy String Manually",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes a source string as input and copies it completely into a separate destination string array. You must perform the copying manually using a loop, without using the standard library function strcpy().\n\nHint: Remember that a C string is only considered a valid string if it is terminated by the null character ($\\text{\\textbackslash} 0$). This character must also be copied to the destination array.",
    "inputFormat": "The program should prompt the user to enter a string (assume no spaces).",
    "outputFormat": "The program must print both the original (source) string and the new (destination) string to confirm the copy was successful.",
    "solution": {
      "explanation": "Manual string copying involves iterating through the source string, character by character, and assigning it to the corresponding index in the destination array. The most crucial step is ensuring that the **null terminator** (\\text{\\textbackslash} 0) is copied as the final character to the destination array. Without this, the destination array is not a valid C string and functions like `printf(\"%s\", ...)` will fail or crash.",
      "code": "#include <stdio.h>\n\nint main() {\n    char source[100];\n    char destination[100]; // Must be large enough to hold the copied string\n    int i = 0;\n\n    // Prompt and read the source string\n    printf(\"Enter a string: \");\n    scanf(\"%s\", source);\n\n    // --- Start of Manual String Copy ---\n\n    // Loop until the null character is encountered in the source string\n    while (source[i] != '\\0') {\n        destination[i] = source[i]; // Copy the character\n        i++;                        // Move to the next index\n    }\n    \n    // CRITICAL STEP: Copy the null terminator to make the destination a valid C string\n    destination[i] = '\\0';  \n    \n    // --- End of Manual String Copy ---\n\n    // Print the results\n    printf(\"\\nSource string: %s\\n\", source);\n    printf(\"Destination string: %s\\n\", destination);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter a string: CProgramming",
        "expected": "\nSource string: CProgramming\nDestination string: CProgramming\n"
      },
      {
        "input": "Enter a string: Hello",
        "expected": "\nSource string: Hello\nDestination string: Hello\n"
      },
      {
        "input": "Enter a string: World123",
        "expected": "\nSource string: World123\nDestination string: World123\n"
      }
    ]
  },
  {
    "id": 15,
    "title": "Simple for loop pattern",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that uses nested for loops to print a right-angled triangle pattern of asterisks (*) with 5 rows.",
    "inputFormat": "No user input is required. The number of rows is set to 5 in the program.",
    "outputFormat": "A right-angled triangle pattern of asterisks, with 1 asterisk in the first row and 5 in the fifth.",
    "solution": {
      "explanation": "This pattern is generated using **nested loops**. The outer `for` loop controls the number of rows ($i$), iterating from 1 to 5. The inner `for` loop controls the number of asterisks printed in the current row. Since we want $i$ stars in row $i$, the inner loop runs $j$ from 1 to $i$. After the inner loop completes, `printf(\"\\n\")` moves the output to the next line.",
      "code": "#include <stdio.h>\n\nint main() {\n    int rows = 5;\n    int i, j;\n\n    // Outer loop for the number of rows\n    for (i = 1; i <= rows; i++) {\n        // Inner loop for the number of stars in the current row\n        for (j = 1; j <= i; j++) {\n            printf(\"*\");\n        }\n        printf(\"\\n\"); // Move to the next line after completing a row\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "No user input.",
        "expected": "*\n**\n***\n****\n*****\n"
      }
    ]
  },
  {
    "id": 16,
    "title": "Swap two numbers (using pointers)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that uses a function and pointers to swap the values of two integer variables. The program should show the values before and after the swap.",
    "inputFormat": "The initial values of the two numbers are pre-defined in the main function.",
    "outputFormat": "Print the values of the two variables before and after the function call.",
    "solution": {
      "explanation": "To allow a function to modify variables outside its scope, C uses **pass-by-reference** via pointers. The function receives the addresses of the variables (`int *a`, `int *b`). Inside the function, the **dereference operator** (`*`) is used to access the values stored at those addresses (`*a`, `*b`). The swap operation involves three steps using a temporary variable, applied to the dereferenced values.",
      "code": "#include <stdio.h>\n\n// Function to swap two integers using pointers\nvoid swap(int *a, int *b) {\n    int temp;\n    \n    // Dereference *a to get the value, store it in temp\n    temp = *a;\n    \n    // Dereference *b to get its value, and assign it to *a\n    *a = *b;\n    \n    // Assign the original value of *a (stored in temp) to *b\n    *b = temp;\n}\n\nint main() {\n    int a = 10;\n    int b = 20;\n\n    printf(\"Before swap: a = %d, b = %d\\n\", a, b);\n\n    // Pass the addresses of a and b using the address-of operator (&)\n    swap(&a, &b);\n\n    printf(\"After swap: a = %d, b = %d\\n\", a, b);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Pre-defined variables: a = 10, b = 20",
        "expected": "Before swap: a = 10, b = 20\nAfter swap: a = 20, b = 10\n"
      },
      {
        "input": "Pre-defined variables: a = -5, b = 100",
        "expected": "Before swap: a = -5, b = 100\nAfter swap: a = 100, b = -5\n"
      }
    ]
  },
  {
    "id": 17,
    "title": "Pointer Arithmetic basic",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program to demonstrate basic pointer arithmetic by using a pointer to traverse and print the elements of an integer array.",
    "inputFormat": "The array is pre-defined in the code.",
    "outputFormat": "Print the elements of the array using pointer arithmetic and the dereference operator.",
    "solution": {
      "explanation": "Pointer arithmetic is fundamental in C. When an integer pointer `ptr` is incremented (`ptr++`), its memory address increases by `sizeof(int)` (typically 4 bytes), automatically pointing it to the next element in the array. By initializing the pointer to the array's start address (`int *ptr = arr;`), we can traverse the entire array using `ptr++` and access the value at the current position using the dereference operator `*ptr`.",
      "code": "#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int size = sizeof(arr) / sizeof(arr[0]);\n    \n    // Initialize a pointer to point to the first element of the array\n    int *ptr = arr;  \n    \n    printf(\"Array elements (using pointer arithmetic): \");\n    \n    // Loop through the array using pointer arithmetic\n    for (int i = 0; i < size; i++) {\n        // *ptr dereferences the pointer to get the value\n        printf(\"%d \", *ptr);\n        \n        // ptr++ moves the pointer to the next element (size of int)\n        ptr++;  \n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Pre-defined array: {10, 20, 30, 40, 50}",
        "expected": "Array elements (using pointer arithmetic): 10 20 30 40 50 \n"
      }
    ]
  },
  {
    "id": 18,
    "title": "Struct definition and basic usage",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that defines a struct named Student with fields for name (a string), id (an integer), and gpa (a float). The program should then create a student variable, assign values to its fields, and print them.",
    "inputFormat": "No user input is required; the values are assigned directly in the code.",
    "outputFormat": "Print the student's name, ID, and GPA in a clear format.",
    "solution": {
      "explanation": "A structure (`struct`) is a user-defined data type used to group related members of different types (e.g., `char[]` for name, `int` for id, `float` for gpa). We declare a variable of the structure type. The **dot operator** (`.`) is used to access and assign values to the individual members of the structure instance.",
      "code": "#include <stdio.h>\n\n// Define the Student structure\nstruct Student {\n    char name[50];\n    int id;\n    float gpa;\n};\n\nint main() {\n    // Declare a structure variable\n    struct Student s1;\n\n    // --- Assign values to the structure members ---\n    // Use strcpy for strings (or manual copy), direct assignment for others\n    // For simplicity, we directly assign to char array assuming a small name\n    snprintf(s1.name, sizeof(s1.name), \"Alice Smith\");\n    s1.id = 101;\n    s1.gpa = 3.75;\n\n    // --- Print the structure members ---\n    printf(\"Student Record:\\n\");\n    printf(\"Name: %s\\n\", s1.name);\n    printf(\"ID: %d\\n\", s1.id);\n    printf(\"GPA: %.2f\\n\", s1.gpa);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Pre-defined student: Alice Smith, ID: 101, GPA: 3.75",
        "expected": "Student Record:\nName: Alice Smith\nID: 101\nGPA: 3.75\n"
      }
    ]
  },
  {
    "id": 19,
    "title": "Simple menu-driven program (switch)",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that presents a simple menu to the user with three options: 1. Sum, 2. Subtract, 3. Exit. The program should use a switch statement to perform the chosen operation on two pre-defined numbers.",
    "inputFormat": "The program should prompt the user to enter their choice (1, 2, or 3).",
    "outputFormat": "Based on the choice, print the result of the calculation or an exit message.",
    "solution": {
      "explanation": "The `switch` statement handles multi-way branching based on the value of a single variable (`choice`). Each option is a `case`. The **`break`** statement is crucial after each `case` block to prevent 'fall-through' into the next case's execution. The `default` case handles any input that doesn't match the explicitly listed cases.",
      "code": "#include <stdio.h>\n\nint main() {\n    int choice;\n    int num1 = 10, num2 = 20;\n    int result;\n\n    printf(\"Simple Calculator Menu:\\n\");\n    printf(\"1. Sum\\n\");\n    printf(\"2. Subtract\\n\");\n    printf(\"3. Exit\\n\");\n    printf(\"Enter your choice (1-3): \");\n    scanf(\"%d\", &choice);\n\n    // Use a switch statement to handle the choice\n    switch (choice) {\n        case 1:\n            result = num1 + num2;\n            printf(\"Result: %d\\n\", result);\n            break;\n        case 2:\n            // Subtract num2 from num1\n            result = num1 - num2; \n            printf(\"Result: %d\\n\", result);\n            break;\n        case 3:\n            printf(\"Exiting the program. Goodbye!\\n\");\n            break;\n        default:\n            printf(\"Invalid choice. Please enter 1, 2, or 3.\\n\");\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter your choice (1-3): 1",
        "expected": "Simple Calculator Menu:\n1. Sum\n2. Subtract\n3. Exit\nEnter your choice (1-3): Result: 30\n"
      },
      {
        "input": "Enter your choice (1-3): 2",
        "expected": "Simple Calculator Menu:\n1. Sum\n2. Subtract\n3. Exit\nEnter your choice (1-3): Result: -10\n"
      },
      {
        "input": "Enter your choice (1-3): 3",
        "expected": "Simple Calculator Menu:\n1. Sum\n2. Subtract\n3. Exit\nEnter your choice (1-3): Exiting the program. Goodbye!\n"
      },
      {
        "input": "Enter your choice (1-3): 5",
        "expected": "Simple Calculator Menu:\n1. Sum\n2. Subtract\n3. Exit\nEnter your choice (1-3): Invalid choice. Please enter 1, 2, or 3.\n"
      }
    ]
  },
  {
    "id": 20,
    "title": "Decimal to Binary conversion",
    "language": "C",
    "difficulty": "Easy",
    "problemStatement": "Write a C program that takes a non-negative decimal integer as input and converts it into its binary equivalent using a manual loop-based method (not built-in functions).",
    "inputFormat": "The program should prompt the user to enter a non-negative decimal integer.",
    "outputFormat": "Print the binary representation of the input number.",
    "solution": {
      "explanation": "Decimal-to-binary conversion is achieved by the method of **repeated division by 2**. The remainder of each division is the next binary digit (starting from the least significant bit). Since C doesn't easily allow printing in reverse, we store the result as a single large number (`binary_num`) by multiplying each remainder by an increasing power of 10 (`base`). The process continues until the original number (`temp_num`) is reduced to 0.",
      "code": "#include <stdio.h>\n\nint main() {\n    int decimal_num, temp_num;\n    long long binary_num = 0; // Use long long for the result\n    int remainder, base = 1;\n\n    // Prompt and read the decimal number\n    printf(\"Enter a decimal number: \");\n    scanf(\"%d\", &decimal_num);\n\n    temp_num = decimal_num;\n    \n    // Handle the special case of 0\n    if (decimal_num == 0) {\n        printf(\"Binary equivalent of 0 is: 0\\n\");\n        return 0;\n    }\n\n    // --- Decimal to Binary Conversion ---\n    while (temp_num > 0) {\n        remainder = temp_num % 2; // Get the remainder (0 or 1)\n        temp_num /= 2;            // Divide the number by 2\n        \n        // Add the remainder to the binary result, scaled by the current position\n        binary_num += remainder * base; \n        \n        base *= 10;                // Move to the next power of 10\n    }\n    // --- End of Conversion ---\n\n    // Print the result\n    printf(\"Binary equivalent of %d is: %lld\\n\", decimal_num, binary_num);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter a decimal number: 13",
        "expected": "Binary equivalent of 13 is: 1101\n"
      },
      {
        "input": "Enter a decimal number: 0",
        "expected": "Binary equivalent of 0 is: 0\n"
      },
      {
        "input": "Enter a decimal number: 20",
        "expected": "Binary equivalent of 20 is: 10100\n"
      },
      {
        "input": "Enter a decimal number: 1",
        "expected": "Binary equivalent of 1 is: 1\n"
      }
    ]
  },
  {
    "id": 21,
    "title": "Implement a Linked List (Insert/Delete/Traversal)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement a basic singly Linked List. The program should define the structure for a node and include functions for:\nInsertion at the beginning of the list.\nTraversal (printing all elements).",
    "inputFormat": "The program should take a sequence of integers as input and insert them into the list. For simplicity, you can hardcode the values to insert (e.g., 10, 20, 30).",
    "outputFormat": "The program must print the elements of the linked list in the order they appear.",
    "solution": {
      "explanation": "A **Singly Linked List** node is a structure containing data and a pointer to the next node (`struct Node *next`). We use a global `head` pointer that points to the start of the list. **Insertion at the Beginning** is an $O(1)$ operation: we allocate a new node, set its data, make its `next` pointer point to the current `head`, and finally update `head` to point to the new node. **Traversal** involves moving a temporary pointer from `head` to `NULL`, printing the data at each step.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a Linked List node\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\n// Global head pointer (or pass by reference/double pointer)\nstruct Node *head = NULL;\n\n// Function to insert a new node at the beginning\nvoid insert(int new_data) {\n    // 1. Allocate memory for new node\n    struct Node *new_node = (struct Node*) malloc(sizeof(struct Node));\n\n    // Check if memory allocation was successful\n    if (new_node == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        return;\n    }\n\n    // 2. Put in the data\n    new_node->data = new_data;\n\n    // 3. Make next of new node as head\n    new_node->next = head;\n\n    // 4. Move the head to point to the new node\n    head = new_node;\n}\n\n// Function to print the linked list\nvoid display() {\n    struct Node *current = head;\n    printf(\"Linked List: \");\n    while (current != NULL) {\n        printf(\"%d\", current->data);\n        if (current->next != NULL) {\n            printf(\" -> \");\n        }\n        current = current->next;\n    }\n    printf(\" -> NULL\\n\");\n}\n\nint main() {\n    // Hardcoded insertions for demonstration\n    insert(10);\n    insert(20);\n    insert(30);\n    \n    // Display the list\n    display();\n\n    // In a real program, you'd free the allocated memory here\n    // For simplicity, we skip freeing the memory in this basic example.\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Hardcoded insertions: 10, 20, 30)",
        "expected": "Linked List: 30 -> 20 -> 10 -> NULL\n"
      },
      {
        "input": "(Hardcoded insertions: 5, 4)",
        "expected": "Linked List: 4 -> 5 -> NULL\n"
      },
      {
        "input": "(Hardcoded insertions: 100)",
        "expected": "Linked List: 100 -> NULL\n"
      }
    ]
  },
  {
    "id": 22,
    "title": "Implement Stack from scratch (using array)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement a Stack data structure using a fixed-size array. The implementation should include the primary stack operations: push (to add an element) and pop (to remove the top element). The program must also handle the Stack Overflow and Stack Underflow conditions.",
    "inputFormat": "The program can have hardcoded calls to push and pop to demonstrate functionality.",
    "outputFormat": "The output should show the result of the operations, including the popped elements and messages for overflow/underflow.",
    "solution": {
      "explanation": "An array-based **Stack** uses a variable, `top`, to track the index of the last element inserted. Initially, `top = -1`. The **`push`** operation increments `top` and inserts data, but first checks for **Stack Overflow** ($top == MAX\\_SIZE - 1$). The **`pop`** operation retrieves the element at `stack[top]` and then decrements `top`, but first checks for **Stack Underflow** ($top == -1$). Both operations are $O(1)$.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 5 // Fixed size for the array-based stack\n\nint stack[MAX_SIZE];\nint top = -1; // Initialize top to -1 (empty stack)\n\n// Function to check if the stack is full\nint isFull() {\n    return top == MAX_SIZE - 1;\n}\n\n// Function to check if the stack is empty\nint isEmpty() {\n    return top == -1;\n}\n\n// Function to add an element to the stack\nvoid push(int data) {\n    if (isFull()) {\n        printf(\"Stack Overflow! Cannot push %d.\\n\", data);\n    } else {\n        top++; // Increment top\n        stack[top] = data; // Insert data\n        printf(\"Element %d pushed to Stack.\\n\", data);\n    }\n}\n\n// Function to remove an element from the stack\nint pop() {\n    if (isEmpty()) {\n        printf(\"Stack Underflow! Stack is empty.\\n\");\n        return -1; // Return a sentinel value for error\n    } else {\n        int data = stack[top]; // Get top element\n        top--; // Decrement top\n        return data;\n    }\n}\n\nint main() {\n    push(10);\n    push(20);\n    \n    printf(\"Popped element: %d\\n\", pop());\n    \n    push(30);\n    \n    printf(\"Popped element: %d\\n\", pop());\n    printf(\"Popped element: %d\\n\", pop());\n    \n    // Demonstrate underflow\n    printf(\"Popped element: %d\\n\", pop());  \n    \n    // Demonstrate overflow\n    push(40);\n    push(50);\n    push(60);\n    push(70);\n    push(80);\n    push(90); // This will cause overflow\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Sequence of operations: push 10, push 20, pop, push 30, pop)",
        "expected": "Element 10 pushed to Stack.\nElement 20 pushed to Stack.\nPopped element: 20\nElement 30 pushed to Stack.\nPopped element: 30\nPopped element: -1\nPopped element: -1\nStack Underflow! Stack is empty.\nPopped element: -1\nElement 40 pushed to Stack.\nElement 50 pushed to Stack.\nElement 60 pushed to Stack.\nElement 70 pushed to Stack.\nElement 80 pushed to Stack.\nStack Overflow! Cannot push 90.\n"
      }
    ]
  },
  {
    "id": 23,
    "title": "Implement Queue from scratch (using array)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement a Queue data structure using a fixed-size array. The implementation should include the primary queue operations: enqueue (to add an element at the rear) and dequeue (to remove an element from the front). The program must handle Queue Overflow and Underflow conditions.",
    "inputFormat": "The program can have hardcoded calls to enqueue and dequeue to demonstrate functionality.",
    "outputFormat": "The output should show the result of the operations, including the dequeued elements and messages for overflow/underflow.",
    "solution": {
      "explanation": "An array-based **Queue** (FIFO) requires two indices: `front` (removal point) and `rear` (insertion point). **`enqueue`** increments `rear` and inserts data, checking for **Overflow** ($rear == MAX\\_SIZE - 1$). **`dequeue`** retrieves the element at `front` and increments `front`, checking for **Underflow** ($front == -1$ or $front > rear$). When the queue becomes empty after a dequeue, both `front` and `rear` are reset to $-1$. Both operations are $O(1)$.",
      "code": "#include <stdio.h>\n\n#define MAX_SIZE 5\n\nint queue[MAX_SIZE];\nint front = -1; // Index of the front element\nint rear = -1;  // Index of the rear element\n\n// Function to check if the queue is full\nint isFull() {\n    return rear == MAX_SIZE - 1;\n}\n\n// Function to check if the queue is empty\nint isEmpty() {\n    return front == -1 || front > rear;\n}\n\n// Function to add an element to the queue (at the rear)\nvoid enqueue(int data) {\n    if (isFull()) {\n        printf(\"Queue Overflow! Cannot enqueue %d.\\n\", data);\n    } else {\n        if (front == -1) {\n            front = 0; // Set front to 0 when the first element is added\n        }\n        rear++; // Move rear\n        queue[rear] = data; // Insert data\n        printf(\"Element %d enqueued to Queue.\\n\", data);\n    }\n}\n\n// Function to remove an element from the queue (from the front)\nint dequeue() {\n    if (isEmpty()) {\n        printf(\"Queue Underflow! Queue is empty.\\n\");\n        return -1; // Return a sentinel value\n    } else {\n        int data = queue[front]; // Get front element\n        front++; // Move front\n        \n        // If all elements are removed, reset the queue\n        if (front > rear) {\n            front = rear = -1;\n        }\n        return data;\n    }\n}\n\nint main() {\n    enqueue(10);\n    enqueue(20);\n    \n    printf(\"Dequeued element: %d\\n\", dequeue());\n    \n    enqueue(30);\n    enqueue(40);\n    enqueue(50);\n    \n    // Demonstrate overflow\n    enqueue(60);  \n    \n    printf(\"Dequeued element: %d\\n\", dequeue());\n    printf(\"Dequeued element: %d\\n\", dequeue());\n    printf(\"Dequeued element: %d\\n\", dequeue());\n    printf(\"Dequeued element: %d\\n\", dequeue());\n\n    // Demonstrate underflow\n    printf(\"Dequeued element: %d\\n\", dequeue()); \n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Sequence of operations: enqueue 10, enqueue 20, dequeue, enqueue 30, dequeue)",
        "expected": "Element 10 enqueued to Queue.\nElement 20 enqueued to Queue.\nDequeued element: 10\nElement 30 enqueued to Queue.\nElement 40 enqueued to Queue.\nElement 50 enqueued to Queue.\nQueue Overflow! Cannot enqueue 60.\nDequeued element: 20\nDequeued element: 30\nDequeued element: 40\nDequeued element: 50\nQueue Underflow! Queue is empty.\nDequeued element: -1\n"
      }
    ]
  },
  {
    "id": 24,
    "title": "Binary Search (Recursive)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement the Binary Search algorithm using a recursive function. The program must search for a specific key in a sorted integer array.",
    "inputFormat": "The program should use a hardcoded sorted array and a search key.",
    "outputFormat": "The program must print the index of the key if found, or a message indicating that the key was not found.",
    "solution": {
      "explanation": "**Binary Search** is an $O(\\log N)$ algorithm for searching in a **sorted** array. The recursive version uses the current search range defined by `low` and `high` indices. The **Base Case** is when `low > high` (not found). In the **Recursive Step**, the `mid` element is compared to the `key`. If `arr[mid]` is a match, return `mid`. Otherwise, the function recursively calls itself on either the left half (if `key` < `arr[mid]`) or the right half (if `key` > `arr[mid]`), effectively halving the search space each time.",
      "code": "#include <stdio.h>\n\n// Recursive Binary Search function\n// Returns the index of key, or -1 if not present\nint recursiveBinarySearch(int arr[], int low, int high, int key) {\n    if (low <= high) {\n        int mid = low + (high - low) / 2; // Avoids potential overflow\n\n        // Base case: Element found\n        if (arr[mid] == key) {\n            return mid;\n        }\n\n        // Key is smaller, search in left subarray\n        if (arr[mid] > key) {\n            return recursiveBinarySearch(arr, low, mid - 1, key);\n        }\n\n        // Key is larger, search in right subarray\n        return recursiveBinarySearch(arr, mid + 1, high, key);\n    }\n\n    // Base case: Element not present\n    return -1;  \n}\n\nint main() {\n    int arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int key = 23;  \n    \n    int result = recursiveBinarySearch(arr, 0, n - 1, key);\n\n    if (result != -1) {\n        printf(\"Element %d found at index %d.\\n\", key, result);\n    } else {\n        printf(\"Element %d not found in the array.\\n\", key);\n    }\n    \n    // Test for a key not present\n    key = 99;\n    result = recursiveBinarySearch(arr, 0, n - 1, key);\n    if (result == -1) {\n        printf(\"Element %d not found in the array.\\n\", key);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Array: {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, Key: 23)",
        "expected": "Element 23 found at index 5.\nElement 99 not found in the array.\n"
      },
      {
        "input": "(Array: {1, 3, 5, 7}, Key: 1)",
        "expected": "Element 1 found at index 0.\nElement 99 not found in the array.\n"
      },
      {
        "input": "(Array: {1, 3, 5, 7}, Key: 7)",
        "expected": "Element 7 found at index 3.\nElement 99 not found in the array.\n"
      }
    ]
  },
  {
    "id": 25,
    "title": "Bubble Sort/Insertion Sort",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to sort an array of integers using the **Bubble Sort** algorithm. The sorting must be done in-place.",
    "inputFormat": "Use a hardcoded unsorted integer array.",
    "outputFormat": "Print the array before and after sorting.",
    "solution": {
      "explanation": "**Bubble Sort** is a simple comparison sort with an average and worst-case complexity of $O(N^2)$. It works by repeatedly stepping through the list, comparing adjacent pairs, and swapping them if they are in the wrong order. The **outer loop** controls the number of passes ($N-1$), and the **inner loop** performs the comparisons and swaps. In each pass, the largest unsorted element 'bubbles up' to its final, correct position at the end of the unsorted portion of the array.",
      "code": "#include <stdio.h>\n\n// Function to swap two elements\nvoid swap(int *xp, int *yp) {\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\n// Function to perform Bubble Sort\nvoid bubbleSort(int arr[], int n) {\n    int i, j;\n    // Outer loop for passes (n-1 passes are needed)\n    for (i = 0; i < n - 1; i++) {\n        // Inner loop for comparison and swapping\n        // In the i-th pass, the largest i elements are already in place\n        for (j = 0; j < n - i - 1; j++) {\n            // Swap if the element found is greater than the next element\n            if (arr[j] > arr[j + 1]) {\n                swap(&arr[j], &arr[j + 1]);\n            }\n        }\n    }\n}\n\n// Function to print the array\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    printf(\"Unsorted array: \");\n    printArray(arr, n);\n\n    bubbleSort(arr, n);\n    \n    printf(\"Sorted array (Bubble Sort): \");\n    printArray(arr, n);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Array: {64, 34, 25, 12, 22, 11, 90})",
        "expected": "Unsorted array: 64 34 25 12 22 11 90 \nSorted array (Bubble Sort): 11 12 22 25 34 64 90 \n"
      },
      {
        "input": "(Array: {5, 4, 3, 2, 1})",
        "expected": "Unsorted array: 5 4 3 2 1 \nSorted array (Bubble Sort): 1 2 3 4 5 \n"
      },
      {
        "input": "(Array: {1, 2, 3, 4, 5})",
        "expected": "Unsorted array: 1 2 3 4 5 \nSorted array (Bubble Sort): 1 2 3 4 5 \n"
      }
    ]
  },
  {
    "id": 26,
    "title": "Merge two sorted arrays",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program that takes two positive integers as input and calculates their Greatest Common Divisor (GCD) and Least Common Multiple (LCM).",
    "inputFormat": "The program should prompt the user to enter two positive integers.",
    "outputFormat": "The program must print both the GCD and the LCM of the two numbers.",
    "solution": {
      "explanation": "This linear time $O(M+N)$ merging technique is the core component of Merge Sort. Since both source arrays (A and B) are already sorted, we use three index pointers ($i, j, k$). We continuously compare the elements $A[i]$ and $B[j]$, copy the smaller element to the merged array $C[k]$, and increment the respective source pointer and the destination pointer $k$. Once one array is fully copied, the remaining elements of the other array are simply appended to $C$.",
      "code": "#include <stdio.h>\n\nint main() {\n    int num1, num2, a, b, temp, gcd, lcm;\n\n    // Prompt and read the two integers\n    printf(\"Enter two positive integers: \");\n    scanf(\"%d %d\", &num1, &num2);\n\n    // Make copies for GCD calculation\n    a = num1;\n    b = num2;\n\n    // --- GCD Calculation (Euclidean Algorithm) ---\n    while (b != 0) {\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n    gcd = a; // GCD is stored in 'a'\n\n    // --- LCM Calculation ---\n    // Formula: LCM(a, b) = (|a * b|) / GCD(a, b)\n    lcm = (num1 * num2) / gcd;\n\n    // Print the results\n    printf(\"\\nGCD of %d and %d is %d\\n\", num1, num2, gcd);\n    printf(\"LCM of %d and %d is %d\\n\", num1, num2, lcm);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Array A: {1, 3, 5, 7}, Array B: {2, 4, 6, 8, 9})",
        "expected": "Array A: 1 3 5 7 \nArray B: 2 4 6 8 9 \nMerged Array C: 1 2 3 4 5 6 7 8 9 \n"
      },
      {
        "input": "(Array A: {10, 20}, Array B: {5, 15, 25})",
        "expected": "Array A: 10 20 \nArray B: 5 15 25 \nMerged Array C: 5 10 15 20 25 \n"
      },
      {
        "input": "(Array A: {1, 2}, Array B: {})",
        "expected": "Array A: 1 2 \nArray B: \nMerged Array C: 1 2 \n"
      }
    ]
  },
  {
    "id": 27,
    "title": "Dynamic Array allocation (malloc)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program that demonstrates dynamic memory allocation for an array. The program should:\n\n1.  Prompt the user for the number of elements (N).\n2.  Dynamically allocate memory for N integers using `malloc()`.\n3.  Read N integer values from the user and store them in the allocated memory.\n4.  Calculate and print the sum of these elements.\n5.  Free the allocated memory using `free()`.",
    "inputFormat": "First, an integer for the size N, followed by N integers.",
    "outputFormat": "The program must print the sum of the elements and confirm the memory was freed.",
    "solution": {
      "explanation": "The program uses **Dynamic Memory Allocation** because the array size is determined at runtime by the user input $N$. The `malloc(N * sizeof(int))` function allocates a block of memory on the heap large enough for $N$ integers and returns a `void*` pointer, which is then cast to `int*`. The crucial final step is calling `free(arr)` to return the allocated memory to the system, preventing **memory leaks**.",
      "code": "#include <stdio.h>\n#include <stdlib.h> // Required for malloc and free\n\nint main() {\n    int n, i, sum = 0;\n    int *arr; // Pointer to hold the base address of the dynamic array\n\n    // 1. Prompt and read the number of elements\n    printf(\"Enter the number of elements: \");\n    if (scanf(\"%d\", &n) != 1 || n <= 0) {\n        printf(\"Invalid input for the number of elements.\\n\");\n        return 1;\n    }\n\n    // 2. Dynamically allocate memory for n integers\n    arr = (int*)malloc(n * sizeof(int)); \n\n    // 3. Check for allocation failure\n    if (arr == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        return 1;\n    }\n\n    // 4. Read the elements\n    printf(\"Enter %d integers: \", n);\n    for (i = 0; i < n; i++) {\n        if (scanf(\"%d\", &arr[i]) != 1) {\n            printf(\"Error reading element.\\n\");\n            free(arr);\n            return 1;\n        }\n        sum += arr[i]; // Calculate the sum while reading\n    }\n\n    // 5. Print the result\n    printf(\"\\nThe sum of the elements is: %d\\n\", sum);\n\n    // 6. Free the allocated memory\n    free(arr);\n    printf(\"Memory freed successfully.\\n\");\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enter the number of elements: 4\nEnter 4 integers: 10 20 30 40",
        "expected": "\nThe sum of the elements is: 100\nMemory freed successfully.\n"
      },
      {
        "input": "Enter the number of elements: 2\nEnter 2 integers: -5 15",
        "expected": "\nThe sum of the elements is: 10\nMemory freed successfully.\n"
      }
    ]
  },
  {
    "id": 28,
    "title": "Array of Pointers",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to demonstrate the use of an Array of Pointers to strings. Specifically, declare an array of character pointers, initialize it with several string literals (names of fruits), and then iterate through the array to print each string.",
    "inputFormat": "The strings (fruit names) should be hardcoded into the array of pointers.",
    "outputFormat": "Print each string, along with its index in the array.",
    "solution": {
      "explanation": "An **Array of Pointers to Characters** (`char *fruits[]`) is used to efficiently store a list of strings in C. Each element in the `fruits` array holds the starting memory address of a string literal. When we iterate through the array, `fruits[i]` is a `char*` pointer that is passed to `printf(\"%s\", ...)` to print the entire string sequence starting at that address. This approach saves space compared to a 2D character array if the string lengths vary widely.",
      "code": "#include <stdio.h>\n\nint main() {\n    // Declaration and initialization of an Array of Pointers to char (strings)\n    char *fruits[] = {\n        \"Apple\",\n        \"Banana\",\n        \"Cherry\",\n        \"Date\",\n        \"Elderberry\"\n    };\n\n    // Calculate the number of elements in the array\n    int size = sizeof(fruits) / sizeof(fruits[0]);\n\n    printf(\"List of Fruits:\\n\");\n    \n    // Iterate through the array of pointers\n    for (int i = 0; i < size; i++) {\n        // fruits[i] is a char* (the address of the i-th string)\n        printf(\"Fruit %d: %s\\n\", i, fruits[i]);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Hardcoded strings: \"Apple\", \"Banana\", \"Cherry\", \"Date\")",
        "expected": "List of Fruits:\nFruit 0: Apple\nFruit 1: Banana\nFruit 2: Cherry\nFruit 3: Date\nFruit 4: Elderberry\n"
      }
    ]
  },
  {
    "id": 29,
    "title": "Matrix Transpose",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to calculate the transpose of a 2D matrix. Given a matrix A of size $M \\times N$, its transpose $A^T$ is an $N \\times M$ matrix where the element at row $i$ and column $j$ in $A^T$ is the element at row $j$ and column $i$ in $A$. ($A^T[i][j]=A[j][i]$).",
    "inputFormat": "Use a hardcoded $3 \\times 2$ matrix.",
    "outputFormat": "Print the original matrix and its transposed matrix.",
    "solution": {
      "explanation": "Matrix transposition is the operation of converting a matrix $A$ of size $M \\times N$ into a matrix $B$ of size $N \\times M$, where the rows of $A$ become the columns of $B$. This is achieved by swapping the indices: $B[j][i] = A[i][j]$. Nested loops are used, where the outer loop iterates through the rows of $A$ ($i$) and the inner loop iterates through the columns of $A$ ($j$).",
      "code": "#include <stdio.h>\n\n#define ROWS 3\n#define COLS 2\n\n// Function to print a matrix\nvoid printMatrix(int matrix[ROWS][COLS], int r, int c) {\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    // Original Matrix (3x2)\n    int A[ROWS][COLS] = {\n        {1, 2},\n        {3, 4},\n        {5, 6}\n    };\n\n    // Transposed Matrix will be 2x3 (COLS x ROWS)\n    int B[COLS][ROWS]; \n\n    printf(\"Original Matrix (%dx%d):\\n\", ROWS, COLS);\n    // Note: This call to printMatrix is slightly simplified as C requires fixed dimensions for functions\n    // The dimensions are used to print the labels correctly.\n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            printf(\"%d \", A[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // --- Transpose Calculation ---\n    for (int i = 0; i < ROWS; i++) { // i is the row index of A\n        for (int j = 0; j < COLS; j++) { // j is the col index of A\n            // A[i][j] becomes B[j][i]\n            B[j][i] = A[i][j]; \n        }\n    }\n    // --- End of Transpose Calculation ---\n\n    printf(\"\\nTransposed Matrix (%dx%d):\\n\", COLS, ROWS);\n    // Note: When printing B, the dimensions are COLS x ROWS\n    for (int i = 0; i < COLS; i++) {\n        for (int j = 0; j < ROWS; j++) {\n            printf(\"%d \", B[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Original Matrix A (3x2): {{1, 2}, {3, 4}, {5, 6}})",
        "expected": "Original Matrix (3x2):\n1 2 \n3 4 \n5 6 \n\nTransposed Matrix (2x3):\n1 3 5 \n2 4 6 \n"
      }
    ]
  },
  {
    "id": 30,
    "title": "String Substring Search (Naive)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement the Naive String Substring Search algorithm. Given a main string (haystack) and a pattern string (needle), find the starting index of the first occurrence of the pattern in the main string. Do not use standard library functions like `strstr()`.",
    "inputFormat": "Use hardcoded main and pattern strings.",
    "outputFormat": "Print the starting index of the pattern if found, or a message indicating it was not found.",
    "solution": {
      "explanation": "The **Naive String Search** algorithm checks for the pattern (needle) at every possible starting position in the main string (haystack). The **outer loop** iterates through the haystack's possible starting indices $i$. The **inner loop** compares the `needle` character by character, starting from $i$. If a mismatch occurs, the inner loop breaks, and the outer loop moves to the next starting position ($i+1$). If the inner loop completes successfully (meaning $j$ reaches the full length of the needle), a match is found at index $i$.",
      "code": "#include <stdio.h>\n#include <string.h> // For strlen (allowed here to get lengths, but copy/search is manual)\n\n// Function to implement Naive String Search\nint naiveSearch(const char *haystack, const char *needle) {\n    int n = strlen(haystack); // Length of main string\n    int m = strlen(needle);    // Length of pattern\n\n    // Outer loop: iterate through all possible starting positions in haystack\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n\n        // Inner loop: check for pattern match starting at index i\n        for (j = 0; j < m; j++) {\n            if (haystack[i + j] != needle[j]) {\n                break; // Mismatch found, break inner loop and move to next starting position i\n            }\n        }\n\n        // If the inner loop completed (j reached m), a match is found\n        if (j == m) {\n            return i; // Return the starting index\n        }\n    }\n\n    return -1; // Pattern not found\n}\n\nint main() {\n    const char *haystack = \"ABABDABACDABABCABAB\";\n    const char *needle = \"ABABCABAB\";\n    \n    int result = naiveSearch(haystack, needle);\n\n    if (result != -1) {\n        printf(\"Pattern found at index %d.\\n\", result);\n    } else {\n        printf(\"Pattern not found.\\n\");\n    }\n    \n    // Another test case\n    const char *needle2 = \"XYZ\";\n    result = naiveSearch(haystack, needle2);\n    if (result == -1) {\n        printf(\"Pattern not found.\\n\");\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Haystack: \"ABABDABACDABABCABAB\", Needle: \"ABABCABAB\")",
        "expected": "Pattern found at index 10.\nPattern not found.\n"
      },
      {
        "input": "(Haystack: \"AABAACAADAABAABA\", Needle: \"AABA\")",
        "expected": "Pattern found at index 0.\nPattern not found.\n"
      },
      {
        "input": "(Haystack: \"SEARCH\", Needle: \"RCH\")",
        "expected": "Pattern found at index 3.\nPattern not found.\n"
      }
    ]
  },
  {
    "id": 31,
    "title": "Reverse Words in a String",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to reverse the order of words in a given string. The individual characters within each word should remain in their original order. The words are separated by a single space.",
    "inputFormat": "Use a hardcoded string.",
    "outputFormat": "Print the original string and the string with the words reversed.",
    "solution": {
      "explanation": "The most direct way to reverse the order of words in C is to use the standard library function **`strtok`** to perform **tokenization**. This function splits the input string into tokens (words) based on a specified delimiter (a space, in this case). We store the pointers to these tokens in an array. Finally, we iterate through the array of pointers in **reverse order** to print the words, achieving the desired result.",
      "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h> // For malloc/free if necessary, but not strictly needed here\n\n#define MAX_WORDS 20\n\n// Function to reverse the order of words\nvoid reverseWords(char *str) {\n    // Array to store pointers to each word\n    char *words[MAX_WORDS];\n    int word_count = 0;\n\n    // Use strtok to tokenize the string (words separated by space)\n    char *token = strtok(str, \" \");\n    while (token != NULL && word_count < MAX_WORDS) {\n        words[word_count++] = token; // Store the pointer to the word\n        token = strtok(NULL, \" \"); // Get the next token\n    }\n\n    // Print the words in reverse order\n    printf(\"Reversed Words: \");\n    for (int i = word_count - 1; i >= 0; i--) {\n        printf(\"%s\", words[i]);\n        if (i > 0) {\n            printf(\" \"); // Print space between words\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    // Note: strtok modifies the original string, so we use a char array.\n    char str[] = \"Gemini is a helpful assistant\";  \n    \n    printf(\"Original String: %s\\n\", str);\n    \n    // We need a temporary copy because strtok modifies str\n    char temp_str[100];\n    strcpy(temp_str, str);  \n\n    reverseWords(temp_str);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(String: \"Gemini is a helpful assistant\")",
        "expected": "Original String: Gemini is a helpful assistant\nReversed Words: assistant helpful a is Gemini\n"
      },
      {
        "input": "(String: \"one two three\")",
        "expected": "Original String: one two three\nReversed Words: three two one\n"
      },
      {
        "input": "(String: \"hello\")",
        "expected": "Original String: hello\nReversed Words: hello\n"
      }
    ]
  },
  {
    "id": 32,
    "title": "Tower of Hanoi",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to solve the classic Tower of Hanoi puzzle using **recursion**. The program should print the sequence of moves required to transfer N disks from a source peg to a destination peg, using an auxiliary peg.",
    "inputFormat": "Use a hardcoded integer N for the number of disks.",
    "outputFormat": "Print each move in the format: \"Move disk N from SOURCE to DESTINATION\".",
    "solution": {
      "explanation": "The **Tower of Hanoi** is a classic problem solved by **recursion**. The solution for $N$ disks relies on the assumption that we can solve the problem for $N-1$ disks. The three recursive steps are:\n\n1.  Move $N-1$ disks from the **Source** to the **Auxiliary** peg.\n2.  Move the largest disk ($N$) from the **Source** to the **Destination** peg.\n3.  Move the $N-1$ disks from the **Auxiliary** peg to the **Destination** peg.",
      "code": "#include <stdio.h>\n\n// Recursive function to solve Tower of Hanoi\n// n: number of disks\n// source, auxiliary, destination: names of the pegs\nvoid towerOfHanoi(int n, char source, char destination, char auxiliary) {\n    // Base Case: Only one disk to move\n    if (n == 1) {\n        printf(\"Move disk 1 from %c to %c\\n\", source, destination);\n        return;\n    }\n\n    // Step 1: Move n-1 disks from Source to Auxiliary, using Destination\n    towerOfHanoi(n - 1, source, auxiliary, destination);\n\n    // Step 2: Move the largest disk n from Source to Destination\n    printf(\"Move disk %d from %c to %c\\n\", n, source, destination);\n\n    // Step 3: Move n-1 disks from Auxiliary to Destination, using Source\n    towerOfHanoi(n - 1, auxiliary, destination, source);\n}\n\nint main() {\n    int num_disks = 3; // The number of disks\n    char peg_A = 'A';  // Source peg\n    char peg_B = 'B';  // Auxiliary peg\n    char peg_C = 'C';  // Destination peg\n\n    printf(\"Tower of Hanoi with %d disks:\\n\", num_disks);\n    towerOfHanoi(num_disks, peg_A, peg_C, peg_B);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Number of disks: 3)",
        "expected": "Tower of Hanoi with 3 disks:\nMove disk 1 from A to C\nMove disk 2 from A to B\nMove disk 1 from C to B\nMove disk 3 from A to C\nMove disk 1 from B to A\nMove disk 2 from B to C\nMove disk 1 from A to C\n"
      },
      {
        "input": "(Number of disks: 1)",
        "expected": "Tower of Hanoi with 1 disks:\nMove disk 1 from A to C\n"
      }
    ]
  },
  {
    "id": 33,
    "title": "Generate all combinations",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program using **recursion** to generate and print all combinations (subsets) of a given set of characters. For a set of N items, the program should list all $2^N$ possible subsets, including the empty set.",
    "inputFormat": "Use a hardcoded string to represent the set of characters (e.g., \"ABC\").",
    "outputFormat": "Print each combination on a new line.",
    "solution": {
      "explanation": "This problem uses **backtracking** by modeling the choices for each element. For every character in the input set, there are two recursive choices: **include** the character in the current combination or **exclude** it. \n\n1.  **Include:** Add the character, recurse to the next index, and then backtrack by removing it.\n2.  **Exclude:** Do not add the character, and simply recurse to the next index.\n\nThe **Base Case** is reached when the index reaches the end of the input string, at which point the current combination is printed.",
      "code": "#include <stdio.h>\n#include <string.h>\n\n// Recursive function to generate all combinations\n// set: The original input string/set of characters\n// combination: The current combination being built\n// index: The current character index being considered\nvoid generateCombinations(const char *set, char *combination, int index) {\n    int n = strlen(set);\n\n    // Base Case: If all characters have been considered\n    if (index == n) {\n        // The combination string needs a null terminator for printing\n        printf(\"{%s}\\n\", combination);  \n        return;\n    }\n\n    // 1. Recursive Step (Include the current character)\n    int len = strlen(combination);\n    combination[len] = set[index]; // Add the character\n    combination[len + 1] = '\\0';  // Null-terminate the new combination\n    generateCombinations(set, combination, index + 1);\n\n    // 2. Recursive Step (Exclude the current character - Backtrack)\n    combination[len] = '\\0'; // Remove the last added character (backtrack)\n    generateCombinations(set, combination, index + 1);\n}\n\nint main() {\n    const char *set = \"ABC\";\n    \n    // We need an array to build the combination string. Max size is set length + 1 (\\0).\n    char combination[4] = \"\";  \n\n    printf(\"Combinations for set: %s\\n\", set);\n    \n    // Start the generation with an empty combination and index 0\n    generateCombinations(set, combination, 0);  \n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Set: \"ABC\")",
        "expected": "Combinations for set: ABC\n{}\n{C}\n{B}\n{BC}\n{A}\n{AC}\n{AB}\n{ABC}\n"
      }
    ]
  },
  {
    "id": 34,
    "title": "Permutations of a string (simple swap)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program using **recursion** and a simple swap-based technique to generate and print all unique permutations of a given string.",
    "inputFormat": "Use a hardcoded string with unique characters (e.g., \"ABC\").",
    "outputFormat": "Print each permutation on a new line.",
    "solution": {
      "explanation": "This recursive solution generates permutations using a **swap-based backtracking** approach. We iterate through the substring from the current starting index $l$ to the end $r$.\n\n1.  **Choose:** Swap the character at $str[l]$ with $str[i]$ (fixing the character at the current position $l$).\n2.  **Recurse:** Call `permute(str, l + 1, r)` to solve the rest of the string.\n3.  **Backtrack:** Swap the characters back (`str[l]` and `str[i]`) to restore the original state, allowing the next iteration of the loop to try a different character at position $l$.",
      "code": "#include <stdio.h>\n#include <string.h>\n\n// Utility function to swap two characters\nvoid swap(char *x, char *y) {\n    char temp;\n    temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n// Recursive function to generate permutations\n// str: The string array\n// l: Starting index of the current substring\n// r: Ending index of the current substring\nvoid permute(char *str, int l, int r) {\n    int i;\n    // Base Case: When the starting index reaches the end, a permutation is complete\n    if (l == r) {\n        printf(\"%s\\n\", str);\n    } else {\n        // Recursive Step: Iterate from the start index to the end\n        for (i = l; i <= r; i++) {\n            // 1. Swap: Fix the character str[i] at the current position str[l]\n            swap((str + l), (str + i));\n            \n            // 2. Recurse: Permute the remaining substring (from l+1 to r)\n            permute(str, l + 1, r);\n            \n            // 3. Backtrack: Swap back to restore the original order \n            // This is CRITICAL to ensure all permutations are generated correctly\n            swap((str + l), (str + i));\n        }\n    }\n}\n\nint main() {\n    // Note: Must use a char array to allow modification (swapping)\n    char str[] = \"ABC\";  \n    int n = strlen(str);\n    \n    printf(\"Permutations of %s:\\n\", str);\n    permute(str, 0, n - 1);\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(String: \"ABC\")",
        "expected": "Permutations of ABC:\nABC\nACB\nBAC\nBCA\nCBA\nCAB\n"
      },
      {
        "input": "(String: \"AB\")",
        "expected": "Permutations of AB:\nAB\nBA\n"
      }
    ]
  },
  {
    "id": 35,
    "title": "DFS on a basic 2D grid",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement Depth-First Search (DFS) on a basic $3 \\times 3$ 2D grid/matrix. Start the search from a specific cell (e.g., (0,0)) and simply print the coordinates of the cells as they are visited. Assume adjacent cells (up, down, left, right) are reachable.",
    "inputFormat": "Use a hardcoded $3 \\times 3$ grid and a starting coordinate (0,0).",
    "outputFormat": "Print the coordinates (row,col) of the cells in the order they are visited by DFS.",
    "solution": {
      "explanation": "**Depth-First Search (DFS)** is a graph traversal algorithm that explores as far as possible along each branch before backtracking. In a 2D grid, this is naturally implemented using a **recursive function**. The function marks the current cell as `visited` and then recursively calls itself on all valid, unvisited neighbors. A separate `visited` array is essential to prevent visiting the same cell multiple times or getting stuck in cycles.",
      "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define ROWS 3\n#define COLS 3\n\n// Directions: {row_change, col_change} for Up, Down, Left, Right\nint dRow[] = {-1, 1, 0, 0};\nint dCol[] = {0, 0, -1, 1};\n\n// Global visited array (initialized to false/0)\nbool visited[ROWS][COLS] = {false};\n\n// Check if a cell is within grid boundaries\nbool isValid(int row, int col) {\n    return (row >= 0 && row < ROWS && col >= 0 && col < COLS);\n}\n\n// Depth First Search function\nvoid DFS(int row, int col) {\n    // 1. Mark the current cell as visited and print\n    visited[row][col] = true;\n    printf(\"Visiting (%d, %d)\\n\", row, col);\n\n    // 2. Explore all 4 neighbors\n    for (int i = 0; i < 4; i++) {\n        int newRow = row + dRow[i];\n        int newCol = col + dCol[i];\n\n        // Check if the neighbor is valid and not yet visited\n        if (isValid(newRow, newCol) && !visited[newRow][newCol]) {\n            DFS(newRow, newCol); // Recurse: Dive deeper\n        }\n    }\n}\n\nint main() {\n    int startRow = 0;\n    int startCol = 0;\n\n    printf(\"DFS Traversal starting from (%d, %d):\\n\", startRow, startCol);\n    \n    // Start the DFS from the specified coordinate\n    DFS(startRow, startCol);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Grid: 3x3, Start: (0, 0))",
        "expected": "DFS Traversal starting from (0, 0):\nVisiting (0, 0)\nVisiting (1, 0)\nVisiting (2, 0)\nVisiting (2, 1)\nVisiting (1, 1)\nVisiting (0, 1)\nVisiting (0, 2)\nVisiting (1, 2)\nVisiting (2, 2)\n"
      }
    ]
  },
  {
    "id": 36,
    "title": "Simple Union-Find/DSU (Array-based)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to implement a basic Union-Find data structure (also known as Disjoint Set Union or DSU) using an array-based representation. The implementation should include the two core functions:\n\n* `find(i)`: Returns the representative (or parent) of the set containing element $i$.\n* `unite(i, j)`: Merges the sets containing $i$ and $j$.",
    "inputFormat": "The program can hardcode a sequence of `unite` and `find` operations. Assume the elements are $0, 1, \\dots, N-1$.",
    "outputFormat": "Print the result of each unite and find operation.",
    "solution": {
      "explanation": "The **Disjoint Set Union (DSU)** structure manages a collection of disjoint sets, represented by an array where $parent[i]$ stores the parent of element $i$. The core operations are:\n\n* **`find(i)`:** Follows parent pointers upward until it reaches the root (an element that is its own parent).\n* **`unite(i, j)`:** Finds the roots of $i$ and $j$. If they are different, it makes one root the parent of the other, effectively merging the sets.",
      "code": "#include <stdio.h>\n\n#define N 5 // Number of elements (0 to N-1)\n\nint parent[N];\n\n// Initializes each element as a set containing only itself\nvoid initializeSets() {\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;  \n    }\n}\n\n// Find the representative (root) of the set containing element i\nint find(int i) {\n    // Stop condition: if element is its own parent, it's the root\n    if (parent[i] == i) {\n        return i;\n    }\n    // Recursive call to find the root\n    return find(parent[i]);\n}\n\n// Union (unite) the sets containing elements i and j\nvoid unite(int i, int j) {\n    // Find the roots/representatives of i and j\n    int root_i = find(i);\n    int root_j = find(j);\n\n    // If they are not already in the same set\n    if (root_i != root_j) {\n        // Simple Union: make root_j the parent of root_i\n        parent[root_i] = root_j;\n        printf(\"Set of %d and %d united.\\n\", i, j);\n    } else {\n        printf(\"%d and %d are already in the same set.\\n\", i, j);\n    }\n}\n\nint main() {\n    initializeSets();\n    printf(\"Initial sets: {0}, {1}, {2}, {3}, {4}\\n\\n\");\n\n    unite(0, 1);\n    unite(2, 3);\n    \n    printf(\"Representative of 1 is %d\\n\", find(1));\n    printf(\"Representative of 4 is %d\\n\", find(4));\n    \n    unite(1, 4);\n    \n    printf(\"Representative of 0 is %d\\n\", find(0)); // Should be same as 4\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Elements: 0 to 4. Operations: unite(0, 1), unite(2, 3), find(1), find(4), unite(1, 4))",
        "expected": "Initial sets: {0}, {1}, {2}, {3}, {4}\n\nSet of 0 and 1 united.\nSet of 2 and 3 united.\nRepresentative of 1 is 1\nRepresentative of 4 is 4\nSet of 1 and 4 united.\nRepresentative of 0 is 4\n"
      }
    ]
  },
  {
    "id": 37,
    "title": "Array rotation by K steps",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to rotate an integer array to the right by K steps. The rotation must be performed **in-place** (without using a temporary array of the same size).",
    "inputFormat": "Use a hardcoded integer array and an integer K (number of rotations).",
    "outputFormat": "Print the array before and after the rotation.",
    "solution": {
      "explanation": "The most efficient **in-place** rotation uses the **Three-Reversal Algorithm**. For a right rotation of $K$ steps on an array of size $N$:\n\n1.  Reverse the first segment (elements $0$ to $N-K-1$).\n2.  Reverse the second segment (elements $N-K$ to $N-1$).\n3.  Reverse the entire array (elements $0$ to $N-1$).\n\nThis swaps all elements to their correct final positions in $O(N)$ time complexity.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Utility function to reverse a segment of an array\nvoid reverse(int arr[], int start, int end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n\n// Function to rotate array to the right by k steps (in-place)\nvoid rotateArrayRight(int arr[], int n, int k) {\n    // Handle the case where k is larger than n or k is 0\n    k = k % n;\n    if (k == 0) return;\n\n    // The segment to be moved to the front has size k. \n    // The main segment has size n-k.\n    int break_point = n - k;\n\n    // 1. Reverse the first (n-k) elements\n    reverse(arr, 0, break_point - 1);\n\n    // 2. Reverse the last k elements\n    reverse(arr, break_point, n - 1);\n\n    // 3. Reverse the entire array\n    reverse(arr, 0, n - 1);\n}\n\n// Function to print the array\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int k = 3; // Number of right rotations\n    \n    printf(\"Original Array: \");\n    printArray(arr, n);\n\n    rotateArrayRight(arr, n, k);\n    \n    printf(\"Array after %d right rotations: \", k);\n    printArray(arr, n);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Array: {1, 2, 3, 4, 5, 6, 7}, K: 3)",
        "expected": "Original Array: 1 2 3 4 5 6 7 \nArray after 3 right rotations: 5 6 7 1 2 3 4 \n"
      },
      {
        "input": "(Array: {1, 2, 3}, K: 1)",
        "expected": "Original Array: 1 2 3 \nArray after 1 right rotations: 3 1 2 \n"
      },
      {
        "input": "(Array: {10, 20, 30}, K: 3)",
        "expected": "Original Array: 10 20 30 \nArray after 3 right rotations: 10 20 30 \n"
      }
    ]
  },
  {
    "id": 38,
    "title": "Josephus Problem",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to solve the **Josephus Problem**. Given N people standing in a circle and a counting step K, starting from the first person, every K-th person is eliminated until only one person remains. The program should return the position of the last person remaining (the survivor). Use a circular linked list or a simple array simulation. The array simulation is chosen here for the \"Medium\" difficulty requirement.",
    "inputFormat": "Use hardcoded integers N (number of people) and K (counting step).",
    "outputFormat": "Print the position (1-based index) of the survivor.",
    "solution": {
      "explanation": "The Josephus Problem simulates a process of elimination in a circle. This solution uses an array (list) simulation. A `while` loop continues until only one person remains. The person to eliminate is calculated using the modulo operation on the remaining count: `(current_index + K - 1) % remaining`. Once a person is eliminated, subsequent array elements are shifted left to maintain the circular structure, and the process repeats.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Function to solve the Josephus Problem using array simulation\nint josephus(int n, int k) {\n    // Use a list/array to hold the person positions (1 to n)\n    int *people = (int*)malloc(n * sizeof(int));\n    if (people == NULL) return -1;\n\n    for (int i = 0; i < n; i++) {\n        people[i] = i + 1; // 1-based indexing for people\n    }\n\n    int current_index = 0; // The index of the first person to be counted from\n    int remaining = n;\n\n    // Loop until only one person remains\n    while (remaining > 1) {\n        // Calculate the index of the person to be eliminated\n        // (k-1) because we are counting k steps from the current_index (0-based)\n        current_index = (current_index + k - 1) % remaining;\n\n        // The person at current_index is eliminated.\n        // We simulate removal by shifting all subsequent elements left.\n        for (int i = current_index; i < remaining - 1; i++) {\n            people[i] = people[i + 1];\n        }\n\n        remaining--; // One person is eliminated\n        \n        // The next count starts from the person who moved into the current_index slot.\n        // The new current_index will be 0 if the eliminated person was the last one.\n        current_index = current_index % remaining;\n    }\n\n    int survivor = people[0];\n    free(people);\n    return survivor;\n}\n\nint main() {\n    int N = 7; // Number of people\n    int K = 3; // Step\n    \n    int survivor_pos = josephus(N, K);\n\n    if (survivor_pos != -1) {\n        printf(\"The survivor is at position %d\\n\", survivor_pos);\n    } else {\n        printf(\"Error in calculation.\\n\");\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(N=7 people, K=3 step)",
        "expected": "The survivor is at position 4\n"
      },
      {
        "input": "(N=10 people, K=2 step)",
        "expected": "The survivor is at position 5\n"
      },
      {
        "input": "(N=1 people, K=10 step)",
        "expected": "The survivor is at position 1\n"
      }
    ]
  },
  {
    "id": 39,
    "title": "Simple File I/O (read a line)",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program to perform basic File Input/Output. The program should:\n\n1.  Create a text file (e.g., \"mydata.txt\") and write a simple line of text into it.\n2.  Open the same file for reading.\n3.  Read the entire first line of the file, up to a newline character or EOF, using `fgets()`.\n4.  Print the line read from the file.",
    "inputFormat": "The content to be written to the file should be hardcoded.",
    "outputFormat": "Print a confirmation message after writing and the line read from the file.",
    "solution": {
      "explanation": "File I/O in C involves using the `FILE` pointer. First, the file is opened in write mode (`\"w\"`) using `fopen`, and content is written using `fprintf`. The file is then closed (`fclose`). It is immediately reopened in read mode (`\"r\"`). The function **`fgets()`** is used to safely read the content line by line, which is superior to `fscanf` for handling strings that contain spaces and for preventing buffer overflows. Always check for `NULL` return values after `fopen` to handle file errors.",
      "code": "#include <stdio.h>\n#include <stdlib.h> // For EXIT_SUCCESS/EXIT_FAILURE\n\n#define FILENAME \"mydata.txt\"\n#define MAX_LINE_SIZE 100\n\nint main() {\n    FILE *fp;\n    char buffer[MAX_LINE_SIZE];\n    const char *data_to_write = \"This is the first line of the file.\\n\";\n\n    // --- Part 1: Writing to the file ---\n    fp = fopen(FILENAME, \"w\"); // Open for writing (w)\n    if (fp == NULL) {\n        perror(\"Error opening file for writing\");\n        return EXIT_FAILURE;\n    }\n\n    fprintf(fp, \"%s\", data_to_write); // Write the line to the file\n    fclose(fp);\n    printf(\"Successfully wrote to file: %s\\n\", FILENAME);\n\n    // --- Part 2: Reading from the file ---\n    fp = fopen(FILENAME, \"r\"); // Open for reading (r)\n    if (fp == NULL) {\n        perror(\"Error opening file for reading\");\n        return EXIT_FAILURE;\n    }\n\n    // Read the entire line (up to MAX_LINE_SIZE characters or newline/EOF)\n    if (fgets(buffer, MAX_LINE_SIZE, fp) != NULL) {\n        printf(\"Data read from file: %s\", buffer);\n    } else {\n        printf(\"Error reading from file or file is empty.\\n\");\n    }\n\n    fclose(fp); // Close the file stream\n\n    return EXIT_SUCCESS;\n}"
    },
    "testCases": [
      {
        "input": "(Hardcoded line: \"This is the first line of the file.\")",
        "expected": "Successfully wrote to file: mydata.txt\nData read from file: This is the first line of the file.\n"
      }
    ]
  },
  {
    "id": 40,
    "title": "Function Pointers basic usage",
    "language": "C",
    "difficulty": "Medium",
    "problemStatement": "Write a C program that demonstrates the basic usage of a **Function Pointer**. The program should define two simple functions (e.g., add and subtract), declare a function pointer that can point to either of them, and then use the function pointer to call both functions dynamically.",
    "inputFormat": "Use hardcoded integer values for the arguments.",
    "outputFormat": "Print the result of the calls made via the function pointer.",
    "solution": {
      "explanation": "A **Function Pointer** stores the memory address of an executable function, allowing functions to be called dynamically. The declaration `int (*op_ptr)(int, int);` specifies a pointer that can point to any function returning an `int` and accepting two `int` arguments. The function's address is assigned simply by using its name (`op_ptr = add;`). The call can be made either by explicit dereferencing (`(*op_ptr)(x, y)`) or, more commonly, by treating the pointer as the function name (`op_ptr(x, y)`).",
      "code": "#include <stdio.h>\n\n// Function 1: Addition\nint add(int a, int b) {\n    return a + b;\n}\n\n// Function 2: Subtraction\nint subtract(int a, int b) {\n    return a - b;\n}\n\nint main() {\n    int x = 10;\n    int y = 5;\n\n    // 1. Declare a function pointer\n    // It is a pointer to a function that returns int and takes two int arguments.\n    int (*op_ptr)(int, int);  \n\n    // 2. Assign the 'add' function address to the pointer\n    op_ptr = add;  \n\n    // 3. Call 'add' using the function pointer\n    int result_add = op_ptr(x, y); // OR (*op_ptr)(x, y);\n    printf(\"Result of addition (via pointer): %d\\n\", result_add);  \n\n    // 4. Assign the 'subtract' function address to the same pointer\n    op_ptr = subtract;  \n\n    // 5. Call 'subtract' using the function pointer\n    int result_subtract = op_ptr(x, y);\n    printf(\"Result of subtraction (via pointer): %d\\n\", result_subtract);  \n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Arguments: 10, 5)",
        "expected": "Result of addition (via pointer): 15\nResult of subtraction (via pointer): 5\n"
      }
    ]
  },
  {
    "id": 41,
    "title": "Implement a Binary Search Tree (BST) from scratch",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to implement a basic **Binary Search Tree (BST)**. The program must define the node structure and include functions for:\n\n* Insertion of a new key (maintaining BST properties).\n* Inorder Traversal (to confirm the BST property: elements are printed in sorted order).",
    "inputFormat": "The keys to be inserted should be hardcoded (e.g., 50, 30, 70, 20, 40, 60, 80).",
    "outputFormat": "Print the keys using the Inorder Traversal.",
    "solution": {
      "explanation": "A **Binary Search Tree (BST)** is a hierarchical data structure where for every node, all keys in the left subtree are smaller than the node's key, and all keys in the right subtree are larger. **Insertion** is a recursive process that starts at the root and traverses left or right based on the new key's value until an empty spot (`NULL`) is found. **Inorder Traversal** is also recursive: it visits the Left subtree, then the Root, then the Right subtree, which results in printing the keys in **sorted order**.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Structure for a BST node\nstruct Node {\n    int key;\n    struct Node *left;\n    struct Node *right;\n};\n\n// Function to create a new node\nstruct Node* createNode(int item) {\n    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));\n    if (temp == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n    temp->key = item;\n    temp->left = temp->right = NULL;\n    return temp;\n}\n\n// Function to insert a new key in the BST\nstruct Node* insert(struct Node* node, int key) {\n    // 1. If the tree is empty, return a new node\n    if (node == NULL) {\n        return createNode(key);\n    }\n\n    // 2. Otherwise, recur down the tree\n    if (key < node->key) {\n        node->left = insert(node->left, key);\n    } else if (key > node->key) {\n        node->right = insert(node->right, key);\n    }\n    \n    // Return the (unchanged) node pointer\n    return node;\n}\n\n// Function for Inorder Traversal\nvoid inorder(struct Node* root) {\n    if (root != NULL) {\n        inorder(root->left); // Left\n        printf(\"%d \", root->key); // Root\n        inorder(root->right); // Right\n    }\n}\n\nint main() {\n    struct Node* root = NULL;\n    int keys[] = {50, 30, 70, 20, 40, 60, 80};\n    int n = sizeof(keys) / sizeof(keys[0]);\n\n    // Insert all keys\n    for (int i = 0; i < n; i++) {\n        root = insert(root, keys[i]);\n    }\n\n    printf(\"Inorder Traversal (Sorted Keys): \");\n    inorder(root);\n    printf(\"\\n\");\n    \n    // In a production program, all nodes would be freed here\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Keys: 50, 30, 70, 20, 40, 60, 80)",
        "expected": "Inorder Traversal (Sorted Keys): 20 30 40 50 60 70 80 \n"
      },
      {
        "input": "(Keys: 10, 5, 15, 2)",
        "expected": "Inorder Traversal (Sorted Keys): 2 5 10 15 \n"
      },
      {
        "input": "(Keys: 100)",
        "expected": "Inorder Traversal (Sorted Keys): 100 \n"
      }
    ]
  },
  {
    "id": 42,
    "title": "Heap Sort implementation",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to implement the **Heap Sort** algorithm. Heap Sort is an in-place sorting algorithm that uses a Binary Heap structure. The implementation must include the helper function `heapify` (to maintain the heap property) and the main `heapSort` function. Assume a Max Heap is used for ascending order sorting.",
    "inputFormat": "Use a hardcoded unsorted integer array.",
    "outputFormat": "Print the array before and after sorting.",
    "solution": {
      "explanation": "**Heap Sort** is an in-place comparison sort with $O(N \\log N)$ complexity. It has two phases: 1. **Building a Max Heap:** The `heapify` function is called recursively on all non-leaf nodes to establish the Max Heap property (root is the largest). 2. **Extraction:** The largest element (at the root/index 0) is swapped with the last element of the unsorted array. The heap size is reduced, and the new root is re-heapified. This step is repeated until the array is fully sorted.",
      "code": "#include <stdio.h>\n\n// Function to swap two elements\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Function to heapify a subtree rooted with node i (N is the size of heap)\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;    // Initialize largest as root\n    int left = 2 * i + 1;  // left child index\n    int right = 2 * i + 2; // right child index\n\n    // If left child is larger than root\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    // If right child is larger than current largest\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    // If largest is not root\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest);\n    }\n}\n\n// Main function to perform Heap Sort\nvoid heapSort(int arr[], int n) {\n    // Phase 1: Build a Max Heap (rearrange array)\n    // Start from the last non-leaf node\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // Phase 2: One by one extract an element from heap\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root (largest element) to end\n        swap(&arr[0], &arr[i]);\n\n        // Call max heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n}\n\n// Function to print the array\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    printf(\"Unsorted array: \");\n    printArray(arr, n);\n\n    heapSort(arr, n);\n    \n    printf(\"Sorted array (Heap Sort): \");\n    printArray(arr, n);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Array: {12, 11, 13, 5, 6, 7})",
        "expected": "Unsorted array: 12 11 13 5 6 7 \nSorted array (Heap Sort): 5 6 7 11 12 13 \n"
      },
      {
        "input": "(Array: {5, 4, 3, 2, 1})",
        "expected": "Unsorted array: 5 4 3 2 1 \nSorted array (Heap Sort): 1 2 3 4 5 \n"
      },
      {
        "input": "(Array: {100, 10, 50, 20})",
        "expected": "Unsorted array: 100 10 50 20 \nSorted array (Heap Sort): 10 20 50 100 \n"
      }
    ]
  },
  {
    "id": 43,
    "title": "Dijkstra's Algorithm (manual implementation)",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to implement **Dijkstra's Algorithm** to find the shortest path from a single source vertex to all other vertices in a weighted, undirected graph. For simplicity, use an adjacency matrix representation and a simple array to find the minimum distance vertex (not a priority queue).",
    "inputFormat": "Use a hardcoded $V \\times V$ weighted adjacency matrix, where $V=5$. A value of 0 means no direct edge, and a large number (INF) represents unreachable vertices. The source vertex is fixed at 0.",
    "outputFormat": "Print the shortest distance from the source (vertex 0) to all other vertices.",
    "solution": {
      "explanation": "**Dijkstra's Algorithm** finds the shortest paths from a single source to all other nodes in a weighted graph with non-negative edge weights. It uses a greedy approach: 1. **Initialization:** Set the distance to the source node to 0 and all others to infinity. 2. **Iteration/Relaxation:** In a loop, select the unvisited node $u$ with the currently smallest distance. Mark $u$ as visited. Update (relax) the distances of all neighbors $v$ of $u$: if $dist[u] + weight(u,v) < dist[v]$, then $dist[v]$ is updated. The process ensures that once a node is marked visited, its distance is final and optimal.",
      "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define V 5\n#define INF INT_MAX\n\n// Function to find the vertex with the minimum distance value\nint minDistance(int dist[], bool sptSet[]) {\n    int min = INF, min_index;\n\n    for (int v = 0; v < V; v++) {\n        if (sptSet[v] == false && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\n// Implements Dijkstra's algorithm for a single source shortest path\nvoid dijkstra(int graph[V][V], int src) {\n    int dist[V];      // dist[i] will hold the shortest distance from src to i\n    bool sptSet[V];    // sptSet[i] will be true if vertex i is included in shortest path tree\n\n    // Initialize all distances as INF and sptSet[] as false\n    for (int i = 0; i < V; i++) {\n        dist[i] = INF;\n        sptSet[i] = false;\n    }\n\n    // Distance of source vertex from itself is always 0\n    dist[src] = 0;\n\n    // Find shortest path for all vertices\n    for (int count = 0; count < V - 1; count++) {\n        // Pick the minimum distance vertex from the set of vertices not yet processed\n        int u = minDistance(dist, sptSet);\n\n        // Mark the picked vertex as processed\n        sptSet[u] = true;\n\n        // Update dist value of the adjacent vertices of the picked vertex\n        for (int v = 0; v < V; v++) {\n            // Relaxation step: Update dist[v] only if:\n            // 1. v is not in sptSet (not yet processed)\n            // 2. There is an edge from u to v (graph[u][v] is not 0)\n            // 3. Total weight of path from src to v through u is smaller than current dist[v]\n            if (!sptSet[v] && graph[u][v] != 0 && dist[u] != INF && \n                (long long)dist[u] + graph[u][v] < dist[v]) { // Using long long to prevent overflow during intermediate sum\n                dist[v] = dist[u] + graph[u][v];\n            }\n        }\n    }\n\n    // Print the constructed distance array\n    printf(\"Shortest distance from source (%d):\\n\", src);\n    for (int i = 0; i < V; i++) {\n        printf(\"Vertex %d: %d\\n\", i, dist[i]);\n    }\n}\n\nint main() {\n    // Graph representation (Adjacency Matrix). 0 means no direct edge.\n    int graph[V][V] = {\n        {0, 10, 5, 0, 0},\n        {0, 0, 2, 1, 0},\n        {0, 3, 0, 9, 2},\n        {0, 0, 0, 0, 4},\n        {7, 0, 0, 6, 0}\n    };\n\n    dijkstra(graph, 0); // Source vertex is 0\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Weighted Graph V=5, Source=0)",
        "expected": "Shortest distance from source (0):\nVertex 0: 0\nVertex 1: 8\nVertex 2: 5\nVertex 3: 9\nVertex 4: 7\n"
      }
    ]
  },
  {
    "id": 44,
    "title": "0/1 Knapsack (Dynamic Programming)",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to solve the **0/1 Knapsack Problem** using **Dynamic Programming**. Given a set of items, each with a weight and a value, determine the maximum value that can be put into a knapsack of a given capacity W, assuming each item can be included or excluded (0/1 choice).",
    "inputFormat": "Use hardcoded arrays for item values, weights, and the maximum knapsack capacity W.",
    "outputFormat": "Print the maximum value that can be achieved.",
    "solution": {
      "explanation": "The **0/1 Knapsack** problem is solved using **Dynamic Programming** to find the maximum value that can be put into a knapsack of capacity $W$, where each item is either included (1) or excluded (0). We build a 2D table, $K[i][w]$, representing the maximum value using the first $i$ items with capacity $w$. The key **recurrence relation** is a max function that compares two choices: 1. **Exclude** item $i$ (value is $K[i-1][w]$). 2. **Include** item $i$ (value is $v_i + K[i-1][w-w_i]$). The final answer is $K[N][W]$.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Function to return the maximum of two integers\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\n// Returns the maximum value that can be put in a knapsack of capacity W\nint knapSack(int W, int wt[], int val[], int n) {\n    // K[i][w] is the max value using first i items and capacity w\n    int K[n + 1][W + 1];\n\n    // Build table K[][] in a bottom-up manner\n    for (int i = 0; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            if (i == 0 || w == 0) {\n                // Base case: 0 items or 0 capacity means 0 value\n                K[i][w] = 0;\n            }  \n            // Case 1: If weight of item i is more than current knapsack capacity w, skip it\n            else if (wt[i - 1] > w) {\n                K[i][w] = K[i - 1][w];\n            }  \n            // Case 2: Take the max of (skipping item i, OR taking item i + max value of remaining capacity)\n            else {\n                K[i][w] = max(K[i - 1][w], val[i - 1] + K[i - 1][w - wt[i - 1]]);\n            }\n        }\n    }\n\n    return K[n][W]; // The final max value\n}\n\nint main() {\n    int val[] = {60, 100, 120}; // Values of items\n    int wt[] = {10, 20, 30};    // Weights of items\n    int W = 50;              // Knapsack capacity\n    int n = sizeof(val) / sizeof(val[0]); // Number of items\n\n    int max_value = knapSack(W, wt, val, n);\n    \n    printf(\"Maximum value in Knapsack: %d\\n\", max_value);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Items: 3, Values: {60, 100, 120}, Weights: {10, 20, 30}, Capacity W: 50)",
        "expected": "Maximum value in Knapsack: 220\n"
      },
      {
        "input": "(Items: 4, Values: {10, 40, 30, 50}, Weights: {5, 4, 6, 3}, Capacity W: 10)",
        "expected": "Maximum value in Knapsack: 90\n"
      }
    ]
  },
  {
    "id": 45,
    "title": "Longest Common Subsequence (LCS)",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to find the length of the **Longest Common Subsequence (LCS)** of two given strings using Dynamic Programming. A subsequence is formed by deleting zero or more characters from the original string.",
    "inputFormat": "Use two hardcoded strings.",
    "outputFormat": "Print the length of the LCS.",
    "solution": {
      "explanation": "The **Longest Common Subsequence (LCS)** problem is solved using **Dynamic Programming**. We create a 2D table, $L[i][j]$, storing the LCS length for prefixes of the two strings. The **recurrence relation** is:\n\n* **Match:** If $X[i-1] = Y[j-1]$, then $L[i][j] = 1 + L[i-1][j-1]$.\n* **Mismatch:** If $X[i-1] \\ne Y[j-1]$, then $L[i][j] = \\max(L[i-1][j], L[i][j-1])$.\n\nThis bottom-up approach fills the table, and the final answer is found at $L[m][n]$.",
      "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h> // For memory allocation\n\n// Function to return the maximum of two integers\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\n// Function to find the length of LCS\nint lcsLength(const char *X, const char *Y, int m, int n) {\n    // Dynamically allocate 2D array L[m+1][n+1]\n    int **L = (int**)malloc((m + 1) * sizeof(int*));\n    if (L == NULL) return 0;\n    for (int i = 0; i <= m; i++) {\n        L[i] = (int*)calloc(n + 1, sizeof(int));\n        if (L[i] == NULL) { /* Handle memory error and clean up */ return 0; }\n    }\n    \n    // Build L[m+1][n+1] in a bottom-up fashion\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0) {\n                L[i][j] = 0;\n            }  \n            // Case 1: Characters match\n            else if (X[i - 1] == Y[j - 1]) {\n                L[i][j] = 1 + L[i - 1][j - 1];\n            }  \n            // Case 2: Characters don't match\n            else {\n                L[i][j] = max(L[i - 1][j], L[i][j - 1]);\n            }\n        }\n    }\n\n    int result = L[m][n];\n    \n    // Free the dynamically allocated memory\n    for (int i = 0; i <= m; i++) {\n        free(L[i]);\n    }\n    free(L);\n\n    return result;\n}\n\nint main() {\n    const char *S1 = \"AGGTAB\";\n    const char *S2 = \"GXTXAYB\";\n    \n    int m = strlen(S1);\n    int n = strlen(S2);\n\n    int length = lcsLength(S1, S2, m, n);\n    \n    printf(\"Length of LCS is %d\\n\", length);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(String 1: \"AGGTAB\", String 2: \"GXTXAYB\")",
        "expected": "Length of LCS is 4\n"
      },
      {
        "input": "(String 1: \"ABCDE\", String 2: \"ACE\")",
        "expected": "Length of LCS is 3\n"
      },
      {
        "input": "(String 1: \"A\", String 2: \"B\")",
        "expected": "Length of LCS is 0\n"
      },
      {
        "input": "(String 1: \"AAAA\", String 2: \"AA\")",
        "expected": "Length of LCS is 2\n"
      }
    ]
  },
  {
    "id": 46,
    "title": "Bit Manipulation for set checking",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program that uses **Bit Manipulation** to check if a number is a power of 2 and to count the number of set bits (1s) in a given integer. Do not use loops for the power of 2 check.",
    "inputFormat": "Use two hardcoded positive integers for testing.",
    "outputFormat": "Print the result of the power of 2 check (true/false) and the count of set bits for both numbers.",
    "solution": {
      "explanation": "This problem demonstrates two highly efficient bitwise tricks:\n\n1.  **Power of 2 Check:** A positive integer $N$ is a power of 2 if and only if it has exactly one set bit (e.g., $8=1000_2$). The expression **$N \\& (N - 1)$** clears the least significant set bit of $N$. If $N$ is a power of 2, the result of the operation is 0.\n2.  **Counting Set Bits (Brian Kernighan's Algorithm):** The loop repeatedly performs the operation $N \\& (N - 1)$, which clears one set bit per iteration. The loop continues until $N$ becomes 0. The total number of loop iterations is the number of set bits.",
      "code": "#include <stdio.h>\n\n// Function to check if a number is a power of 2 using bit manipulation\n// True if N is a power of 2, False otherwise\nint isPowerOfTwo(int n) {\n    // A power of 2 has only one set bit. N & (N - 1) clears the least significant set bit.\n    // If N is a power of 2, then N & (N - 1) will be 0. We must also check N > 0.\n    return (n > 0) && ((n & (n - 1)) == 0);\n}\n\n// Function to count the number of set bits (1s) using Brian Kernighan's Algorithm\nint countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        n &= (n - 1); // Clears the least significant set bit\n        count++;\n    }\n    return count;\n}\n\nvoid printResults(int num) {\n    printf(\"%d is a power of 2 (%s).\\n\", num, isPowerOfTwo(num) ? \"True\" : \"False\");\n    printf(\"Number of set bits in %d is %d\\n\", num, countSetBits(num));\n}\n\nint main() {\n    int num1 = 16; // Binary: 10000 (Power of 2)\n    int num2 = 13; // Binary: 1101 (Not a Power of 2)\n\n    printResults(num1);\n    printResults(num2);\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Number 1: 16, Number 2: 13)",
        "expected": "16 is a power of 2 (True).\nNumber of set bits in 16 is 1\n13 is a power of 2 (False).\nNumber of set bits in 13 is 3\n"
      }
    ]
  },
  {
    "id": 47,
    "title": "Custom memcpy or strcpy implementation",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C function named `my_memcpy` that mimics the functionality of the standard library function `memcpy`. The function must copy N bytes of data from a memory area pointed to by a `const void*` source to a memory area pointed to by a `void*` destination. Using `void*` is essential for handling any data type.",
    "inputFormat": "The program should hardcode an array of integers and copy it to a new array using `my_memcpy`.",
    "outputFormat": "Print the elements of the destination array to confirm the copy was successful.",
    "solution": {
      "explanation": "A custom `memcpy` function is crucial for deep understanding of memory manipulation. It must use **`void*`** pointers to accept any data type, and then **cast** these pointers to **`char*`** (or `unsigned char*`) inside the function. This is because a `char` is guaranteed to be one byte in C, allowing the copy to be performed safely and correctly one byte at a time, irrespective of the actual data type.",
      "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Custom implementation of memcpy\nvoid* my_memcpy(void *dest, const void *src, size_t n) {\n    // 1. Cast the void pointers to char pointers for byte-level access\n    char *d = (char *)dest;\n    const char *s = (const char *)src;\n\n    // 2. Iterate and copy byte by byte\n    for (size_t i = 0; i < n; i++) {\n        d[i] = s[i]; // Copy the byte at index i\n    }\n    \n    // Return the starting address of the destination\n    return dest;\n}\n\nint main() {\n    int source_arr[] = {10, 20, 30, 40, 50};\n    int n = sizeof(source_arr) / sizeof(source_arr[0]);\n    \n    // Allocate memory for the destination array\n    int *dest_arr = (int*)malloc(sizeof(source_arr));\n    if (dest_arr == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        return 1;\n    }\n    \n    // The number of bytes to copy is the total size of the source array\n    size_t bytes_to_copy = sizeof(source_arr);  \n    \n    // --- Perform the copy using the custom function ---\n    my_memcpy(dest_arr, source_arr, bytes_to_copy);\n    \n    // Print source and destination data\n    printf(\"Source data: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", source_arr[i]);\n    }\n    printf(\"\\n\");\n\n    printf(\"Destination data after my_memcpy: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", dest_arr[i]);\n    }\n    printf(\"\\n\");\n\n    free(dest_arr);\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Source Array: {10, 20, 30, 40, 50})",
        "expected": "Source data: 10 20 30 40 50 \nDestination data after my_memcpy: 10 20 30 40 50 \n"
      }
    ]
  },
  {
    "id": 48,
    "title": "N-Queens Problem (Backtracking)",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to solve the classic **N-Queens Problem** using **Backtracking**. The goal is to place N non-attacking queens on an $N \\times N$ chessboard. The program should find and print one valid configuration for a hardcoded $N=4$.",
    "inputFormat": "Hardcoded integer $N=4$.",
    "outputFormat": "Print a representation of the chessboard showing the queen positions (e.g., 'Q' for a queen, '.' for an empty square).",
    "solution": {
      "explanation": "The **N-Queens Problem** is solved using **Backtracking**, a recursive, depth-first search strategy. We attempt to place a queen row by row, starting from row 0. The **`isSafe`** helper function checks for conflicts against all previously placed queens in earlier rows, verifying that the new position is free from attacks vertically, and on both positive and negative diagonals. If a position is safe, we place the queen and recurse. If the recursive call fails, we **backtrack** (remove the queen) and try the next column.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define N 4 // For the 4-Queens problem\n\n// Array to store the solution: pos[i] = column of the queen in row i\nint board[N]; \n\n// Function to print the solution board\nvoid printSolution() {\n    printf(\"Solution found:\\n\");\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i] == j) {\n                printf(\"Q \"); // Queen is at (i, j)\n            } else {\n                printf(\". \"); // Empty square\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\n// Function to check if a queen can be safely placed at board[row][col]\nbool isSafe(int row, int col) {\n    // Check all previous rows (0 to row-1)\n    for (int prev_row = 0; prev_row < row; prev_row++) {\n        // 1. Check for column conflict (Vertical)\n        if (board[prev_row] == col) {\n            return false;\n        }\n        // 2. Check for diagonal conflict (|row - prev_row| == |col - board[prev_row]|)\n        if (abs(prev_row - row) == abs(board[prev_row] - col)) {\n            return false;\n        }\n    }\n    return true; // The position is safe\n}\n\n// Main recursive backtracking function\nbool solveNQueens(int row) {\n    // Base Case: All queens are placed successfully\n    if (row >= N) {\n        printSolution();\n        return true; // Returning true to find only one solution\n    }\n\n    // Try placing a queen in every column of the current row\n    for (int col = 0; col < N; col++) {\n        if (isSafe(row, col)) {\n            // Place the queen (move to the next state)\n            board[row] = col; \n\n            // Recurse for the next row\n            if (solveNQueens(row + 1)) {\n                return true; // Solution found down this path\n            }\n            \n            // Backtrack: If placing the queen here didn't lead to a solution, \n            // the board[row] assignment is effectively undone \n            // when the loop moves to the next column. The loop proceeds to the next column.\n        }\n    }\n\n    return false; // No safe place in this row\n}\n\nint main() {\n    printf(\"N-Queens Solution for N=%d:\\n\", N);\n    \n    // Initialize board array to a safe value (though not strictly necessary)\n    for (int i = 0; i < N; i++) {\n        board[i] = -1;  \n    }\n\n    if (solveNQueens(0) == false) {\n        printf(\"Solution does not exist.\\n\");\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "N=4",
        "expected": "N-Queens Solution for N=4:\n. Q . \n. . . Q \nQ . . \n. . Q \n\n"
      }
    ]
  },
  {
    "id": 49,
    "title": "Graph Cycle Detection (DFS-based)",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to perform **Cycle Detection in a Directed Graph** using a Depth-First Search (DFS) based approach. Use an adjacency list representation (arrays of lists/vectors or a 2D array for simplicity) and the concept of three coloring (white, gray, black) to detect back-edges. For simplicity, we'll use an integer array to represent the three colors (0=White/Unvisited, 1=Gray/In-Stack, 2=Black/Finished).",
    "inputFormat": "Use a hardcoded directed graph (Adjacency Matrix). $V=4$.",
    "outputFormat": "Print whether a cycle is detected or not.",
    "solution": {
      "explanation": "Cycle detection in a **Directed Graph** is done using **DFS** and a **three-coloring** scheme:\n\n1.  **White (0):** Unvisited.\n2.  **Gray (1):** Currently in the recursion stack.\n3.  **Black (2):** Finished processing.\n\nA cycle is detected when the DFS visits a neighbor $v$ of the current node $u$, and $v$ is already in the **Gray** state (a back-edge). If no such Gray neighbor is found after checking all neighbors, the node $u$ is marked Black (finished), and the function returns.",
      "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define V 4 // Number of vertices\n\n// Global array to store the state of each vertex\n// 0: White (Unvisited)\n// 1: Gray (In recursion stack / being visited)\n// 2: Black (Finished processing)\nint color[V]; \n\n// Adjacency Matrix for the Directed Graph\nint graph[V][V] = {\n    {0, 1, 0, 0}, // 0 -> 1\n    {0, 0, 1, 0}, // 1 -> 2\n    {0, 0, 0, 1}, // 2 -> 3\n    {1, 0, 0, 0}  // 3 -> 0 (Forms a cycle)\n};\n\n// DFS function for cycle detection\nbool DFS_cycle_detection(int u) {\n    // 1. Mark the current node as Gray (in recursion stack)\n    color[u] = 1;\n\n    // 2. Recur for all the vertices adjacent to this vertex\n    for (int v = 0; v < V; v++) {\n        // If there is an edge from u to v\n        if (graph[u][v] == 1) {\n            \n            // Case 1: If v is Gray, we found a back edge (a cycle)\n            if (color[v] == 1) {\n                return true;  \n            }\n\n            // Case 2: If v is White, recurse\n            if (color[v] == 0) {\n                if (DFS_cycle_detection(v)) {\n                    return true; // Cycle found in the recursive call\n                }\n            }\n            \n            // Case 3: If v is Black, it's a cross-edge or forward-edge, skip it.\n        }\n    }\n\n    // 3. Mark the current node as Black (finished processing)\n    color[u] = 2;\n    \n    return false; // No cycle found from this vertex\n}\n\n// Main function to check for cycles in the entire graph\nbool hasCycle() {\n    // Initialize all vertices to White (0)\n    for (int i = 0; i < V; i++) {\n        color[i] = 0;\n    }\n\n    // Check all vertices, as the graph might be disconnected\n    for (int i = 0; i < V; i++) {\n        if (color[i] == 0) { // If the vertex is unvisited\n            if (DFS_cycle_detection(i)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    if (hasCycle()) {\n        printf(\"Cycle detected in the graph.\\n\", 1);\n    } else {\n        printf(\"No cycle detected in the graph.\\n\", 0);\n    }\n\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Edges: 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 0) (Contains a cycle)",
        "expected": "Cycle detected in the graph.\n"
      },
      {
        "input": "(Edges: 0 -> 1, 1 -> 2, 2 -> 3)",
        "expected": "No cycle detected in the graph.\n"
      }
    ]
  },
  {
    "id": 50,
    "title": "Generic Linked List using void pointers",
    "language": "C",
    "difficulty": "Hard",
    "problemStatement": "Write a C program to implement a **Generic Singly Linked List** that can store data of any type (e.g., int, $char*$) by utilizing $void*$ pointers for the data field. The implementation should include:\n\n* A node structure with $void*$ data.\n* A function to insert a node at the beginning.\n* A function to print the list elements, requiring a type-specific print helper function (demonstrating how to cast the $void*$ back).",
    "inputFormat": "The program should hardcode the insertion of at least one integer and one string to demonstrate genericity.",
    "outputFormat": "Print the elements of the list, clearly indicating the type of data being printed.",
    "solution": {
      "explanation": "To implement a **Generic Linked List** in C, the data field within the node structure must be a **`void*`** pointer. This allows the node to point to data of any type. When inserting, new memory must be explicitly allocated (`malloc`) for the actual data, and the data content must be copied (`memcpy`) into that new memory. The **`void*`** must be **cast back** to the correct data type pointer (`int*`, `char*`, etc.) before being dereferenced and printed. A `DataType` field is necessary to track the original type for correct printing.",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Enum to specify the type of data stored (essential for generic printing)\ntypedef enum { INT, STRING } DataType;\n\n// Generic Linked List Node structure\nstruct Node {\n    void *data;        // Generic pointer to hold data of any type\n    DataType type;     // Indicator for the data type\n    struct Node *next;\n};\n\nstruct Node *head = NULL;\n\n// Function to insert a node at the beginning\nvoid insert(void *new_data, DataType type, size_t data_size) {\n    struct Node *new_node = (struct Node*) malloc(sizeof(struct Node));\n    if (new_node == NULL) {\n        perror(\"Memory allocation failed for node\");\n        return;\n    }\n\n    // Allocate memory for the actual data and copy it\n    new_node->data = malloc(data_size);\n    if (new_node->data == NULL) {\n        perror(\"Memory allocation failed for data\");\n        free(new_node);\n        return;\n    }\n    memcpy(new_node->data, new_data, data_size); // Copy the content\n\n    new_node->type = type;\n    new_node->next = head;\n    head = new_node;\n}\n\n// Function to print the list, using the type field for correct casting\nvoid display() {\n    struct Node *current = head;\n    printf(\"Generic Linked List:\\n\");\n    while (current != NULL) {\n        printf(\"Data: \");\n        \n        // CRITICAL: Cast the void* back to the correct pointer type\n        if (current->type == INT) {\n            // Cast to int*, then dereference to get the int value\n            printf(\"%d (Integer)\", *(int*)current->data);  \n        } else if (current->type == STRING) {\n            // Cast to char* (or const char*)\n            printf(\"%s (String)\", (char*)current->data);\n        } else {\n            printf(\"Unknown Type\");\n        }\n        \n        printf(\"\\n\");\n        current = current->next;\n    }\n}\n\n// Function to free all allocated memory (prevents memory leaks)\nvoid freeList() {\n    struct Node *current = head;\n    struct Node *next_node;\n    while (current != NULL) {\n        next_node = current->next;\n        free(current->data); // Free the data block first\n        free(current);       // Then free the node block\n        current = next_node;\n    }\n    head = NULL;\n}\n\nint main() {\n    int int_val = 42;\n    char *string_val = \"Hello\";\n\n    // Insert the string (note: we pass the address of the string pointer)\n    insert(string_val, STRING, strlen(string_val) + 1);  \n\n    // Insert the integer (we pass the address of the integer variable)\n    insert(&int_val, INT, sizeof(int));  \n    \n    // Demonstrate another integer\n    int another_int = 100;\n    insert(&another_int, INT, sizeof(int));\n\n    display();\n\n    freeList();\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "(Insert: Integer 42, String \"Hello\")",
        "expected": "Generic Linked List:\nData: 100 (Integer)\nData: 42 (Integer)\nData: Hello (String)\n"
      }
    ]
  },
  {
    "id": 51,
    "title": "Reverse a String using Slicing",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Write a Python program that prompts the user for a word and reverses it using **string slicing**.",
    "inputFormat": "The program should prompt the user for a word.",
    "outputFormat": "Print the reversed word.",
    "solution": {
      "explanation": "String slicing is the most concise and idiomatic way to reverse a string in Python. The syntax **`[::-1]`** means: start at the beginning (first colon), end at the end (second colon), and step backward by 1 (the `-1` step), effectively reversing the order of the characters in the sequence.",
      "code": "word = input(\"Enter a word: \")\nreversed_word = word[::-1]\nprint(reversed_word)"
    },
    "testCases": [
      {
        "input": "Enter a word: Python",
        "expected": "nohtyP\n"
      },
      {
        "input": "Enter a word: Hello",
        "expected": "olleH\n"
      },
      {
        "input": "Enter a word: a",
        "expected": "a\n"
      }
    ]
  },
  {
    "id": 52,
    "title": "List Comprehension: Square Numbers",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Given the list `[1, 2, 3, 4, 5]`, use a single **list comprehension** to create a new list containing the square of every number.",
    "inputFormat": "The program uses a hardcoded list.",
    "outputFormat": "Print the resulting list.",
    "solution": {
      "explanation": "A **List Comprehension** offers a Pythonic way to create a new list from an existing iterable. The structure is `[expression for item in iterable]`. Here, the `expression` is `num * num` (squaring the number), which is applied to every `num` iterating over the `numbers` list.",
      "code": "numbers = [1, 2, 3, 4, 5]\nsquared_numbers = [num * num for num in numbers]\nprint(squared_numbers)"
    },
    "testCases": [
      {
        "input": "(Internal list)",
        "expected": "[1, 4, 9, 16, 25]\n"
      }
    ]
  },
  {
    "id": 53,
    "title": "Remove Duplicates using Set",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Given a list with duplicates, `[1, 2, 2, 3, 4, 4, 5]`, write a program to remove all duplicates and create a new list containing only unique elements.",
    "inputFormat": "The program uses a hardcoded list.",
    "outputFormat": "Print the list with unique elements.",
    "solution": {
      "explanation": "The **`set`** data structure in Python inherently stores only unique elements. Converting a list to a set automatically discards all duplicates. Converting the resultant set back to a list using `list(set(data))` yields a list containing only the unique elements. Note that this process does not guarantee the preservation of the original order of elements.",
      "code": "data = [1, 2, 2, 3, 4, 4, 5]\nunique_list = list(set(data))\n# Note: Order may not be preserved depending on Python version/implementation\nprint(unique_list)"
    },
    "testCases": [
      {
        "input": "(Internal list)",
        "expected": "[1, 2, 3, 4, 5]\n"
      }
    ]
  },
  {
    "id": 54,
    "title": "Dictionary Key/Value Swapping",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Given a dictionary `{'a': 1, 'b': 2, 'c': 3}`, create a new dictionary where the keys and values are swapped.",
    "inputFormat": "The program uses a hardcoded dictionary.",
    "outputFormat": "Print the new dictionary.",
    "solution": {
      "explanation": "This transformation is done concisely using a **Dictionary Comprehension**. The `original_dict.items()` method returns key-value pairs as tuples. The comprehension iterates over these pairs as `key, value` and constructs the new dictionary with the expression `{value: key}`, effectively flipping the mapping.",
      "code": "original_dict = {'a': 1, 'b': 2, 'c': 3}\nswapped_dict = {value: key for key, value in original_dict.items()}\nprint(swapped_dict)"
    },
    "testCases": [
      {
        "input": "(Internal dict)",
        "expected": "{1: 'a', 2: 'b', 3: 'c'}\n"
      }
    ]
  },
  {
    "id": 55,
    "title": "Basic Exception Handling",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Write a program that attempts to divide 10 by a variable `divisor`. Use a `try-except` block to gracefully handle a `ZeroDivisionError` if the divisor is 0.",
    "inputFormat": "The divisor is hardcoded to 0.",
    "outputFormat": "Print the result or the error message.",
    "solution": {
      "explanation": "The **`try-except`** block is used to gracefully handle runtime errors. The code that might fail (division) is placed in the `try` block. If a `ZeroDivisionError` occurs, the program execution jumps to the corresponding `except` block, preventing a crash and printing a user-friendly error message.",
      "code": "divisor = 0\ntry:\n    result = 10 / divisor\n    print(f\"Result: {result}\")\nexcept ZeroDivisionError:\n    print(\"Error: Cannot divide by zero.\")"
    },
    "testCases": [
      {
        "input": "divisor = 0",
        "expected": "Error: Cannot divide by zero.\n"
      },
      {
        "input": "divisor = 5",
        "expected": "Result: 2.0\n"
      }
    ]
  },
  {
    "id": 56,
    "title": "List Comprehension: Filter and Map",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Given `numbers = [1, 5, 12, 8, 20]`, use a list comprehension to create a new list containing only the square of numbers greater than 10.",
    "inputFormat": "The program uses a hardcoded list.",
    "outputFormat": "Print the resulting list.",
    "solution": {
      "explanation": "This is a combined map and filter operation within a single **List Comprehension**. The structure is `[expression for item in iterable if condition]`. The `if num > 10` clause acts as the **filter**, selecting only the numbers to process. The `num ** 2` expression acts as the **map**, transforming the selected numbers by squaring them.",
      "code": "numbers = [1, 5, 12, 8, 20]\nfiltered_squares = [num ** 2 for num in numbers if num > 10]\nprint(filtered_squares)"
    },
    "testCases": [
      {
        "input": "(Internal list)",
        "expected": "[144, 400]\n"
      }
    ]
  },
  {
    "id": 57,
    "title": "Merge Dictionaries (Pythonic)",
    "language": "Python",
    "difficulty": "Easy",
    "problemStatement": "Given `d1 = {'a': 1, 'b': 2}` and `d2 = {'b': 3, 'c': 4}`, merge them, where values from `d2` overwrite `d1` for duplicate keys, using the dictionary unpacking operator.",
    "inputFormat": "The program uses hardcoded dictionaries.",
    "outputFormat": "Print the merged dictionary.",
    "solution": {
      "explanation": "The most modern and Pythonic way to merge dictionaries is using the **Dictionary Unpacking Operator** (`**`). The expression `{**d1, **d2}` unpacks both dictionaries into a new literal. Since `d2` is unpacked last, its value for key 'b' takes precedence.",
      "code": "d1 = {'a': 1, 'b': 2}\nd2 = {'b': 3, 'c': 4}\nmerged_dict = {**d1, **d2}\nprint(merged_dict)"
    },
    "testCases": [
      {
        "input": "(Internal dicts)",
        "expected": "{'a': 1, 'b': 3, 'c': 4}\n"
      }
    ]
  },
  {
    "id": 58,
    "title": "Anagram Check",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a function `is_anagram(s1, s2)` that checks if two strings are anagrams (contain the same characters with the same frequency, ignoring case and spaces).",
    "inputFormat": "The function is called with two strings.",
    "outputFormat": "Print `True` or `False`.",
    "solution": {
      "explanation": "The most robust and clean way to check for an anagram is to ensure both strings contain the same characters with the same frequencies. The process is: 1. **Normalize:** Convert both strings to lowercase and remove spaces/punctuation. 2. **Canonical Form:** Convert each normalized string into a sorted list of characters. 3. **Compare:** If the two sorted lists are identical, the original strings are anagrams.",
      "code": "def is_anagram(s1, s2):\n    # Normalize strings: lowercase and remove spaces\n    s1 = s1.lower().replace(' ', '')\n    s2 = s2.lower().replace(' ', '')\n    \n    # Anagrams if their sorted character lists are equal\n    return sorted(list(s1)) == sorted(list(s2))\n\nprint(is_anagram(\"listen\", \"silent\"))"
    },
    "testCases": [
      {
        "input": "is_anagram(\"listen\", \"silent\")",
        "expected": "True\n"
      },
      {
        "input": "is_anagram(\"Debit Card\", \"Bad Credit\")",
        "expected": "True\n"
      },
      {
        "input": "is_anagram(\"hello\", \"world\")",
        "expected": "False\n"
      }
    ]
  },
  {
    "id": 59,
    "title": "Word Frequency Counter",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Given a sentence, count the frequency of each unique word (case-insensitive) using a dictionary. Ignore punctuation for simplicity.",
    "inputFormat": "The program uses a hardcoded string.",
    "outputFormat": "Print the dictionary of word counts.",
    "solution": {
      "explanation": "The **`collections.Counter`** class is specifically designed for counting hashable objects and is the standard Python solution for word frequency. The input string is first converted to lowercase and split into a list of words. Passing this list directly to `Counter()` automatically generates a dictionary-like object where keys are the unique words and values are their respective counts.",
      "code": "from collections import Counter\n\nsentence = \"The quick brown fox and the quick dog.\"\nwords = sentence.lower().replace('.', '').split()\n\n# Counter does the counting automatically\nword_counts = Counter(words)\nprint(word_counts)"
    },
    "testCases": [
      {
        "input": "sentence = \"The quick brown fox and the quick dog.\"",
        "expected": "Counter({'the': 2, 'quick': 2, 'brown': 1, 'fox': 1, 'and': 1, 'dog': 1})\n"
      },
      {
        "input": "sentence = \"A B C A B\"",
        "expected": "Counter({'a': 2, 'b': 2, 'c': 1})\n"
      }
    ]
  },
  {
    "id": 60,
    "title": "Two Pointers: Find Pair Sum",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Given a **sorted list** `arr = [2, 7, 11, 15]` and a `target = 9`, use the **Two-Pointers** technique to find if a pair exists that sums to the target.",
    "inputFormat": "The function is called internally.",
    "outputFormat": "Print the pair if found.",
    "solution": {
      "explanation": "The **Two-Pointers** technique is highly efficient for problems on **sorted arrays**, running in $O(N)$ time. Pointers `left` (start) and `right` (end) move towards the center. If the `current_sum` is too small, we increment `left` to include a larger number; if the sum is too large, we decrement `right` to include a smaller number. If the sum equals the `target`, the pair is found.",
      "code": "def find_sum_pair(arr, target):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            print(f\"Pair found: ({arr[left]}, {arr[right]})\")\n            return\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    print(\"No pair found.\")\n\nfind_sum_pair([2, 7, 11, 15], 9)"
    },
    "testCases": [
      {
        "input": "arr = [2, 7, 11, 15], target = 9",
        "expected": "Pair found: (2, 7)\n"
      },
      {
        "input": "arr = [1, 2, 3, 4], target = 7",
        "expected": "Pair found: (3, 4)\n"
      },
      {
        "input": "arr = [1, 2, 3], target = 10",
        "expected": "No pair found.\n"
      }
    ]
  },
  {
    "id": 61,
    "title": "Sliding Window: Max Subarray Sum",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Given an array `arr = [1, 4, 2, 10, 23, 3, 1, 0, 20]` and a window size `K=4`, find the maximum sum of any contiguous subarray of size K using the **Sliding Window** technique.",
    "inputFormat": "The function is called internally.",
    "outputFormat": "Print the maximum sum found.",
    "solution": {
      "explanation": "The **Sliding Window** technique solves array problems involving a fixed or variable-size subarray in linear $O(N)$ time. We first calculate the sum of the initial window (size $K$). Then, in the loop, we 'slide' the window one position to the right by performing an $O(1)$ update: **subtract the element leaving the window** (`arr[i-K]`) and **add the element entering the window** (`arr[i]`). We track the maximum sum encountered during this process.",
      "code": "def max_subarray_sum(arr, k):\n    current_sum = sum(arr[:k])\n    max_sum = current_sum\n    \n    for i in range(k, len(arr)):\n        # Slide: Subtract element leaving, add element entering\n        current_sum = current_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n\nresult = max_subarray_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4)\nprint(f\"Maximum sum: {result}\")"
    },
    "testCases": [
      {
        "input": "arr = [1, 4, 2, 10, 23, 3, 1, 0, 20], K=4",
        "expected": "Maximum sum: 38\n"
      },
      {
        "input": "arr = [10, 5, 2, 7, 8], K=3",
        "expected": "Maximum sum: 17\n"
      }
    ]
  },
  {
    "id": 62,
    "title": "Kadane's Algorithm: Max Contiguous Sum",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Implement **Kadane's Algorithm** to find the maximum sum of any contiguous subarray in `arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`. The subarray can include negative numbers.",
    "inputFormat": "The function is called internally.",
    "outputFormat": "Print the maximum contiguous sum.",
    "solution": {
      "explanation": "**Kadane's Algorithm** is a Dynamic Programming solution that finds the maximum sum of any contiguous subarray in $O(N)$ time. It tracks `current_max` (max sum ending at the current position) and `max_so_far` (the overall maximum). At each element, `current_max` decides whether to start a new subarray or extend the previous one. If `current_max + x` is less than `x`, the new subarray starts at `x`.",
      "code": "def kadane(arr):\n    max_so_far = arr[0]\n    current_max = arr[0]\n    \n    for x in arr[1:]:\n        # Start a new subarray at x OR extend the current one\n        current_max = max(x, current_max + x)\n        max_so_far = max(max_so_far, current_max)\n        \n    return max_so_far\n\nresult = kadane([-2, 1, -3, 4, -1, 2, 1, -5, 4])\nprint(f\"Max contiguous sum: {result}\")"
    },
    "testCases": [
      {
        "input": "arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]",
        "expected": "Max contiguous sum: 6\n"
      },
      {
        "input": "arr = [1, 2, 3]",
        "expected": "Max contiguous sum: 6\n"
      },
      {
        "input": "arr = [-10, -5, -2]",
        "expected": "Max contiguous sum: -2\n"
      }
    ]
  },
  {
    "id": 63,
    "title": "OOP: Simple Bank Account Class",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Define a class `BankAccount` with an `__init__` method to set an initial `balance` and methods for `deposit(amount)` and `withdraw(amount)`. Withdrawals should only succeed if the balance is sufficient.",
    "inputFormat": "Internal calls: deposit 100, withdraw 50, withdraw 60.",
    "outputFormat": "Print the balance after each operation and success/failure messages.",
    "solution": {
      "explanation": "This demonstrates basic **Object-Oriented Programming (OOP)**. The constructor (`__init__`) initializes the object's state (`self.balance`). The `deposit` and `withdraw` methods are instance methods that modify this state. The `withdraw` method includes **encapsulation** logic by checking if the `self.balance` is sufficient before allowing the transaction to proceed.",
      "code": "class BankAccount:\n    def __init__(self, initial_balance=0):\n        self.balance = initial_balance\n\n    def deposit(self, amount):\n        self.balance += amount\n        print(f\"Balance after deposit: {self.balance}\")\n\n    def withdraw(self, amount):\n        if self.balance >= amount:\n            self.balance -= amount\n            print(f\"Withdrawal successful. New balance: {self.balance}\")\n            return True\n        else:\n            print(\"Insufficient funds. Withdrawal failed.\")\n            return False\n\naccount = BankAccount()\naccount.deposit(100)\naccount.withdraw(50)\naccount.withdraw(60)"
    },
    "testCases": [
      {
        "input": "Initial balance 0. Deposit 100, Withdraw 50, Withdraw 60.",
        "expected": "Balance after deposit: 100\nWithdrawal successful. New balance: 50\nInsufficient funds. Withdrawal failed.\n"
      }
    ]
  },
  {
    "id": 64,
    "title": "OOP: Class and Instance Attributes",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Define a class `Car`. Use a **class attribute** `wheels = 4`. Use an **instance attribute** `color` set by the `__init__` method. Create two instances and print the `wheels` and `color` for both.",
    "inputFormat": "Internal instantiation of two Car objects.",
    "outputFormat": "Print attributes for two cars.",
    "solution": {
      "explanation": "In Python OOP, **Class Attributes** (`wheels = 4`) are defined directly under the class and are shared by all instances of that class. **Instance Attributes** (`self.color`) are defined within the `__init__` constructor and are unique to each individual object. Accessing `car1.wheels` retrieves the shared class-level value.",
      "code": "class Car:\n    # Class Attribute (shared)\n    wheels = 4\n\n    def __init__(self, color):\n        # Instance Attribute (unique to object)\n        self.color = color\n\ncar1 = Car('Red')\ncar2 = Car('Blue')\n\nprint(f\"Car 1: {car1.wheels} wheels, {car1.color}\")\nprint(f\"Car 2: {car2.wheels} wheels, {car2.color}\")"
    },
    "testCases": [
      {
        "input": "Car('Red'), Car('Blue')",
        "expected": "Car 1: 4 wheels, Red\nCar 2: 4 wheels, Blue\n"
      }
    ]
  },
  {
    "id": 65,
    "title": "Recursion: Fibonacci with Memoization",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a recursive function `fib(n)` to calculate the N-th Fibonacci number. Implement **memoization** using a dictionary to store previously calculated results.",
    "inputFormat": "Call `fib(7)` internally.",
    "outputFormat": "Print the result.",
    "solution": {
      "explanation": "Recursive Fibonacci without optimization has an exponential $O(2^N)$ complexity due to repeated calculations. **Memoization** (Top-Down Dynamic Programming) optimizes this by storing the result of each subproblem (`fib(n)`) in a cache (`memo` dictionary) before returning it. Before any calculation, the function checks the cache; if the result is present, it returns it immediately, reducing the complexity to $O(N)$.",
      "code": "memo = {}\n\ndef fib(n):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    \n    result = fib(n-1) + fib(n-2)\n    memo[n] = result # Store result in memo\n    return result\n\nprint(f\"Fibonacci(7): {fib(7)}\")"
    },
    "testCases": [
      {
        "input": "fib(7)",
        "expected": "Fibonacci(7): 13\n"
      },
      {
        "input": "fib(0)",
        "expected": "Fibonacci(0): 0\n"
      },
      {
        "input": "fib(1)",
        "expected": "Fibonacci(1): 1\n"
      }
    ]
  },
  {
    "id": 66,
    "title": "Chessboard: Knight's Valid Moves",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "In chess, a knight moves in an 'L' shape (two squares in one cardinal direction and then one square perpendicular). Given a position `(row, col)` on an $8 \\times 8$ board (0-indexed), write a function to return a list of all valid squares the knight can move to.",
    "inputFormat": "Call the function with a starting position, e.g., `(1, 1)`.",
    "outputFormat": "Print the list of valid move coordinates.",
    "solution": {
      "explanation": "The solution defines the 8 possible 'L' shaped moves a knight can make relative to its current position using a list of `offsets` (deltas in row and column). For each potential move, the function calculates the new coordinates (`nr, nc`) and then checks the **boundary condition** (`0 <= nr < 8 and 0 <= nc < 8`) to ensure the move remains on the $8 \\times 8$ chessboard.",
      "code": "def knight_moves(r, c):\n    # 8 possible L-shaped moves\n    offsets = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    valid_moves = []\n    for dr, dc in offsets:\n        nr, nc = r + dr, c + dc\n        # Check boundary conditions\n        if 0 <= nr < 8 and 0 <= nc < 8:\n            valid_moves.append((nr, nc))\n    return valid_moves\n\nprint(f\"Valid moves: {knight_moves(1, 1)}\")"
    },
    "testCases": [
      {
        "input": "start = (1, 1)",
        "expected": "Valid moves: [(0, 3), (2, 3), (3, 2), (3, 0)]\n"
      },
      {
        "input": "start = (0, 0)",
        "expected": "Valid moves: [(1, 2), (2, 1)]\n"
      },
      {
        "input": "start = (4, 4)",
        "expected": "Valid moves: [(2, 3), (2, 5), (3, 2), (3, 6), (5, 2), (5, 6), (6, 3), (6, 5)]\n"
      }
    ]
  },
  {
    "id": 67,
    "title": "Real World: URL Slug Generator",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a function `slugify(text)` that converts a title string (e.g., 'Python For Data Science!') into a web-friendly URL slug (e.g., 'python-for-data-science'). The slug should be lowercase and separate words with hyphens.",
    "inputFormat": "The function is called with a sample title.",
    "outputFormat": "Print the resulting slug.",
    "solution": {
      "explanation": "A URL slug generator requires string cleaning using regular expressions (`re` module). The steps are: 1. Convert the entire string to **lowercase**. 2. Use `re.sub(r'[^\\w\\s-]', '', text)` to **remove all non-word characters** (like `!`, `?`, etc.). 3. Use `re.sub(r'\\s+', '-', text)` to **replace all sequences of whitespace** with a single hyphen (`-`), making the string web-friendly.",
      "code": "import re\n\ndef slugify(text):\n    # Convert to lowercase\n    text = text.lower()\n    # Replace non-word characters (except space/hyphen) with nothing\n    text = re.sub(r'[^\\w\\s-]', '', text)\n    # Replace whitespace with a single hyphen\n    text = re.sub(r'\\s+', '-', text)\n    # Strip leading/trailing hyphens (optional)\n    return text.strip('-')\n\nprint(slugify('Python For Data Science!'))"
    },
    "testCases": [
      {
        "input": "title = 'Python For Data Science!'",
        "expected": "python-for-data-science\n"
      },
      {
        "input": "title = 'The 5 best features of 2024'",
        "expected": "the-5-best-features-of-2024\n"
      }
    ]
  },
  {
    "id": 68,
    "title": "Function with Default and Keyword Args",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Define a function `configure_server(ip='127.0.0.1', port=8080, protocol='HTTP')`. Call the function once using only the default arguments, and once overriding the `port` using a keyword argument.",
    "inputFormat": "Internal function calls.",
    "outputFormat": "Print the configuration dictionary for both calls.",
    "solution": {
      "explanation": "This demonstrates Python's flexible function arguments. **Default arguments** are defined in the function signature. When the function is called without that argument, the default is used. **Keyword arguments** (e.g., `port=443`) allow the caller to pass values by name, which improves readability and allows the caller to skip optional arguments.",
      "code": "def configure_server(ip='127.0.0.1', port=8080, protocol='HTTP'):\n    return {'ip': ip, 'port': port, 'protocol': protocol}\n\n# Call 1: Default\nprint(configure_server())\n\n# Call 2: Override port using keyword argument\nprint(configure_server(port=443))"
    },
    "testCases": [
      {
        "input": "Call 1: Default. Call 2: port=443",
        "expected": "{'ip': '127.0.0.1', 'port': 8080, 'protocol': 'HTTP'}\n{'ip': '127.0.0.1', 'port': 443, 'protocol': 'HTTP'}\n"
      }
    ]
  },
  {
    "id": 69,
    "title": "Real World: Password Strength Checker",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a function `check_password(password)` that returns a list of missing requirements for a password to be 'strong': at least 8 characters, and contain at least one uppercase letter and one digit.",
    "inputFormat": "Test the function with a weak password, e.g., 'secret'.",
    "outputFormat": "Print the list of missing requirements.",
    "solution": {
      "explanation": "This function verifies password strength requirements using Python's built-in string methods combined with the **`any()`** function. For instance, to check for an uppercase letter, we use a generator expression `(c.isupper() for c in password)` which yields `True` if any character satisfies the condition. If `any()` returns `False`, the requirement is missing and added to the `missing` list.",
      "code": "def check_password(password):\n    missing = []\n    if len(password) < 8:\n        missing.append('Length < 8')\n    if not any(c.isupper() for c in password):\n        missing.append('Missing uppercase')\n    if not any(c.isdigit() for c in password):\n        missing.append('Missing digit')\n    return missing\n\nresult = check_password('secret')\nprint(f\"Missing: {result}\")"
    },
    "testCases": [
      {
        "input": "password = 'secret'",
        "expected": "Missing: ['Length < 8', 'Missing uppercase', 'Missing digit']\n"
      },
      {
        "input": "password = 'Secure123'",
        "expected": "Missing: []\n"
      },
      {
        "input": "password = 'onlydigits123'",
        "expected": "Missing: ['Missing uppercase']\n"
      }
    ]
  },
  {
    "id": 70,
    "title": "Real World: Date Format Validator",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a function `is_valid_date(date_str)` that uses the `datetime` module and exception handling to check if a string matches the format 'YYYY-MM-DD'.",
    "inputFormat": "Test with a valid date ('2025-01-31') and an invalid one ('2025/01/31').",
    "outputFormat": "Print `True` or `False` for each test case.",
    "solution": {
      "explanation": "Date validation is efficiently handled by the **`datetime.strptime()`** function. This function attempts to parse a string into a date object according to the specified format string (`%Y-%m-%d`). If the input string is invalid (wrong format, non-existent date like '2025-02-30', etc.), `strptime` raises a **`ValueError`**. We wrap the parsing attempt in a `try-except` block to catch this error and return `False` gracefully.",
      "code": "from datetime import datetime\n\ndef is_valid_date(date_str, fmt='%Y-%m-%d'):\n    try:\n        datetime.strptime(date_str, fmt)\n        return True\n    except ValueError:\n        return False\n\nprint(f\"2025-01-31: {is_valid_date('2025-01-31')}\")\nprint(f\"2025/01/31: {is_valid_date('2025/01/31')}\")"
    },
    "testCases": [
      {
        "input": "Valid: '2025-01-31', Invalid: '2025/01/31'",
        "expected": "2025-01-31: True\n2025/01/31: False\n"
      },
      {
        "input": "Valid: '1999-12-31', Invalid: '1999-13-01'",
        "expected": "1999-12-31: True\n1999-13-01: False\n"
      }
    ]
  },
  {
    "id": 71,
    "title": "Binary Search: Find Insertion Point",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Given a sorted list `arr = [1, 3, 5, 6]` and a `target = 5`, return the index where the target is found. If the target is not found (e.g., `target = 2`), return the index where it would be correctly inserted.",
    "inputFormat": "Test with target 5 and target 2.",
    "outputFormat": "Print the insertion index for both cases.",
    "solution": {
      "explanation": "For finding an insertion point in a sorted sequence, Python's standard library module **`bisect`** is the most robust and efficient tool, running in $O(\\log N)$ time. The function **`bisect_left(a, x)`** returns the index where element $x$ should be inserted into list $a$ to maintain sorted order. Critically, if $x$ is already present, it returns the index of the existing left-most occurrence, making it suitable for both searching and insertion point logic.",
      "code": "from bisect import bisect_left\n\narr = [1, 3, 5, 6]\n\n# Target 5 is found at index 2\nindex1 = bisect_left(arr, 5)\nprint(f\"Target 5 index: {index1}\")\n\n# Target 2 is not found, insertion point is index 1\nindex2 = bisect_left(arr, 2)\nprint(f\"Target 2 index: {index2}\")"
    },
    "testCases": [
      {
        "input": "arr = [1, 3, 5, 6], target = 5 and target = 2",
        "expected": "Target 5 index: 2\nTarget 2 index: 1\n"
      },
      {
        "input": "arr = [1, 3, 5, 6], target = 0 and target = 7",
        "expected": "Target 0 index: 0\nTarget 7 index: 4\n"
      }
    ]
  },
  {
    "id": 72,
    "title": "Longest Common Subsequence (DP)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a function `lcs_length(s1, s2)` to find the length of the **Longest Common Subsequence (LCS)** between two strings, `s1='AGGTAB'` and `s2='GXTXAYB'`, using a **Dynamic Programming** table (2D list).",
    "inputFormat": "The function is called internally.",
    "outputFormat": "Print the length of the LCS.",
    "solution": {
      "explanation": "The **Longest Common Subsequence (LCS)** problem is a classic application of **Dynamic Programming**. A 2D table (`dp`) is used, where $dp[i][j]$ stores the LCS length of prefixes of length $i$ and $j$. The key recurrence is: if the characters $s1[i-1]$ and $s2[j-1]$ match, $dp[i][j]$ is $1 + dp[i-1][j-1]$; otherwise, $dp[i][j]$ is the maximum of the adjacent top and left cells, $\\max(dp[i-1][j], dp[i][j-1])$. The final length is at $dp[m][n]$.",
      "code": "def lcs_length(s1, s2):\n    m, n = len(s1), len(s2)\n    # Initialize DP table with zeros\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                \n    return dp[m][n]\n\nprint(f\"LCS Length: {lcs_length('AGGTAB', 'GXTXAYB')}\")"
    },
    "testCases": [
      {
        "input": "s1='AGGTAB', s2='GXTXAYB'",
        "expected": "LCS Length: 4\n"
      },
      {
        "input": "s1='ABC', s2='ACB'",
        "expected": "LCS Length: 2\n"
      },
      {
        "input": "s1='A', s2='B'",
        "expected": "LCS Length: 0\n"
      }
    ]
  },
  {
    "id": 73,
    "title": "0/1 Knapsack (Dynamic Programming)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Solve the **0/1 Knapsack Problem** using **Dynamic Programming**. Given `weights=[2, 1, 3, 2]`, `values=[12, 10, 20, 15]`, and `capacity=5`, find the maximum total value.",
    "inputFormat": "The function is called internally.",
    "outputFormat": "Print the maximum value achievable.",
    "solution": {
      "explanation": "The 0/1 Knapsack problem is solved with **Dynamic Programming** using a 2D table, $dp[i][w]$. $dp[i][w]$ represents the max value achievable using the first $i$ items with a weight capacity $w$. The logic for each cell is a choice between two options:\n\n1.  **Exclude:** The value remains $dp[i-1][w]$.\n2.  **Include:** The value is $v_i$ plus the max value from the remaining capacity $dp[i-1][w-w_i]$.\n\nThe solution takes the maximum of these two options.",
      "code": "def knapsack_dp(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        w_i, v_i = weights[i-1], values[i-1]\n        for w in range(capacity + 1):\n            if w_i > w:\n                dp[i][w] = dp[i-1][w]\n            else:\n                dp[i][w] = max(dp[i-1][w], v_i + dp[i-1][w - w_i])\n                \n    return dp[n][capacity]\n\nresult = knapsack_dp([2, 1, 3, 2], [12, 10, 20, 15], 5)\nprint(f\"Maximum value: {result}\")"
    },
    "testCases": [
      {
        "input": "weights=[2, 1, 3, 2], values=[12, 10, 20, 15], capacity=5",
        "expected": "Maximum value: 37\n"
      },
      {
        "input": "weights=[10, 20, 30], values=[60, 100, 120], capacity=50",
        "expected": "Maximum value: 220\n"
      }
    ]
  },
  {
    "id": 74,
    "title": "Dijkstra's Algorithm (using heapq)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Implement **Dijkstra's Shortest Path Algorithm** for a graph starting at node 'A'. Use `heapq` for an efficient priority queue implementation.",
    "inputFormat": "The function is called internally with a graph dictionary.",
    "outputFormat": "Print the dictionary of shortest distances.",
    "solution": {
      "explanation": "**Dijkstra's Algorithm** finds the shortest path and is optimized using a **Min-Priority Queue** for $O((V+E)\\log V)$ complexity. In Python, the **`heapq`** module implements a Min-Heap. We store `(distance, node)` tuples in the heap. The `heappop()` operation efficiently retrieves the unvisited node with the smallest distance, enabling the **relaxation** process where neighbor distances are updated if a shorter path is found.",
      "code": "import heapq\n\ndef dijkstra(graph, start_node):\n    distances = {node: float('inf') for node in graph}\n    distances[start_node] = 0\n    pq = [(0, start_node)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n            \n        for neighbor, weight in graph.get(current_node, []):\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n                \n    return distances\n\ngraph = {'A': [('B', 1), ('C', 4)], 'B': [('C', 2), ('D', 3)], 'C': [('D', 1), ('E', 5)], 'D': [('E', 2)], 'E': []}\nprint(dijkstra(graph, 'A'))"
    },
    "testCases": [
      {
        "input": "Graph: {'A': [('B', 1), ('C', 4)], ...}",
        "expected": "{'A': 0, 'B': 1, 'C': 3, 'D': 4, 'E': 6}\n"
      }
    ]
  },
  {
    "id": 75,
    "title": "Graph DFS (Recursive)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Implement a **recursive Depth-First Search (DFS)** function for an undirected graph represented by an adjacency list dictionary, starting at node 'A'.",
    "inputFormat": "The function is called internally.",
    "outputFormat": "Print the visited nodes in DFS order.",
    "solution": {
      "explanation": "**Depth-First Search (DFS)** is a recursive traversal algorithm. It uses a **`set`** to efficiently track `visited` nodes. The function marks the current `node` as visited and then recursively calls itself on each of the node's **unvisited neighbors**. Because recursion uses the call stack, DFS naturally explores the graph as deep as possible down one path before backtracking.",
      "code": "def dfs(graph, node, visited):\n    if node in visited:\n        return\n    \n    visited.add(node)\n    print(node, end=\" \")\n    \n    for neighbor in graph.get(node, []):\n        dfs(graph, neighbor, visited)\n        \ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': [], 'F': ['C']}\nvisited = set()\nprint(\"DFS order:\", end=\" \")\ndfs(graph, 'A', visited)\nprint()"
    },
    "testCases": [
      {
        "input": "Graph: {'A': ['B', 'C'], 'B': ['D'], ...}",
        "expected": "DFS order: A B D F C E \n"
      }
    ]
  },
  {
    "id": 76,
    "title": "Memoization: Caching Factorial",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a recursive function `factorial(n)` and apply the **`@functools.lru_cache`** decorator to implement memoization. Calculate `factorial(10)` and print the result.",
    "inputFormat": "Call `factorial(10)` internally.",
    "outputFormat": "Print the factorial result.",
    "solution": {
      "explanation": "The **`@functools.lru_cache`** decorator provides the simplest and most Pythonic way to implement **Memoization** (caching) for a function. It automatically stores the results of past function calls in a dictionary. When the function is called again with the same arguments, the cached result is returned instantly, preventing redundant calculations and drastically speeding up recursive or computationally expensive functions like factorial or Fibonacci.",
      "code": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n-1)\n\nprint(f\"Factorial of 10 is: {factorial(10)}\")"
    },
    "testCases": [
      {
        "input": "factorial(10)",
        "expected": "Factorial of 10 is: 3628800\n"
      },
      {
        "input": "factorial(0)",
        "expected": "Factorial of 0 is: 1\n"
      },
      {
        "input": "factorial(5)",
        "expected": "Factorial of 5 is: 120\n"
      }
    ]
  },
  {
    "id": 77,
    "title": "Decorator: Measure Execution Time",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a **decorator** `measure_time` that wraps a function, calculates its execution time, and prints the result. Apply it to a dummy function `slow_task` that sleeps for 0.5 seconds.",
    "inputFormat": "Call the decorated function internally.",
    "outputFormat": "Print the task message and the execution time.",
    "solution": {
      "explanation": "A **Decorator** is a callable that wraps a function, modifying its behavior. The `measure_time` decorator uses `time.perf_counter()` to record the time immediately before and after calling the wrapped function (`func`). The difference calculates the execution time, which is then printed. The **`@wraps`** decorator from `functools` is crucial, as it preserves the original function's metadata (like its name and docstrings).",
      "code": "import time\nfrom functools import wraps\n\ndef measure_time(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        print(f\"Execution Time: {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@measure_time\ndef slow_task():\n    time.sleep(0.5)\n    print(\"Task finished.\")\n\nslow_task()"
    },
    "testCases": [
      {
        "input": "slow_task()",
        "expected": "Task finished.\nExecution Time: 0.5xxx seconds\n"
      }
    ]
  },
  {
    "id": 78,
    "title": "Generator: Infinite Fibonacci",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a **generator function** `infinite_fib()` that yields Fibonacci numbers indefinitely. Use `itertools.islice` to retrieve and print the first 10 numbers efficiently.",
    "inputFormat": "Internal usage of the generator.",
    "outputFormat": "Print the first 10 Fibonacci numbers.",
    "solution": {
      "explanation": "A **Generator function** uses the **`yield`** keyword instead of `return` to produce a sequence of results one at a time, allowing it to generate an **infinite sequence** (like Fibonacci) without consuming large amounts of memory. The `itertools.islice` utility is then used to safely extract a finite subset (the first 10 numbers) from the infinite stream, controlling the loop externally.",
      "code": "from itertools import islice\n\ndef infinite_fib():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nfirst_ten = list(islice(infinite_fib(), 10))\nprint(', '.join(map(str, first_ten)))"
    },
    "testCases": [
      {
        "input": "islice(infinite_fib(), 10)",
        "expected": "0, 1, 1, 2, 3, 5, 8, 13, 21, 34\n"
      }
    ]
  },
  {
    "id": 79,
    "title": "Context Manager: File Closer",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Implement a **Context Manager** class `ManagedFile` with `__enter__` and `__exit__` to safely open a file for writing and ensure it is always closed, even if an error occurs within the `with` block.",
    "inputFormat": "Internal usage of the context manager.",
    "outputFormat": "Print the start and end messages.",
    "solution": {
      "explanation": "A **Context Manager** is implemented using the `__enter__` and `__exit__` methods. The `__enter__` method returns the resource (the opened file object). The **`__exit__`** method is guaranteed to run, even if an exception occurs within the `with` block. Its role is to perform necessary **cleanup**, ensuring that the file is always properly closed and preventing resource leaks.",
      "code": "class ManagedFile:\n    def __init__(self, name, mode):\n        self.name = name\n        self.mode = mode\n        self.file = None\n\n    def __enter__(self):\n        self.file = open(self.name, self.mode)\n        print(\"File opened successfully.\")\n        return self.file\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n        print(\"File closed.\")\n        # Suppress exception if needed, by returning True\n        return False\n\n# NOTE: This creates a temporary file named 'test.txt'\nwith ManagedFile('test.txt', 'w') as f:\n    f.write('Managed content.')"
    },
    "testCases": [
      {
        "input": "with ManagedFile('output.txt', 'w') as f:",
        "expected": "File opened successfully.\nFile closed.\n"
      }
    ]
  },
  {
    "id": 80,
    "title": "LRU Cache (using OrderedDict)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Design and implement an **LRU Cache** class with capacity 2, using `collections.OrderedDict`. Implement `get(key)` (updates MRU status) and `put(key, value)` (handles eviction).",
    "inputFormat": "Internal sequence of operations.",
    "outputFormat": "Print the result of `get` and the evicted key.",
    "solution": {
      "explanation": "The **Least Recently Used (LRU) Cache** is implemented efficiently using Python's **`collections.OrderedDict`**, which maintains the order of key insertion. When `get(key)` is called, `move_to_end(key)` is used to update the key's position to the most recently used (MRU) end. When `put(key, value)` hits capacity, the oldest (LRU) item is removed from the front using `popitem(last=False)`.",
      "code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache: return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n        else:\n            if len(self.cache) >= self.capacity:\n                # Pop LRU item (the first one added)\n                lru_key, _ = self.cache.popitem(last=False)\n                print(f\"Evicted key: {lru_key}\")\n            self.cache[key] = value\n\nlru = LRUCache(2)\nlru.put(1, 'A')\nlru.put(2, 'B')\nlru.get(1) # Access 1\nlru.put(3, 'C') # 2 should be evicted\nprint(f\"Get(1) value: {lru.get(1)}\")"
    },
    "testCases": [
      {
        "input": "Put(1, 'A'), Put(2, 'B'), Get(1), Put(3, 'C')",
        "expected": "Evicted key: 2\nGet(1) value: A\n"
      }
    ]
  },
  {
    "id": 81,
    "title": "OOP: Custom `@property` and Setter",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Define a class `Circle` with a private instance attribute `_radius`. Use the `@property` decorator to create a read-only `area` attribute and a `radius` setter to enforce that the radius must be positive.",
    "inputFormat": "Internal: Create a circle, set a new valid radius, and try an invalid radius.",
    "outputFormat": "Print the area, new radius, and error message.",
    "solution": {
      "explanation": "The **`@property`** decorator allows a method to be accessed like an attribute (`circle.area`), dynamically calculating its value. The **`@radius.setter`** method is essential for **validation** and **encapsulation**. It defines the logic that runs whenever the attribute is assigned a new value. This logic checks the value (e.g., ensuring it's positive) before updating the internal private variable (`self._radius`), thus protecting the object's state.",
      "code": "import math\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def area(self):\n        return math.pi * (self._radius ** 2)\n\n    @property\n    def radius(self):\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):\n        if value > 0:\n            self._radius = value\n        else:\n            print(\"Error: Radius must be positive.\")\n\ncircle = Circle(5)\nprint(f\"Initial Area: {circle.area:.2f}\")\ncircle.radius = 10\nprint(f\"New Radius: {circle.radius}\")\ncircle.radius = -1"
    },
    "testCases": [
      {
        "input": "Initial radius 5. Set radius to 10. Set radius to -1.",
        "expected": "Initial Area: 78.54\nNew Radius: 10\nError: Radius must be positive.\n"
      }
    ]
  },
  {
    "id": 82,
    "title": "Real World: Process CSV and Calculate Average",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Simulate reading a CSV file with columns 'name' and 'score'. Use the `csv` module's `DictReader` to calculate the average score.",
    "inputFormat": "Internal string data simulating a file.",
    "outputFormat": "Print the calculated average score.",
    "solution": {
      "explanation": "The **`csv.DictReader`** is the standard Python tool for reading CSV data. It treats the first row as headers and converts every subsequent row into a dictionary where the keys are the column headers. This simplifies data access, as we can directly retrieve scores using `row['score']`. The scores are summed up and counted to calculate the average.",
      "code": "import csv\nfrom io import StringIO\n\ncsv_data = \"name,score\\nAlice,85\\nBob,92\\nCharlie,78\"\ncsvfile = StringIO(csv_data)\nreader = csv.DictReader(csvfile)\n\ntotal_score = 0\ncount = 0\nfor row in reader:\n    total_score += int(row['score'])\n    count += 1\n    \nprint(f\"Average score: {total_score / count}\")"
    },
    "testCases": [
      {
        "input": "data: name,score\\nAlice,85\\nBob,92\\nCharlie,78",
        "expected": "Average score: 85.0\n"
      },
      {
        "input": "data: name,score\\nTom,100\\nJerry,50",
        "expected": "Average score: 75.0\n"
      }
    ]
  },
  {
    "id": 83,
    "title": "Real World: JSON Serialization",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Given a dictionary `data = {'name': 'Project', 'version': 1.0}`, use the `json` module to serialize it into a JSON formatted string, ensuring it is **pretty-printed** with an indent of 2.",
    "inputFormat": "The program uses a hardcoded dictionary.",
    "outputFormat": "Print the resulting JSON string.",
    "solution": {
      "explanation": "The **`json.dumps()`** function converts a Python object (like a dictionary) into a JSON formatted string. The key to pretty-printing is the **`indent`** parameter, which structures the output with line breaks and the specified number of spaces for indentation, making the serialized data much more human-readable.",
      "code": "import json\n\ndata = {\n    'name': 'Project',\n    'version': 1.0,\n    'status': 'complete'\n}\n\njson_string = json.dumps(data, indent=2)\nprint(json_string)"
    },
    "testCases": [
      {
        "input": "data = {'name': 'Project', 'version': 1.0}",
        "expected": "{\n  \"name\": \"Project\",\n  \"version\": 1.0,\n  \"status\": \"complete\"\n}\n"
      }
    ]
  },
  {
    "id": 84,
    "title": "Chessboard: Check King's Safety",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a function `is_king_safe(king, queen)` that takes the positions of a king and a queen (e.g., `(4, 4)`) and determines if the king is currently attacked by the queen.",
    "inputFormat": "Test the function with positions where the queen attacks and where it doesn't.",
    "outputFormat": "Print `True` or `False` for each test case.",
    "solution": {
      "explanation": "A Queen attacks a King if they share the same row, same column, or any diagonal. The logic involves checking three conditions: 1. **Same Row:** $r_k == r_q$. 2. **Same Column:** $c_k == c_q$. 3. **Same Diagonal:** The absolute difference between their row coordinates must equal the absolute difference between their column coordinates: $abs(r_k - r_q) == abs(c_k - c_q)$. The king is safe if *none* of these conditions are met.",
      "code": "def is_king_safe(king, queen):\n    r_k, c_k = king\n    r_q, c_q = queen\n    \n    # Check Row, Column, and Diagonal attack\n    is_row_attack = r_k == r_q\n    is_col_attack = c_k == c_q\n    is_diag_attack = abs(r_k - r_q) == abs(c_k - c_q)\n    \n    return not (is_row_attack or is_col_attack or is_diag_attack)\n\nprint(f\"Attacked: {not is_king_safe((4, 4), (4, 6))}\")\nprint(f\"Safe: {is_king_safe((4, 4), (5, 6))}\")"
    },
    "testCases": [
      {
        "input": "king=(4, 4), queen=(4, 6) and king=(4, 4), queen=(5, 6)",
        "expected": "Attacked: True\nSafe: False\n"
      },
      {
        "input": "king=(1, 1), queen=(8, 8)",
        "expected": "Attacked: True\nSafe: False\n"
      }
    ]
  },
  {
    "id": 85,
    "title": "Chessboard: Validate N-Queens Placement",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a function `is_valid_nqueens(board)` to check if a list of queen column positions (`board`) for an $N \\times N$ board represents a valid, non-attacking placement.",
    "inputFormat": "Test with a valid 4-Queens solution `[1, 3, 0, 2]` and an invalid one `[0, 1, 2, 3]`.",
    "outputFormat": "Print `True` or `False` for each test case.",
    "solution": {
      "explanation": "In an N-Queens solution represented by an array of column positions (`board`), each row already has a unique queen. We only need to check for **column conflicts** and **diagonal conflicts**. The check compares every pair of queens $(i, j)$: if $board[i] == board[j]$ (column conflict) or $abs(board[i] - board[j]) == abs(i - j)$ (diagonal conflict), the placement is invalid.",
      "code": "def is_valid_nqueens(board):\n    n = len(board)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check column conflict (should never happen if logic is correct, but safe to check)\n            if board[i] == board[j]:\n                return False\n            # Check diagonal conflict: |col1 - col2| == |row1 - row2|\n            if abs(board[i] - board[j]) == abs(i - j):\n                return False\n    return True\n\nprint(f\"Valid placement: {is_valid_nqueens([1, 3, 0, 2])}\")\nprint(f\"Invalid placement: {is_valid_nqueens([0, 1, 2, 3])}\")"
    },
    "testCases": [
      {
        "input": "Valid: [1, 3, 0, 2], Invalid: [0, 1, 2, 3]",
        "expected": "Valid placement: True\nInvalid placement: False\n"
      }
    ]
  },
  {
    "id": 86,
    "title": "Real World: Log File Error Rate",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a function `calculate_error_rate(log_data)` that takes a list of log lines and calculates the percentage of lines that contain the substring 'ERROR' (case-insensitive).",
    "inputFormat": "Test with a sample log list.",
    "outputFormat": "Print the error rate as a percentage.",
    "solution": {
      "explanation": "This function calculates a ratio using a list comprehension combined with the **`sum()`** function. The expression `sum(1 for line in log_data if 'error' in line.lower())` filters the logs case-insensitively, counting 1 for every line that contains 'error'. The result is then divided by the total number of lines and multiplied by 100 to yield the percentage.",
      "code": "def calculate_error_rate(log_data):\n    total_lines = len(log_data)\n    if total_lines == 0: return 0.0\n    \n    error_count = sum(1 for line in log_data if 'error' in line.lower())\n    \n    return (error_count / total_lines) * 100\n\nlogs = ['INFO: task started', 'ERROR: failed', 'DEBUG: heartbeat', 'Warning: low disk']\nresult = calculate_error_rate(logs)\nprint(f\"Error rate: {result:.2f}%\")"
    },
    "testCases": [
      {
        "input": "logs = ['INFO: task started', 'ERROR: failed', 'DEBUG: ...']",
        "expected": "Error rate: 33.33%\n"
      },
      {
        "input": "logs = ['info', 'warning', 'error']",
        "expected": "Error rate: 33.33%\n"
      },
      {
        "input": "logs = ['INFO', 'DEBUG']",
        "expected": "Error rate: 0.00%\n"
      }
    ]
  },
  {
    "id": 87,
    "title": "Real World: Simple API Mock Class",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Define a class `APIMock` that simulates fetching user data. The `get_user(id)` method should return a hardcoded dictionary for `id=1` and raise a custom `UserNotFound` exception for any other ID.",
    "inputFormat": "Test calls for id 1 and id 2.",
    "outputFormat": "Print the returned user data or the exception message.",
    "solution": {
      "explanation": "This demonstrates how to define and use a **Custom Exception** in Python by inheriting from the built-in `Exception` class. When the ID is not found, the `get_user` method uses the **`raise`** keyword to signal a specialized error (`UserNotFound`) to the calling code. The calling code then specifically handles this custom error type using a `try-except` block.",
      "code": "class UserNotFound(Exception):\n    pass\n\nclass APIMock:\n    def get_user(self, id):\n        if id == 1:\n            return {'id': 1, 'name': 'Neo'}\n        else:\n            raise UserNotFound(f\"User with ID {id} not found in mock API.\")\n\napi = APIMock()\nprint(api.get_user(1))\ntry:\n    api.get_user(2)\nexcept UserNotFound as e:\n    print(e)"
    },
    "testCases": [
      {
        "input": "get_user(1) and get_user(2)",
        "expected": "{'id': 1, 'name': 'Neo'}\nUserNotFound: User with ID 2 not found in mock API.\n"
      }
    ]
  },
  {
    "id": 88,
    "title": "Graph BFS (Adjacency List)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Implement **Breadth-First Search (BFS)** for a graph starting at node 'A'. Use `collections.deque` for the queue structure and a set for visited nodes.",
    "inputFormat": "Internal graph dictionary: `{'A': ['B', 'C'], 'B': ['D'], ...}`",
    "outputFormat": "Print the visited nodes in BFS order.",
    "solution": {
      "explanation": "**Breadth-First Search (BFS)** is a graph traversal algorithm that explores nodes layer by layer. It requires a **Queue** (FIFO: First-In, First-Out) to store nodes to visit next. Python's **`collections.deque`** is used for efficient $O(1)$ appends and pops from the left end. A `visited` set ensures that each node is processed exactly once.",
      "code": "from collections import deque\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = {start}\n    order = []\n    \n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return ' '.join(order)\n\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': [], 'F': []}\nprint(f\"BFS order: {bfs(graph, 'A')}\")"
    },
    "testCases": [
      {
        "input": "Start node 'A'",
        "expected": "BFS order: A B C D E F\n"
      }
    ]
  },
  {
    "id": 89,
    "title": "Real World: Password Generator",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a function `generate_password(length)` that creates a random, cryptographically secure password of a given length, containing a mix of digits, lowercase, and uppercase letters. Use the **`secrets` module**.",
    "inputFormat": "Call the function with a length of 12.",
    "outputFormat": "Print the generated password (will be random).",
    "solution": {
      "explanation": "For cryptographically secure applications like password generation, the **`secrets`** module is mandatory, as it uses a cryptographically secure pseudo-random number generator, unlike the standard `random` module. The function defines the character pool using `string.ascii_letters` and `string.digits` and then uses `secrets.choice()` repeatedly to select characters from this pool.",
      "code": "import secrets\nimport string\n\ndef generate_password(length):\n    chars = string.ascii_letters + string.digits\n    # Use secrets.choice for cryptographic randomness\n    password = ''.join(secrets.choice(chars) for _ in range(length))\n    return password\n\nprint(f\"Generated Password: {generate_password(12)}\")"
    },
    "testCases": [
      {
        "input": "length = 12",
        "expected": "Generated Password: 5jK8oP3tA1qZ\n"
      }
    ]
  },
  {
    "id": 90,
    "title": "Real World: Stock Price Calculator",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Define a function `stock_analysis(prices)` that takes a list of historical stock prices and returns the **maximum profit** that could have been made by buying and selling once (or 0 if no profit is possible).",
    "inputFormat": "Test with a sample price list.",
    "outputFormat": "Print the maximum profit.",
    "solution": {
      "explanation": "This problem is solved in $O(N)$ linear time by iterating through the prices only once. The algorithm maintains two variables: `min_price` (the lowest price seen up to the current day) and `max_profit` (the highest profit found so far). At each price point, the potential profit is calculated (`price - min_price`), and the `max_profit` is updated accordingly.",
      "code": "def stock_analysis(prices):\n    if not prices: return 0\n    \n    min_price = prices[0]\n    max_profit = 0\n    \n    for price in prices[1:]:\n        min_price = min(min_price, price)\n        current_profit = price - min_price\n        max_profit = max(max_profit, current_profit)\n        \n    return max_profit\n\nresult = stock_analysis([7, 1, 5, 3, 6, 4])\nprint(f\"Max Profit: {result}\")"
    },
    "testCases": [
      {
        "input": "prices = [7, 1, 5, 3, 6, 4]",
        "expected": "Max Profit: 5\n"
      },
      {
        "input": "prices = [7, 6, 4, 3, 1]",
        "expected": "Max Profit: 0\n"
      },
      {
        "input": "prices = [1, 2, 3]",
        "expected": "Max Profit: 2\n"
      }
    ]
  },
  {
    "id": 91,
    "title": "0/1 Knapsack (DP implementation)",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a Python function `knapsack(weights, values, capacity)` that solves the **0/1 Knapsack Problem** using **Dynamic Programming (DP)**. Given lists of weights and values for N items, and a knapsack capacity, find the maximum total value that can be achieved without exceeding the capacity. Assume items are indivisible (you must take all or none of an item).",
    "inputFormat": "The function is called internally with:\n\n* `weights = [2, 1, 3, 2]`\n* `values = [12, 10, 20, 15]`\n* `capacity = 5`",
    "outputFormat": "A single line printing the maximum value achievable.",
    "solution": {
      "explanation": "The 0/1 Knapsack problem is solved with **Dynamic Programming** using a 2D table, $DP[i][w]$. $DP[i][w]$ represents the max value achievable using the first $i$ items with a weight capacity $w$. The logic for each cell is a choice between two options:\n\n1.  **Exclude:** The value remains $DP[i-1][w]$.\n2.  **Include:** The value is $v_i$ plus the max value from the remaining capacity $DP[i-1][w-w_i]$.\n\nThe solution takes the maximum of these two options.",
      "code": "def knapsack(weights, values, capacity):\n    N = len(weights)\n    \n    # Initialize the DP table: rows for items (N+1), columns for capacity (capacity+1)\n    # dp[i][w] is the max value using first i items with capacity w\n    dp = [[0] * (capacity + 1) for _ in range(N + 1)]\n    \n    # Iterate through each item\n    for i in range(1, N + 1):\n        # Current item's weight and value (using i-1 for 0-based array index)\n        w_i = weights[i-1]\n        v_i = values[i-1]\n        \n        # Iterate through each possible capacity\n        for w in range(capacity + 1):\n            if w_i > w:\n                # Case 1: Item is too heavy, must exclude it\n                dp[i][w] = dp[i-1][w]\n            else:\n                # Case 2: Max of (excluding item) OR (including item)\n                value_without_item = dp[i-1][w]\n                value_with_item = v_i + dp[i-1][w - w_i]\n                \n                dp[i][w] = max(value_without_item, value_with_item)\n                \n    # The bottom-right cell holds the maximum value\n    return dp[N][capacity]\n\n# Test case\nW = [2, 1, 3, 2]\nV = [12, 10, 20, 15]\nC = 5\n\nresult = knapsack(W, V, C)\nprint(f\"Maximum value achievable: {result}\")"
    },
    "testCases": [
      {
        "input": "weights=[2, 1, 3, 2], values=[12, 10, 20, 15], capacity=5",
        "expected": "Maximum value achievable: 37\n"
      }
    ]
  },
  {
    "id": 92,
    "title": "Unpacking and Merging Dictionaries",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Given `user = {'name': 'Alice', 'role': 'User'}` and `updates = {'role': 'Admin', 'active': True}`, create a new dictionary merging both, with `updates` taking precedence.",
    "inputFormat": "The program uses hardcoded dictionaries.",
    "outputFormat": "Print the merged dictionary.",
    "solution": {
      "explanation": "The most modern and standard way to merge dictionaries in Python (3.5+) is using the **Dictionary Unpacking Operator** (`**`). The syntax `{**user, **updates}` creates a new dictionary by spreading both sources. The order matters: since `updates` is spread last, its values for any overlapping keys (like `'role'`) will overwrite those from the `user` dictionary.",
      "code": "user = {'name': 'Alice', 'role': 'User'}\nupdates = {'role': 'Admin', 'active': True}\n\nmerged_data = {**user, **updates}\nprint(merged_data)"
    },
    "testCases": [
      {
        "input": "user, updates",
        "expected": "{'name': 'Alice', 'role': 'Admin', 'active': True}\n"
      },
      {
        "input": "d1, d2",
        "expected": "{'a': 1, 'b': 3, 'c': 4}\n"
      }
    ]
  },
  {
    "id": 93,
    "title": "Lambda with map and filter",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Given `data = [1, 5, 10, 15, 20]`, use **`filter` with a lambda** to keep numbers divisible by 5, then use **`map` with a lambda** to square the remaining numbers.",
    "inputFormat": "The program uses a hardcoded list.",
    "outputFormat": "Print the resulting list.",
    "solution": {
      "explanation": "This demonstrates chaining functional programming primitives: 1. **`filter`** uses a `lambda` to select elements divisible by 5. 2. **`map`** uses a second `lambda` to square the results returned by `filter`. This style is concise and often clearer than explicit loops. The results of `filter` and `map` (which are iterators) are converted to a final list using `list()`.",
      "code": "data = [1, 5, 10, 15, 20]\n\n# 1. Filter: Keep multiples of 5\nfiltered = filter(lambda x: x % 5 == 0, data)\n\n# 2. Map: Square the results\nsquared = list(map(lambda x: x*x, filtered))\n\nprint(squared)"
    },
    "testCases": [
      {
        "input": "data = [1, 5, 10, 15, 20]",
        "expected": "[25, 225, 400]\n"
      },
      {
        "input": "data = [2, 4, 6]",
        "expected": "[]\n"
      }
    ]
  },
  {
    "id": 94,
    "title": "Data Class: Point Structure",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Define a simple **`dataclass`** named `Point` with fields `x` and `y`. Create an instance and print it.",
    "inputFormat": "Internal instantiation.",
    "outputFormat": "Print the object (dataclasses have an auto-generated `__repr__`).",
    "solution": {
      "explanation": "The **`@dataclass`** decorator, introduced in Python 3.7, is used to easily create classes primarily used for storing data. It automatically generates essential boilerplate methods, including the constructor (`__init__`) based on the type-hinted fields, and a useful string representation method (`__repr__`) for easy printing and debugging.",
      "code": "from dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n\np = Point(x=10, y=20)\nprint(p)"
    },
    "testCases": [
      {
        "input": "Point(x=10, y=20)",
        "expected": "Point(x=10, y=20)\n"
      }
    ]
  },
  {
    "id": 95,
    "title": "Merge Sorted Lists",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Given two sorted lists, `l1 = [1, 3, 5]` and `l2 = [2, 4, 6]`, merge them into a single sorted list efficiently.",
    "inputFormat": "The program uses hardcoded lists.",
    "outputFormat": "Print the merged list.",
    "solution": {
      "explanation": "Since both input lists are already sorted, the most efficient and Pythonic solution is to use **`heapq.merge`**. This function merges the iterables in $O(N+M)$ time by always yielding the minimum of the currently pointed elements from both lists. It avoids storing all elements in memory at once and is much faster than concatenating the lists and then calling `sort()`.",
      "code": "from heapq import merge\n\nl1 = [1, 3, 5]\nl2 = [2, 4, 6]\n\nmerged_list = list(merge(l1, l2))\nprint(merged_list)"
    },
    "testCases": [
      {
        "input": "l1 = [1, 3, 5], l2 = [2, 4, 6]",
        "expected": "[1, 2, 3, 4, 5, 6]\n"
      },
      {
        "input": "l1 = [1, 10], l2 = [5, 15]",
        "expected": "[1, 5, 10, 15]\n"
      }
    ]
  },
  {
    "id": 96,
    "title": "Closures/Factory Function",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a **factory function** `power_factory(exponent)` that returns a **closure function**. The closure function should take a number and raise it to the power of `exponent` (e.g., cube or square).",
    "inputFormat": "Internal creation and calling of a `cube` function.",
    "outputFormat": "Print the result of $3^3$.",
    "solution": {
      "explanation": "A **Closure** is an inner function (`power_function`) that remembers and retains access to variables from its enclosing scope (`exponent`), even after the outer function (`power_factory`) has finished executing. The outer function acts as a **Factory**, generating and returning specialized functions that are pre-configured with a specific state (the exponent).",
      "code": "def power_factory(exponent):\n    def power_function(base):\n        # 'exponent' is retained from the outer scope\n        return base ** exponent\n    return power_function\n\n# Create a function that cubes a number\ncube = power_factory(3)\n\nprint(f\"Result: {cube(3)}\")"
    },
    "testCases": [
      {
        "input": "power_factory(3)(3)",
        "expected": "Result: 27\n"
      },
      {
        "input": "power_factory(2)(5)",
        "expected": "Result: 25\n"
      }
    ]
  },
  {
    "id": 97,
    "title": "OOP: Multiple Inheritance",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Define three classes: `Flyer`, `Swimmer`, and `Duck` (inherits from both). `Flyer` has `fly()` and `Swimmer` has `swim()`. Implement `Duck` with a `quack()` method and call all three methods on a `Duck` object.",
    "inputFormat": "Internal instantiation.",
    "outputFormat": "Print the output of the three methods.",
    "solution": {
      "explanation": "Python supports **Multiple Inheritance**, allowing a child class (`Duck`) to inherit from two or more parent classes (`Flyer`, `Swimmer`). The `Duck` object successfully receives and can call methods from all its ancestors, consolidating the functionalities (`fly()`, `swim()`) into a single object instance.",
      "code": "class Flyer:\n    def fly(self): print(\"I can fly!\")\n\nclass Swimmer:\n    def swim(self): print(\"I can swim!\")\n\nclass Duck(Flyer, Swimmer):\n    def quack(self): print(\"Quack!\")\n\ndaffy = Duck()\ndaffy.fly()\ndaffy.swim()\ndaffy.quack()"
    },
    "testCases": [
      {
        "input": "Duck object",
        "expected": "I can fly!\nI can swim!\nQuack!\n"
      }
    ]
  },
  {
    "id": 98,
    "title": "Class vs Instance Attributes",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate the difference between Class attributes and Instance attributes by defining a class `Robot` where `population` is a shared **Class attribute** and `name` is a unique **Instance attribute**.",
    "inputFormat": "Internal creation of two robots.",
    "outputFormat": "Print `Robot.population` and the names.",
    "solution": {
      "explanation": "This demonstrates the difference between class and instance attributes. **`Robot.population`** is a **Class Attribute**, shared among all instances. It's updated directly on the class (`Robot.population += 1`) within the constructor to maintain a count of all objects. **`self.name`** is an **Instance Attribute**, unique to each object and accessed via `self`.",
      "code": "class Robot:\n    population = 0\n    \n    def __init__(self, name):\n        self.name = name\n        Robot.population += 1\n        \nrobot1 = Robot('R2')\nrobot2 = Robot('C3')\n\nprint(f\"Total Robots: {Robot.population}\")\nprint(f\"Names: {robot1.name}, {robot2.name}\")"
    },
    "testCases": [
      {
        "input": "Robot('R2'), Robot('C3')",
        "expected": "Total Robots: 2\nNames: R2, C3\n"
      }
    ]
  },
  {
    "id": 99,
    "title": "Generator for infinite Fibonacci sequence",
    "language": "Python",
    "difficulty": "Hard",
    "problemStatement": "Write a Python **generator function** `infinite_fibonacci()` that yields the numbers in the Fibonacci sequence indefinitely. Use this generator along with the built-in **`itertools.islice`** to efficiently retrieve and print only the first 10 numbers of the sequence.",
    "inputFormat": "Internal commands using the generator and `itertools.islice`.",
    "outputFormat": "A single line printing the first 10 Fibonacci numbers, separated by spaces.",
    "solution": {
      "explanation": "A **Generator function** uses the **`yield`** keyword to create an iterable that produces values one at a time, making it ideal for infinite sequences like Fibonacci without consuming large amounts of memory. The **`itertools.islice`** function is a standard utility that safely takes a finite slice (the first 10 numbers) from the infinite generator stream without needing complex loop termination logic.",
      "code": "from itertools import islice\n\ndef infinite_fibonacci():\n    \"\"\"Generates the Fibonacci sequence indefinitely.\"\"\"\n    a, b = 0, 1\n    yield a\n    yield b\n    \n    while True:\n        # Calculate the next number\n        next_num = a + b\n        \n        # Yield the new number\n        yield next_num\n        \n        # Update state for the next iteration\n        a = b\n        b = next_num\n\n# Create the generator object\nfib_generator = infinite_fibonacci()\n\n# Use islice to take only the first 10 numbers from the infinite stream\nfirst_ten = list(islice(fib_generator, 10))\n\nprint(\"First 10 Fibonacci numbers:\", *first_ten)"
    },
    "testCases": [
      {
        "input": "(Internal generator usage)",
        "expected": "First 10 Fibonacci numbers: 0 1 1 2 3 5 8 13 21 34\n"
      }
    ]
  },
  {
    "id": 100,
    "title": "Real World: Password Generator (using `secrets`)",
    "language": "Python",
    "difficulty": "Medium",
    "problemStatement": "Write a function `generate_secure_password(length)` that creates a random, cryptographically secure password of a given length, containing a mix of letters and digits. Use the **`secrets` module**.",
    "inputFormat": "Call the function with a length of 12.",
    "outputFormat": "Print the generated password (will be random).",
    "solution": {
      "explanation": "For cryptographically secure applications like password generation, the **`secrets`** module is preferred for security over the `random` module. We define a pool of characters and use **`secrets.choice`** within a generator expression to build the password.",
      "code": "import secrets\nimport string\n\ndef generate_secure_password(length):\n    chars = string.ascii_letters + string.digits\n    # Use secrets.choice for cryptographic randomness\n    password = ''.join(secrets.choice(chars) for _ in range(length))\n    return password\n\nprint(f\"Generated Password: {generate_secure_password(12)}\")"
    },
    "testCases": [
      {
        "input": "length = 12",
        "expected": "Generated Password: 5jK8oP3tA1qZ\n"
      }
    ]
  },
  {
    "id": 101,
    "title": "Basic Hello World",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program that prints the standard greeting: \"Hello, Java World!\".",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the specified greeting.",
    "solution": {
      "explanation": "This is the fundamental structure of a Java program: the code is wrapped in a public class (`Main`). The execution begins in the static method `public static void main(String[] args)`. Output is sent to the console using the standard library method **`System.out.println()`**, which automatically includes a newline character.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java World!\");\n    }\n}"
    },
    "testCases": [
      {
        "input": "No input.",
        "expected": "Hello, Java World!\n"
      }
    ]
  },
  {
    "id": 102,
    "title": "Sum of Two Integers (Scanner)",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program that takes two integers as input from the user and calculates their sum. Use the `java.util.Scanner` class for input.",
    "inputFormat": "The user enters two integers on separate lines.",
    "outputFormat": "The program must print the sum of the two numbers.",
    "solution": {
      "explanation": "The **`java.util.Scanner`** class is Java's primary tool for parsing primitive types from input streams, here reading from `System.in`. We use `scanner.nextInt()` to read each integer value. The `Scanner` object must be closed using `scanner.close()` after use to release system resources, a good practice to prevent resource leaks.",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.print(\"Enter first integer: \");\n        int num1 = scanner.nextInt();\n        \n        System.out.print(\"Enter second integer: \");\n        int num2 = scanner.nextInt();\n        \n        int sum = num1 + num2;\n        \n        System.out.println(\"The sum is: \" + sum);\n        \n        scanner.close();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enter first integer: 15\nEnter second integer: 7",
        "expected": "The sum is: 22\n"
      },
      {
        "input": "Enter first integer: 100\nEnter second integer: 200",
        "expected": "The sum is: 300\n"
      }
    ]
  },
  {
    "id": 103,
    "title": "Area of a Rectangle",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program to calculate the area of a rectangle given its width and height as integer inputs.",
    "inputFormat": "The user enters the width and height as integers.",
    "outputFormat": "The program must print the calculated area.",
    "solution": {
      "explanation": "This is a simple arithmetic problem. The user inputs are read using the `Scanner` class, and the area is calculated using the formula $Area = Width \\times Height$. Since we are dealing with integers, there is no need for type casting or floating-point numbers.",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.print(\"Enter width: \");\n        int width = scanner.nextInt();\n        \n        System.out.print(\"Enter height: \");\n        int height = scanner.nextInt();\n        \n        int area = width * height;\n        \n        System.out.println(\"Area of the rectangle: \" + area);\n        \n        scanner.close();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enter width: 10\nEnter height: 5",
        "expected": "Area of the rectangle: 50\n"
      },
      {
        "input": "Enter width: 1\nEnter height: 100",
        "expected": "Area of the rectangle: 100\n"
      }
    ]
  },
  {
    "id": 104,
    "title": "Check Positive, Negative, or Zero",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program that reads an integer and determines if it is positive, negative, or zero.",
    "inputFormat": "The user enters a single integer.",
    "outputFormat": "The program must print the number's classification.",
    "solution": {
      "explanation": "The logic is implemented using a standard Java **`if-else if-else`** control structure. The checks are sequential: first, if the number is greater than 0 (`positive`); second, if it is less than 0 (`negative`); and finally, the remaining case must be equal to 0.",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter an integer: \");\n        int num = scanner.nextInt();\n        \n        if (num > 0) {\n            System.out.println(\"The number is Positive.\");\n        } else if (num < 0) {\n            System.out.println(\"The number is Negative.\");\n        } else {\n            System.out.println(\"The number is Zero.\");\n        }\n        \n        scanner.close();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enter an integer: -10",
        "expected": "The number is Negative.\n"
      },
      {
        "input": "Enter an integer: 5",
        "expected": "The number is Positive.\n"
      },
      {
        "input": "Enter an integer: 0",
        "expected": "The number is Zero.\n"
      }
    ]
  },
  {
    "id": 105,
    "title": "Find Largest of Three Numbers",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program that reads three integers and determines the largest value. Use a simple nested `if` structure or logical operators.",
    "inputFormat": "The user enters three integers.",
    "outputFormat": "The program must print the largest of the three numbers.",
    "solution": {
      "explanation": "While this could be solved with nested `if-else` blocks, the most idiomatic Java solution is to use the **`Math.max()`** static method. This method accepts two arguments and returns the larger one. By nesting it, `Math.max(a, Math.max(b, c))`, we find the maximum of all three numbers concisely and clearly.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        int a = 10, b = 25, c = 18;\n        int largest;\n        \n        // Find the largest using Math.max for a clean solution\n        largest = Math.max(a, Math.max(b, c));\n        \n        System.out.println(\"The largest number is: \" + largest);\n    }\n}"
    },
    "testCases": [
      {
        "input": "10\n25\n18",
        "expected": "The largest number is: 25\n"
      },
      {
        "input": "5\n5\n5",
        "expected": "The largest number is: 5\n"
      },
      {
        "input": "-1\n-5\n-10",
        "expected": "The largest number is: -1\n"
      }
    ]
  },
  {
    "id": 106,
    "title": "Sum of First N Natural Numbers (Loop)",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program that reads a positive integer N and calculates the sum of the first N natural numbers using a `for` loop.",
    "inputFormat": "The user enters a positive integer N.",
    "outputFormat": "The program must print the sum.",
    "solution": {
      "explanation": "The sum is calculated using an iterative approach with a **`for` loop**. The loop initializes a counter $i$ to 1 and iterates up to the input number $N$. In each iteration, the current value of $i$ is added to the running total, stored in the `sum` variable, until the total sum of $1 + 2 + \\dots + N$ is achieved.",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter a positive integer N: \");\n        int N = scanner.nextInt();\n        \n        int sum = 0;\n        \n        for (int i = 1; i <= N; i++) {\n            sum += i;\n        }\n        \n        System.out.println(\"The sum of the first \" + N + \" natural numbers is: \" + sum);\n        scanner.close();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enter a positive integer N: 5",
        "expected": "The sum of the first 5 natural numbers is: 15\n"
      },
      {
        "input": "Enter a positive integer N: 1",
        "expected": "The sum of the first 1 natural numbers is: 1\n"
      },
      {
        "input": "Enter a positive integer N: 10",
        "expected": "The sum of the first 10 natural numbers is: 55\n"
      }
    ]
  },
  {
    "id": 107,
    "title": "Factorial (Iterative)",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program to calculate the factorial of a non-negative integer N using a `for` loop. Use `long` to prevent overflow for larger numbers.",
    "inputFormat": "The user enters a non-negative integer N (e.g., up to 20).",
    "outputFormat": "The program must print the factorial.",
    "solution": {
      "explanation": "Factorial is the product of all positive integers less than or equal to N. We initialize `factorial` to 1 and multiply it by each integer from 1 to N inside the loop.",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter a non-negative integer N: \");\n        int N = scanner.nextInt();\n        \n        long factorial = 1;\n        \n        if (N < 0) {\n            System.out.println(\"Factorial is not defined for negative numbers.\");\n            return;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            factorial *= i;\n        }\n        \n        System.out.println(\"Factorial of \" + N + \" is: \" + factorial);\n        scanner.close();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enter a non-negative integer N: 5",
        "expected": "Factorial of 5 is: 120\n"
      },
      {
        "input": "Enter a non-negative integer N: 0",
        "expected": "Factorial of 0 is: 1\n"
      },
      {
        "input": "Enter a non-negative integer N: 1",
        "expected": "Factorial of 1 is: 1\n"
      }
    ]
  },
  {
    "id": 108,
    "title": "Print Diamond Pattern",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Write a Java program using nested loops to print a simple diamond shape composed of asterisks (*). The number of rows for the top half (excluding the center) should be fixed at 4.",
    "inputFormat": "No user input required.",
    "outputFormat": "The diamond pattern.",
    "solution": {
      "explanation": "This diamond pattern is constructed using two separate blocks of **nested `for` loops**: one for the top half (pyramid) and one for the bottom half (inverted pyramid). In both halves, the outer loop controls the row number, while the inner loops control the printing of leading **spaces** and **asterisks** (`*`). The number of stars follows the pattern $2i - 1$, where $i$ is the relative row number from the center.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        int n = 4;\n        \n        // Top half (Pyramid)\n        for (int i = 1; i <= n; i++) {\n            // Print spaces\n            for (int j = 1; j <= n - i; j++) {\n                System.out.print(\" \");\n            }\n            // Print stars\n            for (int k = 1; k <= 2 * i - 1; k++) {\n                System.out.print(\"*\");\n            }\n            System.out.println();\n        }\n        \n        // Bottom half (Inverted Pyramid)\n        for (int i = n - 1; i >= 1; i--) {\n            // Print spaces\n            for (int j = 1; j <= n - i; j++) {\n                System.out.print(\" \");\n            }\n            // Print stars\n            for (int k = 1; k <= 2 * i - 1; k++) {\n                System.out.print(\"*\");\n            }\n            System.out.println();\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "No user input required.",
        "expected": "   *\n  ***\n *****\n*******\n *****\n  ***\n   *\n"
      }
    ]
  },
  {
    "id": 109,
    "title": "OOP: Basic Class and Object Creation",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Define a simple Java class `Dog` with two fields: `name` (String) and `age` (int). Create an object of the `Dog` class, set its attributes, and print them to the console.",
    "inputFormat": "No user input required; attributes are set in the `main` method.",
    "outputFormat": "The program must print the dog's name and age.",
    "solution": {
      "explanation": "In Java, a **Class** (`Dog`) is a blueprint defining fields (`name`, `age`). An **Object** (instance) is created from this class using the **`new`** keyword (`Dog myDog = new Dog();`). The attributes of the object are accessed and set in the `main` method using the **dot operator** (`.`), demonstrating fundamental Object-Oriented Programming (OOP) concepts.",
      "code": "class Dog {\n    String name;\n    int age;\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an object (instance) of the Dog class\n        Dog myDog = new Dog();\n        \n        // Set attributes\n        myDog.name = \"Buddy\";\n        myDog.age = 5;\n        \n        // Print attributes\n        System.out.println(\"Dog's Name: \" + myDog.name + \", Age: \" + myDog.age);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Dog attributes: Buddy, 5",
        "expected": "Dog's Name: Buddy, Age: 5\n"
      }
    ]
  },
  {
    "id": 110,
    "title": "OOP: Constructor and Method",
    "language": "Java",
    "difficulty": "Easy",
    "problemStatement": "Enhance the `Dog` class from the previous problem by adding a **constructor** to initialize `name` and `age` upon creation, and a method `bark()` that prints a sound.",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the dog's attributes and the output of the `bark()` method.",
    "solution": {
      "explanation": "The **Constructor** is a special method with the same name as the class (`Dog(String name, int age)`). It is automatically executed when an object is instantiated and is responsible for initializing the instance variables. The keyword **`this`** is used inside the constructor to distinguish the class's instance variables (`this.name`) from the local parameter names (`name`). The `bark()` method is a simple instance method that prints object-specific behavior.",
      "code": "class Dog {\n    String name;\n    int age;\n\n    // Constructor\n    public Dog(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Method\n    public void bark() {\n        System.out.println(name + \" says Woof!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create object using the constructor\n        Dog myDog = new Dog(\"Buddy\", 5);\n        \n        System.out.println(\"Dog created: \" + myDog.name + \" (\" + myDog.age + \" years old)\");\n        myDog.bark();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Dog attributes: Buddy, 5",
        "expected": "Dog created: Buddy (5 years old)\nBuddy says Woof!\n"
      }
    ]
  },
  {
    "id": 111,
    "title": "String Reversal (Iterative)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java function `reverseString(str)` that takes a string and reverses it using an iterative method (a `for` loop), without using built-in helper classes like `StringBuilder`'s `reverse()` method.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print the reversed string.",
    "solution": {
      "explanation": "Since Java `String` objects are **immutable**, reversal requires converting the string to a mutable array, like a **`char[]`**. The reversal is performed in-place using a **`while` loop** with two pointers, `left` and `right`. In each iteration, the characters at the two pointers are swapped, and the pointers move inward until they cross. The final `char[]` is converted back to a `String`.",
      "code": "public class Main {\n    public static String reverseString(String str) {\n        // Convert the string to a character array\n        char[] charArray = str.toCharArray();\n        int left = 0;\n        int right = charArray.length - 1;\n        \n        // Swap characters from the ends inwards\n        while (left < right) {\n            char temp = charArray[left];\n            charArray[left] = charArray[right];\n            charArray[right] = temp;\n            left++;\n            right--;\n        }\n        \n        // Convert the character array back to a String\n        return new String(charArray);\n    }\n    \n    public static void main(String[] args) {\n        String original = \"Java\";\n        String reversed = reverseString(original);\n        System.out.println(reversed);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Java",
        "expected": "avaJ\n"
      },
      {
        "input": "Madam",
        "expected": "madaM\n"
      },
      {
        "input": "a",
        "expected": "a\n"
      }
    ]
  },
  {
    "id": 112,
    "title": "Check Palindrome String",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java function `isPalindrome(str)` that checks if a given string is a palindrome (reads the same forwards and backwards), ignoring case.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print whether the string is a palindrome (True/False).",
    "solution": {
      "explanation": "We convert the string to lowercase first. Then, we use a loop with two pointers, `left` and `right`, checking if the characters at these positions match. The comparison stops when `left` is no longer less than `right`.",
      "code": "public class Main {\n    public static boolean isPalindrome(String str) {\n        // 1. Convert to lowercase for case-insensitive check\n        String cleanStr = str.toLowerCase();\n        \n        int left = 0;\n        int right = cleanStr.length() - 1;\n        \n        while (left < right) {\n            if (cleanStr.charAt(left) != cleanStr.charAt(right)) {\n                return false; // Mismatch found\n            }\n            left++;\n            right--;\n        }\n        return true; // No mismatches found\n    }\n    \n    public static void main(String[] args) {\n        String test1 = \"Madam\";\n        String test2 = \"world\";\n        System.out.println(\"Is Palindrome: \" + isPalindrome(test1));\n        System.out.println(\"Is Palindrome: \" + isPalindrome(test2));\n    }\n}"
    },
    "testCases": [
      {
        "input": "Madam",
        "expected": "Is Palindrome: true\n"
      },
      {
        "input": "world",
        "expected": "Is Palindrome: false\n"
      },
      {
        "input": "Racecar",
        "expected": "Is Palindrome: true\n"
      }
    ]
  },
  {
    "id": 113,
    "title": "Count Vowels and Consonants",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program that reads a string and counts the number of vowels (A, E, I, O, U, case-insensitive) and consonants in the string.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print the count of vowels and consonants.",
    "solution": {
      "explanation": "We iterate through the string, converting the character to lowercase for easy checking. We check if the character is one of the five vowels. If not, we check if it is within the alphabetical range ('a' to 'z') to count it as a consonant.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        String str = \"Programming\";\n        int vowels = 0;\n        int consonants = 0;\n        \n        String lowerStr = str.toLowerCase();\n        \n        for (int i = 0; i < lowerStr.length(); i++) {\n            char ch = lowerStr.charAt(i);\n            \n            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n                vowels++;\n            } else if (ch >= 'a' && ch <= 'z') {\n                consonants++;\n            }\n        }\n        \n        System.out.println(\"Vowels: \" + vowels + \", Consonants: \" + consonants);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Programming",
        "expected": "Vowels: 4, Consonants: 7\n"
      },
      {
        "input": "AEIOUaeiou",
        "expected": "Vowels: 10, Consonants: 0\n"
      },
      {
        "input": "XYZ123",
        "expected": "Vowels: 0, Consonants: 3\n"
      }
    ]
  },
  {
    "id": 114,
    "title": "Array Initialization and Sum",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program that initializes an array of integers, calculates the sum of all elements, and prints the result.",
    "inputFormat": "The array is hardcoded: `int[] arr = {10, 20, 30, 40, 50};`",
    "outputFormat": "The program must print the sum of the array elements.",
    "solution": {
      "explanation": "The problem demonstrates basic Java array manipulation. An array of primitive `int` type is initialized directly. The sum is calculated efficiently using a **`for` loop** that iterates from the starting index (0) up to the length of the array. In each iteration, the element at the current index is added to the running `sum` variable.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        int[] arr = {10, 20, 30, 40, 50};\n        int sum = 0;\n        \n        // Standard for loop iteration\n        for (int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n        \n        System.out.println(\"Sum of array elements: \" + sum);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array elements: 10, 20, 30, 40, 50",
        "expected": "Sum of array elements: 150\n"
      },
      {
        "input": "Array elements: 1, 1, 1, 1, 1",
        "expected": "Sum of array elements: 5\n"
      }
    ]
  },
  {
    "id": 115,
    "title": "Find Max Element in Array",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java function that finds and returns the largest element in a given integer array.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "The program must print the maximum element.",
    "solution": {
      "explanation": "The function initializes a variable `max` to the first element of the array. It then uses a `for` loop to iterate through the rest of the array (starting from the second element). In each step, if the current element is greater than the currently stored `max`, the `max` variable is updated. This approach finds the maximum element in a single pass with $O(N)$ time complexity.",
      "code": "public class Main {\n    public static int findMax(int[] arr) {\n        if (arr.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n        \n        int max = arr[0];\n        \n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {10, 5, 20, 15};\n        int max = findMax(numbers);\n        System.out.println(\"Maximum element: \" + max);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {10, 5, 20, 15}",
        "expected": "Maximum element: 20\n"
      },
      {
        "input": "Array: {-10, -5, -20}",
        "expected": "Maximum element: -5\n"
      },
      {
        "input": "Array: {100}",
        "expected": "Maximum element: 100\n"
      }
    ]
  },
  {
    "id": 116,
    "title": "Multiplication Table",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program that reads an integer N and prints its multiplication table up to 10.",
    "inputFormat": "The user enters an integer N (e.g., 7).",
    "outputFormat": "The program must print 10 lines of the multiplication table.",
    "solution": {
      "explanation": "A **`for` loop** is used to iterate from 1 to 10. In each iteration, we calculate the product of $N$ and the current loop counter $i$. The result is printed in a formatted string using string concatenation, clearly showing the equation and the answer.",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter an integer N: \");\n        int N = scanner.nextInt();\n        \n        for (int i = 1; i <= 10; i++) {\n            int result = N * i;\n            System.out.println(N + \" x \" + i + \" = \" + result);\n        }\n        \n        scanner.close();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enter an integer N: 7",
        "expected": "7 x 1 = 7\n7 x 2 = 14\n7 x 3 = 21\n7 x 4 = 28\n7 x 5 = 35\n7 x 6 = 42\n7 x 7 = 49\n7 x 8 = 56\n7 x 9 = 63\n7 x 10 = 70\n"
      }
    ]
  },
  {
    "id": 117,
    "title": "OOP: Method Overloading (Polymorphism)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Method Overloading** by creating a class `Calculator` with three separate `add` methods: one that accepts two integers, one that accepts two doubles, and one that accepts three integers.",
    "inputFormat": "Internal calls to all three `add` methods.",
    "outputFormat": "Print the results of the three `add` calls.",
    "solution": {
      "explanation": "**Method Overloading** is a form of Compile-Time Polymorphism in Java. It allows a class (`Calculator`) to define multiple methods with the same name (`add`), provided they have distinct **parameter signatures** (different number of parameters or different types of parameters). The compiler determines which version of `add` to execute based on the data types and count of the arguments passed during the method call.",
      "code": "class Calculator {\n    // Method 1: Two integers\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    // Method 2: Two doubles (Overloaded by data type)\n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    // Method 3: Three integers (Overloaded by number of arguments)\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        \n        System.out.println(\"Sum (int): \" + calc.add(5, 3));\n        System.out.println(\"Sum (double): \" + calc.add(5.5, 3.2));\n        System.out.println(\"Sum (3 ints): \" + calc.add(1, 2, 3));\n    }\n}"
    },
    "testCases": [
      {
        "input": "add(5, 3), add(5.5, 3.2), add(1, 2, 3)",
        "expected": "Sum (int): 8\nSum (double): 8.7\nSum (3 ints): 6\n"
      }
    ]
  },
  {
    "id": 118,
    "title": "Exception: ArithmeticException",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program that attempts a division by zero (`10 / 0`). Use a **`try-catch`** block to specifically handle the `java.lang.ArithmeticException` and print an error message instead of crashing the program.",
    "inputFormat": "No user input required; the exception is generated internally.",
    "outputFormat": "A single line printing the error message from the `catch` block.",
    "solution": {
      "explanation": "The division by zero operation (`10 / 0`) throws a **`java.lang.ArithmeticException`**. The **`try-catch`** block is used to prevent the program from crashing. The code that might throw the exception is placed in the `try` block. If the exception occurs, execution immediately jumps to the `catch (ArithmeticException e)` block, where a custom, user-friendly error message is printed.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        try {\n            int a = 10;\n            int b = 0;\n            // This line will throw an ArithmeticException\n            int result = a / b; \n            System.out.println(\"Result: \" + result);\n        } catch (ArithmeticException e) {\n            // The program execution jumps here if ArithmeticException is thrown\n            System.out.println(\"Error: Cannot divide by zero.\");\n        } finally {\n            // Optional: code that runs regardless of exception\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "Internal division by 0",
        "expected": "Error: Cannot divide by zero.\n"
      }
    ]
  },
  {
    "id": 119,
    "title": "Array to ArrayList Conversion",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to convert a given array of Strings (`String[] arr`) to an **`ArrayList<String>`**. Print the contents and class name of the resulting list.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "Print the ArrayList and its class type.",
    "solution": {
      "explanation": "The most effective way to convert a primitive array (`String[]`) to a mutable **`ArrayList`** is a two-step process: 1. Use **`Arrays.asList(arr)`** to get a fixed-size `List` view of the array. 2. Pass this list view to the **`ArrayList` constructor** (`new ArrayList<>(...)`). This creates a new, independent, and mutable `ArrayList` instance that can be freely manipulated (added to or removed from).",
      "code": "import java.util.Arrays;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] arr = {\"A\", \"B\", \"C\"};\n        \n        // Convert the array to a mutable ArrayList\n        ArrayList<String> list = new ArrayList<>(Arrays.asList(arr));\n        \n        // Print the contents\n        System.out.println(list);\n        // Print the class type\n        System.out.println(\"Class: \" + list.getClass().getName());\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {\"A\", \"B\", \"C\"}",
        "expected": "[A, B, C]\nClass: java.util.ArrayList\n"
      }
    ]
  },
  {
    "id": 120,
    "title": "ArrayList Manipulation (Add/Remove)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to demonstrate basic `ArrayList` manipulation: create an `ArrayList` of Integers, add 5 elements, remove the element at index 2, and then print the list.",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the final state of the ArrayList.",
    "solution": {
      "explanation": "The **`ArrayList`** class is a resizable array implementation of the `List` interface. The `add(element)` method appends the element to the end. The **`remove(index)`** method removes the element at the specified position. A key feature of `ArrayList` is that when an element is removed, all subsequent elements are automatically shifted to the left to maintain contiguity.",
      "code": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList<Integer> numbers = new ArrayList<>();\n        \n        // 1. Add 5 elements\n        numbers.add(10);\n        numbers.add(20);\n        numbers.add(30);\n        numbers.add(40);\n        numbers.add(50);\n        \n        // 2. Remove the element at index 2 (which is 30)\n        numbers.remove(2);\n        \n        // 3. Print the final list\n        System.out.println(\"Final list: \" + numbers);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Initial elements: 10, 20, 30, 40, 50. Remove index 2 (value 30).",
        "expected": "Final list: [10, 20, 40, 50]\n"
      }
    ]
  },
  {
    "id": 121,
    "title": "HashMap Basic Operations",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to demonstrate basic `HashMap` operations: create a `HashMap` mapping String keys (names) to Integer values (scores), add three entries, retrieve the value for one key, and print the map.",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the retrieved score and the full HashMap.",
    "solution": {
      "explanation": "The **`HashMap`** class stores data in **key-value pairs** and provides $O(1)$ average time complexity for insertion (`put`) and retrieval (`get`). It does not guarantee any order for the elements. The `put(key, value)` method inserts a new mapping, or updates the value if the key already exists. The `get(key)` method returns the value associated with the specified key.",
      "code": "import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap<String, Integer> scores = new HashMap<>();\n        \n        // 1. Add entries using put()\n        scores.put(\"Alice\", 95);\n        scores.put(\"Bob\", 88);\n        scores.put(\"Charlie\", 79);\n        \n        // 2. Retrieve a value using get()\n        Integer aliceScore = scores.get(\"Alice\");\n        \n        System.out.println(\"Alice's score: \" + aliceScore);\n        \n        // 3. Print the full HashMap\n        System.out.println(\"Full Map: \" + scores);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Map contents: Alice: 95, Bob: 88, Charlie: 79",
        "expected": "Alice's score: 95\nFull Map: {Bob=88, Alice=95, Charlie=79}\n"
      }
    ]
  },
  {
    "id": 122,
    "title": "OOP: Inheritance and Super Keyword",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Inheritance** by creating a parent class `Animal` with a method `eat()`, and a child class `Cat` that extends `Animal`. The `Cat` class must override the `eat()` method and call the parent's `eat()` method using the **`super`** keyword.",
    "inputFormat": "Internal creation of a `Cat` object.",
    "outputFormat": "The program must print the output of the `Cat`'s `eat()` method, which includes the parent's output.",
    "solution": {
      "explanation": "**Inheritance** is established using the **`extends`** keyword. The `Cat` class inherits public and protected members from `Animal`. **Method Overriding** occurs when `Cat` provides its own implementation of the `eat()` method. The keyword **`super.eat()`** is used inside the derived class's method to explicitly call and execute the implementation of the parent (`Animal`) class's `eat()` method before running the child's specific logic.",
      "code": "class Animal {\n    public void eat() {\n        System.out.println(\"Animal is eating generic food.\");\n    }\n}\n\nclass Cat extends Animal {\n    // Method Overriding\n    @Override\n    public void eat() {\n        // Call the parent's (Animal) eat() method\n        super.eat(); \n        System.out.println(\"Cat is eating tuna.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Cat myCat = new Cat();\n        myCat.eat();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Call cat.eat()",
        "expected": "Animal is eating generic food.\nCat is eating tuna.\n"
      }
    ]
  },
  {
    "id": 123,
    "title": "OOP: Abstract Class and Method",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Abstract Classes** by defining an `abstract class Shape` with an `abstract method calculateArea()`. Create a concrete subclass `Circle` that extends `Shape` and implements the `calculateArea()` method.",
    "inputFormat": "Internal creation of a `Circle` object.",
    "outputFormat": "The program must print the calculated area of the circle.",
    "solution": {
      "explanation": "An **`abstract class`** cannot be directly instantiated. Its purpose is to define a common interface and partial implementation for its subclasses. The **`abstract method`** (`calculateArea()`) sets a contract: any **concrete** subclass (`Circle`) that extends the abstract class **must** provide a method body (implementation) for all inherited abstract methods, ensuring necessary functionality is present.",
      "code": "abstract class Shape {\n    // Abstract method must be implemented by concrete subclasses\n    public abstract double calculateArea();\n    \n    public void display() {\n        System.out.println(\"This is a shape.\");\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    // Mandatory implementation of the abstract method\n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Circle circle = new Circle(5.0);\n        System.out.println(\"Area of the Circle: \" + circle.calculateArea());\n    }\n}"
    },
    "testCases": [
      {
        "input": "Circle with radius 5",
        "expected": "Area of the Circle: 78.53981633974483\n"
      }
    ]
  },
  {
    "id": 124,
    "title": "Interface Implementation",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Interfaces** by defining an interface `Printable` with an abstract method `printDetails()`. Create a class `Document` that implements `Printable` and provides the implementation for `printDetails()`.",
    "inputFormat": "Internal creation of a `Document` object.",
    "outputFormat": "The program must print the output of the `printDetails()` method.",
    "solution": {
      "explanation": "An **`interface`** in Java is a blueprint of a class that defines a set of abstract methods (a contract). A class uses the **`implements`** keyword to adhere to this contract. By implementing `Printable`, the `Document` class is obligated to provide a concrete, public implementation for the abstract method **`printDetails()`**, fulfilling the required behavior.",
      "code": "interface Printable {\n    void printDetails();\n}\n\nclass Document implements Printable {\n    private String title;\n    \n    public Document(String title) {\n        this.title = title;\n    }\n\n    // Implementation of the interface method\n    @Override\n    public void printDetails() {\n        System.out.println(\"Document Details: \" + title);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Document report = new Document(\"Quarterly Report\");\n        report.printDetails();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Document title: Report",
        "expected": "Document Details: Quarterly Report\n"
      }
    ]
  },
  {
    "id": 125,
    "title": "OOP: Final Keyword Usage",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate the **`final`** keyword by: \n1. Defining a `final` variable for a constant PI.\n2. Defining a `final` method `greet()` in a class `User`.\n3. Defining a `final` class `Configuration`.",
    "inputFormat": "Internal calls to demonstrate access.",
    "outputFormat": "Print the final constant and the method output.",
    "solution": {
      "explanation": "The **`final`** keyword enforces immutability and restriction:\n\n* **Variable (`public static final double PI`):** Makes the variable a constant; its value cannot be changed after initialization.\n* **Method (`public final void greet()`):** Prevents the method from being overridden by any subclass.\n* **Class (`final class Config`):** Prevents any other class from inheriting or extending this class.",
      "code": "final class Config {}\n\nclass User {\n    // final method: cannot be overridden by subclasses\n    public final void greet() {\n        System.out.println(\"User greets: Hello!\");\n    }\n}\n\npublic class Main {\n    // final variable: a constant\n    public static final double PI = 3.14; \n    \n    public static void main(String[] args) {\n        System.out.println(\"Value of PI: \" + PI);\n        \n        User user = new User();\n        user.greet();\n        \n        // If you try to change PI here, it will be a compile error.\n        // PI = 3.14159; // Compile Error\n    }\n}"
    },
    "testCases": [
      {
        "input": "Final constant PI access",
        "expected": "Value of PI: 3.14\nUser greets: Hello!\n"
      }
    ]
  },
  {
    "id": 126,
    "title": "Abstract Factory Pattern (Conceptual)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the structure of the **Abstract Factory Pattern** by defining two product interfaces (`Button`, `Checkbox`) and two abstract factories (`GUIFactory`, `WindowsFactory`). The `WindowsFactory` must create concrete implementations of both products.",
    "inputFormat": "Internal creation of a `WindowsFactory` object.",
    "outputFormat": "The program must print the output of the Windows button and checkbox functions.",
    "solution": {
      "explanation": "The **Abstract Factory** provides an interface for creating families of related or dependent objects without specifying their concrete classes. It allows a client to use an abstract factory (e.g., `GUIFactory`) and receive objects (e.g., `WindowsButton`) without knowing the specific implementation class.",
      "code": "interface Button {\n    void render();\n}\ninterface Checkbox {\n    void render();\n}\n\n// Concrete Products for Windows\nclass WindowsButton implements Button {\n    @Override public void render() {\n        System.out.println(\"Rendering Windows Button.\");\n    }\n}\nclass WindowsCheckbox implements Checkbox {\n    @Override public void render() {\n        System.out.println(\"Rendering Windows Checkbox.\");\n    }\n}\n\n// Abstract Factory\ninterface GUIFactory {\n    Button createButton();\n    Checkbox createCheckbox();\n}\n\n// Concrete Factory\nclass WindowsFactory implements GUIFactory {\n    @Override public Button createButton() {\n        return new WindowsButton();\n    }\n    @Override public Checkbox createCheckbox() {\n        return new WindowsCheckbox();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Client code uses the abstract factory interface\n        GUIFactory factory = new WindowsFactory();\n        Button button = factory.createButton();\n        Checkbox checkbox = factory.createCheckbox();\n        \n        button.render();\n        checkbox.render();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Windows Factory",
        "expected": "Rendering Windows Button.\nRendering Windows Checkbox.\n"
      }
    ]
  },
  {
    "id": 127,
    "title": "Factory Method Pattern (Conceptual)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the structure of the **Factory Method Pattern** by defining a creator class `VehicleFactory` with an abstract `createVehicle()` method. Create a subclass `CarFactory` that implements `createVehicle()` to produce a `Car` object.",
    "inputFormat": "Internal creation of a `CarFactory`.",
    "outputFormat": "The program must print the output of the car's method.",
    "solution": {
      "explanation": "The **Factory Method** delegates object creation to subclasses. The parent class (`VehicleFactory`) defines the *framework* for object creation, but the concrete subclass (`CarFactory`) decides *which* product to create, allowing the system to be decoupled from specific product classes.",
      "code": "interface Vehicle {\n    void drive();\n}\n\nclass Car implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Created Car: Vroom Vroom!\");\n    }\n}\n\nabstract class VehicleFactory {\n    // The Factory Method (abstract)\n    public abstract Vehicle createVehicle();\n    \n    // Creator logic uses the factory method\n    public void startProduction() {\n        Vehicle vehicle = createVehicle();\n        vehicle.drive();\n    }\n}\n\nclass CarFactory extends VehicleFactory {\n    // Concrete Factory implements the factory method\n    @Override\n    public Vehicle createVehicle() {\n        return new Car();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        VehicleFactory factory = new CarFactory();\n        factory.startProduction();\n    }\n}"
    },
    "testCases": [
      {
        "input": "Car Factory",
        "expected": "Created Car: Vroom Vroom!\n"
      }
    ]
  },
  {
    "id": 128,
    "title": "Singleton Pattern (Thread-Safe Lazy)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Implement the **Singleton Pattern** in Java. The `Logger` class should only allow a single instance to be created. Use a **private constructor** and a **static method** (`getInstance`) with **lazy instantiation** and **thread-safety** (using `synchronized` or Double-Checked Locking for efficiency).",
    "inputFormat": "Internal calls to `Logger.getInstance()` twice.",
    "outputFormat": "The program must confirm that both calls return the same object (i.e., same hash code/reference).",
    "solution": {
      "explanation": "The **Singleton pattern** ensures only one instance of a class exists. **Lazy instantiation** means the object is created only when requested (inside `getInstance`). **Thread-safety** is achieved by synchronizing the `getInstance` method, preventing multiple threads from creating separate instances concurrently. The private constructor prevents direct external instantiation.",
      "code": "class Logger {\n    // 1. Private static instance variable\n    private static Logger instance;\n    \n    // 2. Private constructor prevents external instantiation\n    private Logger() {\n        System.out.println(\"Instance created.\");\n    }\n    \n    // 3. Public static method provides global access point\n    public static synchronized Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n    \n    // Example method\n    public void log(String message) {\n        System.out.println(\"LOG: \" + message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Logger logger1 = Logger.getInstance();\n        Logger logger2 = Logger.getInstance();\n        \n        // Check if both references point to the same object\n        boolean same = (logger1 == logger2);\n        \n        System.out.println(\"Instances are the same: \" + same);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Logger Instance Calls",
        "expected": "Instance created.\nInstances are the same: true\n"
      }
    ]
  },
  {
    "id": 129,
    "title": "String to Integer Conversion with Exception",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a Java program that attempts to convert a non-numeric string (`\"abc\"`) to an integer. Use a **`try-catch`** block to specifically handle the `NumberFormatException` that results from this operation and print an error message.",
    "inputFormat": "The non-numeric string is hardcoded.",
    "outputFormat": "A single line printing the error message from the `catch` block.",
    "solution": {
      "explanation": "The `Integer.parseInt(str)` method throws a **`NumberFormatException`** if the string cannot be parsed as a valid integer. This is a common **runtime exception** that must be handled. The `try-catch` block catches this specific exception, allowing the program to report the error and continue execution gracefully instead of terminating.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        String str = \"abc\";\n        \n        try {\n            // This will throw NumberFormatException\n            int num = Integer.parseInt(str); \n            System.out.println(\"Converted number: \" + num);\n        } catch (NumberFormatException e) {\n            // Handle the specific exception thrown by parseInt()\n            System.out.println(\"Error: Invalid number format for conversion.\");\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "String: \"abc\"",
        "expected": "Error: Invalid number format for conversion.\n"
      }
    ]
  },
  {
    "id": 130,
    "title": "Custom Checked Exception",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a Java program that defines and throws a **Custom Checked Exception** named `InsufficientFundsException`. Create a method `withdraw(amount)` in a `BankAccount` class that throws this exception if the balance is less than the amount.",
    "inputFormat": "Internal call to `withdraw(200)` with initial balance 100.",
    "outputFormat": "The program must print the custom exception message.",
    "solution": {
      "explanation": "A **Custom Checked Exception** extends `java.lang.Exception`. Checked exceptions *must* be declared in the method signature (`throws InsufficientFundsException`) and must be handled (`try-catch`) by the calling method. This forces the developer to acknowledge and handle potential critical failures.",
      "code": "// 1. Define the Custom Checked Exception\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\nclass BankAccount {\n    private double balance = 100.0;\n    \n    // 2. Declare the exception in the method signature\n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (balance < amount) {\n            // 3. Throw the custom exception\n            throw new InsufficientFundsException(\n                \"Cannot withdraw \" + amount + \". Current balance is \" + balance + \".\"\n            );\n        }\n        balance -= amount;\n        System.out.println(\"Withdrawal successful. New balance: \" + balance);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount();\n        \n        try {\n            // 4. Calling method must handle the checked exception\n            account.withdraw(200.0);\n        } catch (InsufficientFundsException e) {\n            System.out.println(\"Caught Exception: \" + e.getMessage());\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "Withdrawal of 200 from 100",
        "expected": "Caught Exception: Cannot withdraw 200.0. Current balance is 100.0.\n"
      }
    ]
  },
  {
    "id": 131,
    "title": "Array: Find Second Largest",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java function to find the second largest element in an integer array without sorting the entire array.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "The program must print the second largest element.",
    "solution": {
      "explanation": "This efficient $O(N)$ solution finds the second largest element in a single pass without sorting the entire array. It maintains two variables: `max` and `secondMax`, both initialized to `Integer.MIN_VALUE`. If a number is greater than `max`, the old `max` becomes `secondMax`. If a number is less than `max` but greater than `secondMax`, it becomes the new `secondMax`. The condition `num != max` ensures duplicates of the largest element are handled correctly.",
      "code": "public class Main {\n    public static int findSecondLargest(int[] arr) {\n        int max = Integer.MIN_VALUE;\n        int secondMax = Integer.MIN_VALUE;\n        \n        for (int num : arr) {\n            if (num > max) {\n                secondMax = max; // Old max becomes second max\n                max = num;       // New max is found\n            } else if (num > secondMax && num != max) {\n                secondMax = num; // Found a new second max\n            }\n        }\n        return secondMax;\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {10, 5, 20, 8, 15};\n        int result = findSecondLargest(numbers);\n        System.out.println(\"Second largest element: \" + result);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {10, 5, 20, 8, 15}",
        "expected": "Second largest element: 15\n"
      },
      {
        "input": "Array: {5, 5, 5, 5}",
        "expected": "Second largest element: -2147483648\n"
      },
      {
        "input": "Array: {100, 10, 50, 100}",
        "expected": "Second largest element: 50\n"
      }
    ]
  },
  {
    "id": 132,
    "title": "Linear Search in Array",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to perform a **Linear Search** on a predefined integer array for a target value. The function should return the index of the first occurrence of the target, or -1 if not found.",
    "inputFormat": "The array and target are hardcoded.",
    "outputFormat": "The program must print the index or -1.",
    "solution": {
      "explanation": "**Linear Search** is the simplest search algorithm, checking every element sequentially. It iterates through the array from the first index to the last. The comparison `arr[i] == target` checks for a match. If found, the current index $i$ is immediately returned. If the loop completes without a match, the function returns -1.",
      "code": "public class Main {\n    public static int linearSearch(int[] arr, int target) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == target) {\n                return i; // Return the index immediately upon finding the target\n            }\n        }\n        return -1; // Return -1 if the loop completes without finding the target\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {10, 20, 30, 40};\n        int target = 30;\n        int index = linearSearch(numbers, target);\n        \n        if (index != -1) {\n            System.out.println(\"Element \" + target + \" found at index \" + index);\n        } else {\n            System.out.println(\"Element not found.\");\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {10, 20, 30, 40}, Target: 30",
        "expected": "Element 30 found at index 2\n"
      },
      {
        "input": "Array: {1, 5, 10}, Target: 20",
        "expected": "Element not found.\n"
      },
      {
        "input": "Array: {10, 10, 20}, Target: 10",
        "expected": "Element 10 found at index 0\n"
      }
    ]
  },
  {
    "id": 133,
    "title": "Reverse an Array (In-place)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program that reverses the elements of an integer array **in-place** (without creating a new array).",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "The program must print the array after the in-place reversal.",
    "solution": {
      "explanation": "The most efficient way to reverse an array **in-place** is using the **Two-Pointer** technique. Pointers `start` (index 0) and `end` (last index) are initialized. A `while` loop continues as long as `start < end`. In each iteration, the elements at `start` and `end` are swapped using a temporary variable, and then the pointers move towards the center until they meet or cross. This ensures $O(N)$ time complexity.",
      "code": "import java.util.Arrays;\n\npublic class Main {\n    public static void reverseArray(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        \n        while (start < end) {\n            // Swap elements\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            \n            // Move pointers\n            start++;\n            end--;\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5};\n        reverseArray(numbers);\n        // Arrays.toString() is the standard way to print array contents\n        System.out.println(Arrays.toString(numbers));\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {1, 2, 3, 4, 5}",
        "expected": "[5, 4, 3, 2, 1]\n"
      },
      {
        "input": "Array: {10, 20, 30, 40}",
        "expected": "[40, 30, 20, 10]\n"
      },
      {
        "input": "Array: {100}",
        "expected": "[100]\n"
      }
    ]
  },
  {
    "id": 134,
    "title": "Bubble Sort Implementation",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to sort an array of integers using the **Bubble Sort** algorithm.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "The program must print the array after sorting.",
    "solution": {
      "explanation": "**Bubble Sort** is an $O(N^2)$ algorithm using **nested loops**. The outer loop manages the number of passes ($N-1$). The inner loop performs the comparisons and swaps of adjacent elements. In each pass, the largest unsorted element 'bubbles up' to its correct position. The inner loop's upper bound shrinks by $i$ in each pass because the last $i$ elements are already in place.",
      "code": "import java.util.Arrays;\n\npublic class Main {\n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        int temp;\n        \n        for (int i = 0; i < n - 1; i++) { // Outer loop for passes\n            for (int j = 0; j < n - i - 1; j++) { // Inner loop for comparisons\n                if (arr[j] > arr[j + 1]) {\n                    // Swap arr[j] and arr[j+1]\n                    temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {64, 34, 25, 12, 22, 11, 90};\n        bubbleSort(numbers);\n        System.out.println(Arrays.toString(numbers));\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {64, 34, 25, 12, 22, 11, 90}",
        "expected": "[11, 12, 22, 25, 34, 64, 90]\n"
      },
      {
        "input": "Array: {5, 4, 3, 2, 1}",
        "expected": "[1, 2, 3, 4, 5]\n"
      }
    ]
  },
  {
    "id": 135,
    "title": "Insertion Sort Implementation",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to sort an array of integers using the **Insertion Sort** algorithm.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "The program must print the array after sorting.",
    "solution": {
      "explanation": "**Insertion Sort** builds the final sorted array one item at a time. It iterates from the second element ($i=1$). The current element (`key`) is compared with elements in the already sorted subarray to its left. If a larger element is found, it is shifted one position to the right (`arr[j + 1] = arr[j]`). This process creates a space where the `key` is finally inserted (`arr[j + 1] = key`).",
      "code": "import java.util.Arrays;\n\npublic class Main {\n    public static void insertionSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 1; i < n; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            \n            // Move elements of arr[0..i-1], that are greater than key, \n            // to one position ahead of their current position\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key; // Insert the key in its correct place\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {12, 11, 13, 5, 6};\n        insertionSort(numbers);\n        System.out.println(Arrays.toString(numbers));\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {12, 11, 13, 5, 6}",
        "expected": "[5, 6, 11, 12, 13]\n"
      },
      {
        "input": "Array: {1, 5, 3, 2}",
        "expected": "[1, 2, 3, 5]\n"
      }
    ]
  },
  {
    "id": 136,
    "title": "Merge two sorted arrays",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to merge two already sorted integer arrays (`A` and `B`) into a single, new sorted array (`C`). The merging must be done in $O(M+N)$ time (linear), without using a general sorting algorithm on the final array.",
    "inputFormat": "The arrays are hardcoded.",
    "outputFormat": "The program must print the final merged array.",
    "solution": {
      "explanation": "This linear time $O(M+N)$ merge operation uses three pointers ($i, j, k$) for the arrays A, B, and C respectively. The core logic uses a `while` loop to compare $A[i]$ and $B[j]$, placing the smaller element into $C[k]$ and advancing the corresponding pointers. Two subsequent `while` loops handle copying any remaining elements from the array that was not fully exhausted.",
      "code": "import java.util.Arrays;\n\npublic class Main {\n    public static int[] mergeSortedArrays(int[] A, int[] B) {\n        int m = A.length;\n        int n = B.length;\n        int[] C = new int[m + n];\n        \n        int i = 0, j = 0, k = 0; // Pointers for A, B, and C\n        \n        // Compare and merge elements\n        while (i < m && j < n) {\n            if (A[i] < B[j]) {\n                C[k++] = A[i++];\n            } else {\n                C[k++] = B[j++];\n            }\n        }\n        \n        // Copy remaining elements from A\n        while (i < m) {\n            C[k++] = A[i++];\n        }\n        \n        // Copy remaining elements from B\n        while (j < n) {\n            C[k++] = B[j++];\n        }\n        \n        return C;\n    }\n    \n    public static void main(String[] args) {\n        int[] A = {1, 3, 5};\n        int[] B = {2, 4, 6};\n        int[] merged = mergeSortedArrays(A, B);\n        System.out.println(Arrays.toString(merged));\n    }\n}"
    },
    "testCases": [
      {
        "input": "A={1, 3, 5}, B={2, 4, 6}",
        "expected": "[1, 2, 3, 4, 5, 6]\n"
      },
      {
        "input": "A={10, 20}, B={5, 15, 25}",
        "expected": "[5, 10, 15, 20, 25]\n"
      }
    ]
  },
  {
    "id": 137,
    "title": "Count Word Frequency (HashMap)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to count the frequency of each word in a given sentence. Store the results in a `HashMap<String, Integer>` and print the map. Ignore punctuation and convert all words to lowercase.",
    "inputFormat": "The sentence is hardcoded.",
    "outputFormat": "The program must print the final word frequency map.",
    "solution": {
      "explanation": "The text is first cleaned (lowercase, punctuation removal) and split into an array of words. A **`HashMap<String, Integer>`** stores the word counts. The **`getOrDefault(key, defaultValue)`** method is used for efficient counting: it retrieves the current count of a word or returns 0 if the word is new, avoiding a separate `containsKey` check before incrementing the count.",
      "code": "import java.util.HashMap;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        String sentence = \"The quick brown fox and the quick dog.\";\n        \n        // 1. Clean and split the sentence into words\n        String cleanSentence = sentence.toLowerCase().replaceAll(\"[^a-z\\s]\", \"\");\n        String[] words = cleanSentence.split(\"\\s+\");\n        \n        HashMap<String, Integer> wordCounts = new HashMap<>();\n        \n        // 2. Iterate and count frequency\n        for (String word : words) {\n            if (!word.isEmpty()) {\n                // If word exists, increment count; otherwise, set count to 1\n                wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\n            }\n        }\n        \n        System.out.println(wordCounts);\n    }\n}"
    },
    "testCases": [
      {
        "input": "The quick brown fox and the quick dog.",
        "expected": "{quick=2, dog=1, fox=1, brown=1, the=2, and=1}\n"
      },
      {
        "input": "A B C A B C",
        "expected": "{a=2, b=2, c=2}\n"
      }
    ]
  },
  {
    "id": 138,
    "title": "String Anagram Check (HashMap)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java function `areAnagrams(s1, s2)` that checks if two strings are anagrams of each other. Use a `HashMap` to store character frequencies for efficient comparison.",
    "inputFormat": "The strings are hardcoded.",
    "outputFormat": "The program must print whether the strings are anagrams (True/False).",
    "solution": {
      "explanation": "Anagrams have identical character frequency counts. This solution uses a **`HashMap`** for counting: 1. It builds the frequency map for the first string. 2. It iterates through the second string, decrementing the count for each character in the map. If the count of any character drops below zero, or a character is missing, the strings are not anagrams. An initial length check ensures early exit for unequal-length strings.",
      "code": "import java.util.HashMap;\n\npublic class Main {\n    public static boolean areAnagrams(String s1, String s2) {\n        // Check length first\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        \n        HashMap<Character, Integer> counts = new HashMap<>();\n        \n        // 1. Build frequency map for s1\n        for (char c : s1.toLowerCase().toCharArray()) {\n            counts.put(c, counts.getOrDefault(c, 0) + 1);\n        }\n        \n        // 2. Decrement frequency for s2\n        for (char c : s2.toLowerCase().toCharArray()) {\n            if (!counts.containsKey(c) || counts.get(c) == 0) {\n                return false; // Character not present or count already exhausted\n            }\n            counts.put(c, counts.get(c) - 1);\n        }\n        \n        // Final check: Since lengths are equal, we only need to verify no negative counts occurred.\n        // All counts must be 0, which is implicitly checked in the loop above.\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        String s1 = \"listen\";\n        String s2 = \"silent\";\n        System.out.println(\"Are Anagrams: \" + areAnagrams(s1, s2));\n    }\n}"
    },
    "testCases": [
      {
        "input": "listen, silent",
        "expected": "Are Anagrams: true\n"
      },
      {
        "input": "Debit Card, Bad Credit",
        "expected": "Are Anagrams: true\n"
      },
      {
        "input": "hello, world",
        "expected": "Are Anagrams: false\n"
      }
    ]
  },
  {
    "id": 139,
    "title": "Matrix Multiplication (2x2)",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to perform matrix multiplication on two hardcoded $2 \\times 2$ matrices, $A$ and $B$. Print the resulting matrix $C$.",
    "inputFormat": "The matrices are hardcoded.",
    "outputFormat": "The program must print the resulting $2 \\times 2$ matrix $C$.",
    "solution": {
      "explanation": "Matrix multiplication requires **three nested loops**. For the resulting matrix $C$, the element $C[i][j]$ is calculated by taking the dot product of the $i$-th row of matrix $A$ and the $j$-th column of matrix $B$. The innermost loop performs this summation of products: $C[i][j] = \\sum_{k=0}^{K-1} A[i][k] \\times B[k][j]$, where $K$ is the number of columns in $A$ and rows in $B$.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        int[][] A = {{1, 2}, {3, 4}};\n        int[][] B = {{5, 6}, {7, 8}};\n        int[][] C = new int[2][2];\n        \n        int rows = 2, cols = 2, k_max = 2;\n        \n        for (int i = 0; i < rows; i++) { // Row of A\n            for (int j = 0; j < cols; j++) { // Column of B\n                C[i][j] = 0;\n                for (int k = 0; k < k_max; k++) { // Inner product calculation\n                    C[i][j] += A[i][k] * B[k][j];\n                }\n                System.out.print(C[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "A={{1, 2}, {3, 4}}, B={{5, 6}, {7, 8}}",
        "expected": "19 22 \n43 50 \n"
      },
      {
        "input": "A={{1, 0}, {0, 1}}, B={{5, 6}, {7, 8}}",
        "expected": "5 6 \n7 8 \n"
      }
    ]
  },
  {
    "id": 140,
    "title": "Matrix Transpose",
    "language": "Java",
    "difficulty": "Medium",
    "problemStatement": "Write a Java program to calculate the transpose of a $3 \\times 2$ matrix $A$ and store it in a $2 \\times 3$ matrix $B$. Print the transposed matrix $B$.",
    "inputFormat": "The matrix is hardcoded.",
    "outputFormat": "The program must print the transposed matrix.",
    "solution": {
      "explanation": "Matrix transposition is a non-square matrix simply involves copying the rows of the original matrix $A$ into the columns of the new matrix $B$. This is achieved by swapping the indices: $B[j][i] = A[i][j]$. Since the dimensions are inverted, the new matrix $B$ must be declared with dimensions $N \\times M$ if $A$ was $M \\times N$.",
      "code": "public class Main {\n    public static void main(String[] args) {\n        int[][] A = {{1, 2}, {3, 4}, {5, 6}}; // 3x2 matrix\n        int rowsA = 3;\n        int colsA = 2;\n        int[][] B = new int[colsA][rowsA]; // 2x3 matrix for transpose\n        \n        for (int i = 0; i < rowsA; i++) {\n            for (int j = 0; j < colsA; j++) {\n                B[j][i] = A[i][j]; // Transpose operation\n            }\n        }\n        \n        // Print transposed matrix B\n        for (int i = 0; i < colsA; i++) {\n            for (int j = 0; j < rowsA; j++) {\n                System.out.print(B[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}"
    },
    "testCases": [
      {
        "input": "A={{1, 2}, {3, 4}, {5, 6}}",
        "expected": "1 3 5 \n2 4 6 \n"
      },
      {
        "input": "A={{10}, {20}, {30}}",
        "expected": "10 20 30 \n"
      }
    ]
  },
  {
    "id": 141,
    "title": "Binary Search (Iterative)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write an iterative Java function `binarySearch(arr, target)` that searches for a target value in a **sorted** integer array `arr`. Return the index of the target if found, or -1 otherwise.",
    "inputFormat": "The array and target are hardcoded.",
    "outputFormat": "The program must print the index or -1.",
    "solution": {
      "explanation": "Iterative **Binary Search** maintains `low`, `high`, and `mid` pointers. The `while (low <= high)` loop iteratively halves the search space. The `mid` is recalculated in each iteration. The process stops when the target is found or when `low` exceeds `high`.",
      "code": "public class Main {\n    public static int binarySearch(int[] arr, int target) {\n        int low = 0;\n        int high = arr.length - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2; // Safe way to calculate mid\n            \n            if (arr[mid] == target) {\n                return mid; // Target found\n            } else if (arr[mid] < target) {\n                low = mid + 1; // Target is in the upper half\n            } else {\n                high = mid - 1; // Target is in the lower half\n            }\n        }\n        \n        return -1; // Target not found\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {2, 5, 8, 12, 16};\n        int target = 12;\n        int index = binarySearch(numbers, target);\n        System.out.println(\"Element \" + target + \" found at index: \" + index);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {2, 5, 8, 12, 16}, Target: 12",
        "expected": "Element 12 found at index: 3\n"
      },
      {
        "input": "Array: {1, 3, 5}, Target: 4",
        "expected": "Element not found.\n"
      },
      {
        "input": "Array: {1, 3, 5}, Target: 1",
        "expected": "Element 1 found at index: 0\n"
      }
    ]
  },
  {
    "id": 142,
    "title": "Binary Search (Recursive)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a **recursive** Java function `recursiveBinarySearch(arr, low, high, target)` to perform Binary Search on a sorted array. Return the index of the target, or -1.",
    "inputFormat": "The array and target are hardcoded.",
    "outputFormat": "The program must print the index or -1.",
    "solution": {
      "explanation": "Recursive **Binary Search** achieves the same $O(\\log N)$ complexity as the iterative approach but simplifies the logic using the method call stack. The function's **base case** is `low > high`, signaling the element is not found. In the recursive step, the function calls itself, passing the new `low` and `high` indices that narrow the search space, effectively implementing the divide-and-conquer strategy.",
      "code": "public class Main {\n    public static int recursiveBinarySearch(int[] arr, int low, int high, int target) {\n        // Base Case: Search space is empty\n        if (low > high) {\n            return -1;\n        }\n        \n        int mid = low + (high - low) / 2;\n        \n        if (arr[mid] == target) {\n            return mid; // Target found\n        } else if (arr[mid] < target) {\n            // Recurse on the right half\n            return recursiveBinarySearch(arr, mid + 1, high, target);\n        } else {\n            // Recurse on the left half\n            return recursiveBinarySearch(arr, low, mid - 1, target);\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] numbers = {2, 5, 8, 12, 16};\n        int target = 8;\n        int index = recursiveBinarySearch(numbers, 0, numbers.length - 1, target);\n        System.out.println(\"Element \" + target + \" found at index: \" + index);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Array: {2, 5, 8, 12, 16}, Target: 8",
        "expected": "Element 8 found at index: 2\n"
      },
      {
        "input": "Array: {10, 20, 30}, Target: 5",
        "expected": "Element not found.\n"
      }
    ]
  },
  {
    "id": 143,
    "title": "Factorial (Recursive)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a **recursive** Java function `factorial(n)` that calculates the factorial of a non-negative integer N. Test the function with $N=5$.",
    "inputFormat": "The function is called internally with $N=5$.",
    "outputFormat": "A single line printing the factorial result.",
    "solution": {
      "explanation": "The recursive definition of the factorial function is $N! = N \\times (N-1)!$. This is directly translated into the function: it returns $N$ multiplied by the result of calling itself with $N-1$. The essential **base case** is when $N \\le 1$, at which point the function stops recursing and returns 1.",
      "code": "public class Main {\n    public static long factorial(int n) {\n        // Base Case\n        if (n <= 1) {\n            return 1;\n        }\n        // Recursive Step\n        return n * factorial(n - 1);\n    }\n    \n    public static void main(String[] args) {\n        int N = 5;\n        System.out.println(\"Factorial of \" + N + \" is: \" + factorial(N));\n    }\n}"
    },
    "testCases": [
      {
        "input": "5",
        "expected": "Factorial of 5 is: 120\n"
      },
      {
        "input": "0",
        "expected": "Factorial of 0 is: 1\n"
      }
    ]
  },
  {
    "id": 144,
    "title": "Fibonacci Sequence (Recursive)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a **recursive** Java function `fibonacci(n)` that returns the N-th Fibonacci number. Test the function for $N=7$ (result should be 13).",
    "inputFormat": "The function is called internally with $N=7$.",
    "outputFormat": "A single line printing the Fibonacci number.",
    "solution": {
      "explanation": "The Fibonacci sequence is defined by the recurrence relation $F(N) = F(N-1) + F(N-2)$. The recursive function calls itself twice in its return statement. The base cases are $F(0)=0$ and $F(1)=1$. Note that the complexity is exponential $O(2^N)$ without memoization, highlighting the inefficiency of pure recursion for this problem.",
      "code": "public class Main {\n    public static int fibonacci(int n) {\n        // Base Cases\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        \n        // Recursive Step\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n    \n    public static void main(String[] args) {\n        int N = 7;\n        System.out.println(\"Fibonacci(\" + N + \"): \" + fibonacci(N));\n    }\n}"
    },
    "testCases": [
      {
        "input": "7",
        "expected": "Fibonacci(7): 13\n"
      },
      {
        "input": "0",
        "expected": "Fibonacci(0): 0\n"
      },
      {
        "input": "1",
        "expected": "Fibonacci(1): 1\n"
      }
    ]
  },
  {
    "id": 145,
    "title": "Tower of Hanoi (Recursive)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a recursive Java function to solve the **Tower of Hanoi** puzzle for $N=3$ disks. Print the sequence of moves required.",
    "inputFormat": "The function is called internally with $N=3$.",
    "outputFormat": "Print the sequence of moves.",
    "solution": {
      "explanation": "The **Tower of Hanoi** solution is a three-part recursive strategy: 1. Move $N-1$ disks from the Source to the Auxiliary peg. 2. Move the largest disk $N$ from the Source to the Destination peg. 3. Move the $N-1$ disks from the Auxiliary to the Destination peg. The function's arguments are swapped in each recursive call to correctly manage the roles of the Source, Destination, and Auxiliary pegs.",
      "code": "public class Main {\n    public static void solveHanoi(int n, char source, char destination, char auxiliary) {\n        if (n == 1) {\n            System.out.println(\"Move disk 1 from \" + source + \" to \" + destination);\n            return;\n        }\n        \n        // Step 1: Move n-1 disks from Source to Auxiliary\n        solveHanoi(n - 1, source, auxiliary, destination);\n        \n        // Step 2: Move disk n from Source to Destination\n        System.out.println(\"Move disk \" + n + \" from \" + source + \" to \" + destination);\n        \n        // Step 3: Move n-1 disks from Auxiliary to Destination\n        solveHanoi(n - 1, auxiliary, destination, source);\n    }\n    \n    public static void main(String[] args) {\n        solveHanoi(3, 'A', 'C', 'B');\n    }\n}"
    },
    "testCases": [
      {
        "input": "3 Disks",
        "expected": "Move disk 1 from A to C\nMove disk 2 from A to B\nMove disk 1 from C to B\nMove disk 3 from A to C\nMove disk 1 from B to A\nMove disk 2 from B to C\nMove disk 1 from A to C\n"
      }
    ]
  },
  {
    "id": 146,
    "title": "Implement Stack using LinkedList",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Implement a Stack (LIFO) in Java. Use the `java.util.LinkedList` class as the underlying data structure. Implement the methods `push(int data)`, `pop()`, and `peek()`.",
    "inputFormat": "Internal sequence of stack operations.",
    "outputFormat": "Print the result of the `pop` and `peek` operations.",
    "solution": {
      "explanation": "A **Stack** (LIFO: Last-In, First-Out) is efficiently implemented in Java using **`java.util.LinkedList`**. The operations are mapped to the head of the list for $O(1)$ efficiency: **`push`** uses `addFirst()`, **`pop`** uses `removeFirst()`, and **`peek`** uses `getFirst()`. This leverages the linked nature of the list to perform fast insertions and deletions at the front.",
      "code": "import java.util.LinkedList;\n\nclass CustomStack {\n    private LinkedList<Integer> list = new LinkedList<>();\n    \n    public void push(int data) {\n        list.addFirst(data); // Add to the beginning (head)\n    }\n    \n    public int pop() {\n        if (list.isEmpty()) {\n            throw new java.util.EmptyStackException();\n        }\n        return list.removeFirst(); // Remove from the beginning\n    }\n    \n    public int peek() {\n        if (list.isEmpty()) {\n            throw new java.util.EmptyStackException();\n        }\n        return list.getFirst(); // View the top element\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        CustomStack stack = new CustomStack();\n        stack.push(10);\n        stack.push(20);\n        \n        System.out.println(\"Popped: \" + stack.pop());\n        System.out.println(\"Top element: \" + stack.peek());\n    }\n}"
    },
    "testCases": [
      {
        "input": "Push 10, Push 20, Pop, Peek",
        "expected": "Popped: 20\nTop element: 10\n"
      }
    ]
  },
  {
    "id": 147,
    "title": "Implement Queue using LinkedList",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Implement a Queue (FIFO) in Java. Use the `java.util.LinkedList` class as the underlying data structure. Implement the methods `enqueue(int data)` and `dequeue()`.",
    "inputFormat": "Internal sequence of queue operations.",
    "outputFormat": "Print the result of the `dequeue` operations.",
    "solution": {
      "explanation": "A **Queue** (FIFO: First-In, First-Out) is implemented using Java's **`LinkedList`** with operations mapped to opposite ends: **`enqueue`** (insertion at the rear) uses `addLast()`, and **`dequeue`** (removal from the front) uses `removeFirst()`. Both operations are $O(1)$, ensuring the First-In, First-Out principle is correctly maintained.",
      "code": "import java.util.LinkedList;\n\nclass CustomQueue {\n    private LinkedList<Integer> list = new LinkedList<>();\n    \n    public void enqueue(int data) {\n        list.addLast(data); // Add to the end (rear)\n    }\n    \n    public int dequeue() {\n        if (list.isEmpty()) {\n            throw new java.util.NoSuchElementException(\"Queue is empty\");\n        }\n        return list.removeFirst(); // Remove from the beginning (front)\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        CustomQueue queue = new CustomQueue();\n        queue.enqueue(10);\n        queue.enqueue(20);\n        \n        System.out.println(\"Dequeued: \" + queue.dequeue());\n        System.out.println(\"Dequeued: \" + queue.dequeue());\n    }\n}"
    },
    "testCases": [
      {
        "input": "Enqueue 10, Enqueue 20, Dequeue, Dequeue",
        "expected": "Dequeued: 10\nDequeued: 20\n"
      }
    ]
  },
  {
    "id": 148,
    "title": "Final/Const correctness",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a Java program to demonstrate the use of the `final` keyword in various contexts: a **method parameter**, a **local variable**, and a **reference to an object**.",
    "inputFormat": "Internal calls to a function with a final parameter.",
    "outputFormat": "Print the output of the demonstration.",
    "solution": {
      "explanation": "The **`final`** keyword restricts re-assignment:\n\n* **Local Variable:** `final int LOCAL_VAR` prevents the value from changing.\n* **Method Parameter:** `final int param` prevents the parameter variable from being reassigned within the function.\n* **Object Reference:** `final Person p` prevents the reference `p` from pointing to a different object (it cannot be reassigned with `p = new Person(...)`). However, the object itself (`p.name`) remains **mutable**.",
      "code": "class Person {\n    String name;\n    public Person(String name) { this.name = name; }\n}\n\npublic class Main {\n    \n    // Method with a final parameter\n    public static void process(final int param) {\n        System.out.println(\"Final parameter: \" + param);\n        // param = 11; // This would cause a compile error\n    }\n    \n    public static void main(String[] args) {\n        // 1. Final local variable\n        final int LOCAL_VAR = 20;\n        System.out.println(\"Final local variable: \" + LOCAL_VAR);\n        \n        // 2. Final reference to an object\n        final Person p = new Person(\"Alice\");\n        System.out.println(\"Final reference object name: \" + p.name);\n        \n        // p = new Person(\"Bob\"); // Compile Error (cannot reassign final reference)\n        p.name = \"Charlie\"; // Allowed (object is mutable, only reference is final)\n        \n        process(10);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Demo of final keyword",
        "expected": "Final local variable: 20\nFinal reference object name: Alice\nFinal parameter: 10\n"
      }
    ]
  },
  {
    "id": 149,
    "title": "String Permutations (Recursive)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a recursive Java function to generate and print all unique **permutations** of a given string using the swapping/backtracking technique.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "Print all permutations, each on a new line.",
    "solution": {
      "explanation": "This recursive solution uses a **backtracking** approach based on swapping characters. It fixes a character at the current index ($l$), recursively calls itself to find permutations of the remaining substring ($l+1$ to $r$), and then uses a **second swap** (backtracking step) to restore the string's original order. This restoration is crucial to ensure that the next iteration of the loop can start from a known state and explore a new branch of the permutation tree.",
      "code": "public class Main {\n    // Utility method to swap two characters in a string\n    public static String swap(String a, int i, int j) {\n        char[] charArray = a.toCharArray();\n        char temp = charArray[i];\n        charArray[i] = charArray[j];\n        charArray[j] = temp;\n        return String.valueOf(charArray);\n    }\n    \n    public static void permute(String str, int l, int r) {\n        if (l == r) {\n            System.out.println(str); // Base Case: print the complete permutation\n        } else {\n            for (int i = l; i <= r; i++) {\n                // 1. Swap the character at position l with the character at position i\n                str = swap(str, l, i);\n                \n                // 2. Recurse for the remaining substring (l+1 to r)\n                permute(str, l + 1, r);\n                \n                // 3. Backtrack: swap back to restore the original order for the next iteration\n                str = swap(str, l, i); \n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        String str = \"ABC\";\n        int n = str.length();\n        permute(str, 0, n - 1);\n    }\n}"
    },
    "testCases": [
      {
        "input": "ABC",
        "expected": "ABC\nACB\nBAC\nBCA\nCBA\nCAB\n"
      }
    ]
  },
  {
    "id": 150,
    "title": "Matrix Transpose (In-place on square matrix)",
    "language": "Java",
    "difficulty": "Hard",
    "problemStatement": "Write a Java program to perform the **Transpose of a Square Matrix** ($N \\times N$) **in-place** (without using a second matrix). Only swap the necessary elements ($A[i][j]$ with $A[j][i]$) below the main diagonal to save memory and time.",
    "inputFormat": "The $3 \\times 3$ matrix is hardcoded.",
    "outputFormat": "Print the matrix after the in-place transpose.",
    "solution": {
      "explanation": "To perform the **transpose of a square matrix in-place**, we only need to iterate over the elements in the **lower triangle** (where the row index $i$ is greater than the column index $j$). For every such element $A[i][j]$, we swap it with its symmetric counterpart $A[j][i]$. This ensures that every pair is swapped exactly once, avoiding the need for a second matrix and resulting in $O(N^2)$ time complexity.",
      "code": "public class Main {\n    public static void transposeInPlace(int[][] matrix) {\n        int N = matrix.length;\n        int temp;\n        \n        for (int i = 0; i < N; i++) {\n            // Inner loop goes from j=0 up to i-1 (only swaps elements below the main diagonal)\n            for (int j = 0; j < i; j++) {\n                // Swap matrix[i][j] with matrix[j][i]\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n    }\n    \n    public static void printMatrix(int[][] matrix) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[][] A = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; // 3x3 matrix\n        transposeInPlace(A);\n        printMatrix(A);\n    }\n}"
    },
    "testCases": [
      {
        "input": "Matrix A={{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}",
        "expected": "1 4 7 \n2 5 8 \n3 6 9 \n"
      }
    ]
  },
  {
    "id": 151,
    "title": "Basic Hello World",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ program that prints the standard greeting: \"Hello, C++ World!\".",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the specified greeting.",
    "solution": {
      "explanation": "C++ uses the standard I/O library `<iostream>`. Output is achieved using **`std::cout`** (the character output stream) and the insertion operator (`<<`). The standard practice is to include **`std::endl`** to flush the output buffer and insert a newline, or simply use `\\n`.",
      "code": "#include <iostream>\n\nint main() {\n    std::cout << \"Hello, C++ World!\" << std::endl;\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "No input.",
        "expected": "Hello, C++ World!\n"
      }
    ]
  },
  {
    "id": 152,
    "title": "Sum of Two Integers (cin/cout)",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ program that takes two integers as input from the user and calculates their sum. Use `std::cin` and `std::cout`.",
    "inputFormat": "The user enters two integers.",
    "outputFormat": "The program must print the sum of the two numbers.",
    "solution": {
      "explanation": "C++ uses **`std::cin`** (the character input stream) and the **extraction operator** (`>>`) to read user input into integer variables. The program then performs simple addition. Since the operator `>>` skips whitespace, the user can input the two numbers on the same line or separate lines.",
      "code": "#include <iostream>\n\nint main() {\n    int num1, num2;\n    \n    std::cout << \"Enter two integers: \";\n    std::cin >> num1 >> num2;\n    \n    int sum = num1 + num2;\n    \n    std::cout << \"The sum is: \" << sum << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "15 7",
        "expected": "The sum is: 22\n"
      },
      {
        "input": "100 200",
        "expected": "The sum is: 300\n"
      }
    ]
  },
  {
    "id": 153,
    "title": "Basic Class and Constructor",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Define a C++ class `Point` with two public integer fields, `x` and `y`. Implement a **constructor** to initialize these fields upon object creation. Create a `Point` object and print its coordinates.",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the coordinates.",
    "solution": {
      "explanation": "A **Constructor** is a special method used to initialize the object upon creation. In modern C++, the preferred method is to use an **Initialization List** (e.g., `: x(x_coord), y(y_coord)`) to initialize the member variables. This is more efficient for complex types than assignment within the constructor body.",
      "code": "#include <iostream>\n\nclass Point {\npublic:\n    int x;\n    int y;\n\n    // Constructor\n    Point(int x_coord, int y_coord) : x(x_coord), y(y_coord) {}\n};\n\nint main() {\n    // Create an object using the constructor\n    Point p1(10, 20);\n    \n    std::cout << \"Point coordinates: (\" << p1.x << \", \" << p1.y << \")\" << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Coordinates: (10, 20)",
        "expected": "Point coordinates: (10, 20)\n"
      }
    ]
  },
  {
    "id": 154,
    "title": "Vector Initialization and Sum",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ program that initializes a `std::vector<int>` with 5 elements. Use a `for` loop to calculate the sum of all elements and print the result.",
    "inputFormat": "The vector elements are hardcoded.",
    "outputFormat": "The program must print the sum.",
    "solution": {
      "explanation": "C++ uses the Standard Template Library (STL) container **`std::vector`** for dynamic arrays. The simplest way to iterate and sum its elements is using a **range-based `for` loop** (`for (int num : numbers)`). This automatically iterates over every element in the container, providing a clean and safe way to perform the aggregation.",
      "code": "#include <iostream>\n#include <vector>\n\nint main() {\n    // Initialize a vector using an initializer list\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    int sum = 0;\n    \n    // Use a range-based for loop (modern C++)\n    for (int num : numbers) {\n        sum += num;\n    }\n    \n    std::cout << \"Sum of elements: \" << sum << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {1, 2, 3, 4, 5}",
        "expected": "Sum of elements: 15\n"
      },
      {
        "input": "Vector: {10, 20, 30}",
        "expected": "Sum of elements: 60\n"
      }
    ]
  },
  {
    "id": 155,
    "title": "Swap using References",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ function `swap_values` that swaps the values of two integers using **references** (`&`). Print the values before and after the swap.",
    "inputFormat": "Two hardcoded integer variables.",
    "outputFormat": "Print the values before and after the swap.",
    "solution": {
      "explanation": "In C++, using **references** (`int& a`) allows the function to modify the actual variable passed to it, eliminating the need for pointers and the dereference operator (`*`). This is known as **pass-by-reference**. The `swap_values` function directly modifies the original `x` and `y` variables in the `main` function's scope.",
      "code": "#include <iostream>\n\n// Function uses references (int& a, int& b) to operate directly on the original variables\nvoid swap_values(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 10;\n    int y = 20;\n    \n    std::cout << \"Before swap: a=\" << x << \", b=\" << y << std::endl;\n    \n    swap_values(x, y);\n    \n    std::cout << \"After swap: a=\" << x << \", b=\" << y << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "a=10, b=20",
        "expected": "Before swap: a=10, b=20\nAfter swap: a=20, b=10\n"
      },
      {
        "input": "a=-5, b=100",
        "expected": "Before swap: a=-5, b=100\nAfter swap: a=100, b=-5\n"
      }
    ]
  },
  {
    "id": 156,
    "title": "Factorial (Recursive)",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ function to calculate the factorial of a non-negative integer N using **recursion**.",
    "inputFormat": "A single hardcoded integer N (e.g., 5).",
    "outputFormat": "The program must print the factorial.",
    "solution": {
      "explanation": "The recursive factorial function calculates $N!$ as $N \\times (N-1)!$. The function calls itself with $N-1$ until it reaches the **base case** ($N \\le 1$), where it returns 1. To handle larger factorial results, the return type is set to **`long long`**.",
      "code": "#include <iostream>\n\nlong long factorial(int n) {\n    // Base Case\n    if (n <= 1) {\n        return 1;\n    }\n    // Recursive Step\n    return (long long)n * factorial(n - 1);\n}\n\nint main() {\n    int N = 5;\n    std::cout << \"Factorial of \" << N << \" is: \" << factorial(N) << std::endl;\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "N=5",
        "expected": "Factorial of 5 is: 120\n"
      },
      {
        "input": "N=0",
        "expected": "Factorial of 0 is: 1\n"
      },
      {
        "input": "N=10",
        "expected": "Factorial of 10 is: 3628800\n"
      }
    ]
  },
  {
    "id": 157,
    "title": "String Palindrome Check",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ program that checks if a string (`std::string`) is a palindrome (reads the same forwards and backwards). Ignore case.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print whether the string is a palindrome (True/False).",
    "solution": {
      "explanation": "To check a case-insensitive palindrome, the entire string is first converted to lowercase using `std::transform` and `::tolower`. Then, the **Two-Pointer** technique is applied: `left` starts at 0, and `right` starts at the end. The `while (left < right)` loop checks for character equality, moving the pointers inward until they meet or a mismatch is found.",
      "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nbool isPalindrome(std::string s) {\n    // Convert to lowercase\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n\n    int left = 0;\n    int right = s.length() - 1;\n\n    while (left < right) {\n        if (s[left] != s[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint main() {\n    std::string s1 = \"Racecar\";\n    std::cout << \"Is Palindrome: \" << (isPalindrome(s1) ? \"True\" : \"False\") << std::endl;\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Racecar",
        "expected": "Is Palindrome: True\n"
      },
      {
        "input": "hello",
        "expected": "Is Palindrome: False\n"
      },
      {
        "input": "A",
        "expected": "Is Palindrome: True\n"
      }
    ]
  },
  {
    "id": 158,
    "title": "Vector Find Max Element",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ program to find the largest element in a `std::vector<int>` using the `std::max_element` function.",
    "inputFormat": "The vector is hardcoded.",
    "outputFormat": "The program must print the maximum element.",
    "solution": {
      "explanation": "The C++ Standard Template Library (STL) provides generic algorithms in the `<algorithm>` header. The function **`std::max_element`** efficiently finds the largest element within a given range, defined by its start (`.begin()`) and end (`.end()`) iterators. The function returns an **iterator** pointing to the element, which must be **dereferenced** (`*max_it`) to retrieve the actual maximum value.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> numbers = {10, 5, 20, 15};\n    \n    // Find the iterator pointing to the maximum element\n    auto max_it = std::max_element(numbers.begin(), numbers.end());\n    \n    // Dereference the iterator to get the value\n    int max_value = *max_it;\n    \n    std::cout << \"Maximum element: \" << max_value << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {10, 5, 20, 15}",
        "expected": "Maximum element: 20\n"
      },
      {
        "input": "Vector: {-1, -5, -10}",
        "expected": "Maximum element: -1\n"
      }
    ]
  },
  {
    "id": 159,
    "title": "Class with a Method",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Define a C++ class `Car` with a method `startEngine()` that prints a message. Create an object and call the method.",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the method's output.",
    "solution": {
      "explanation": "A class method, like `startEngine()`, is a function defined within the class that operates on the object's instance. The method is defined as **`public`** to allow external access. The method is called on an object instance (`myCar`) using the **dot operator** (`myCar.startEngine();`).",
      "code": "#include <iostream>\n\nclass Car {\npublic:\n    void startEngine() {\n        std::cout << \"Vroom! Engine started.\" << std::endl;\n    }\n};\n\nint main() {\n    Car myCar;\n    myCar.startEngine();\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Call car.startEngine()",
        "expected": "Vroom! Engine started.\n"
      }
    ]
  },
  {
    "id": 160,
    "title": "Use std::array (Fixed Size)",
    "language": "C++",
    "difficulty": "Easy",
    "problemStatement": "Write a C++ program using `std::array` (fixed-size container) to store 4 integers. Access and print the element at index 2 using the `.at()` method for bounds checking.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "The program must print the element.",
    "solution": {
      "explanation": "**`std::array`** is a C++ container that wraps a fixed-size C-style array, providing modern features while retaining efficiency. The **`.at(index)`** method is used to access elements. Unlike the subscript operator (`[]`), `.at()` performs **run-time bounds checking** and throws an `std::out_of_range` exception if the index is invalid, making it safer for accessing elements.",
      "code": "#include <iostream>\n#include <array>\n\nint main() {\n    // std::array is fixed-size (size 4 is part of the type)\n    std::array<int, 4> data = {1, 2, 3, 4};\n    \n    try {\n        // .at() provides boundary checks\n        int element = data.at(2);\n        std::cout << \"Element at index 2 is: \" << element << std::endl;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Error: Index out of range.\" << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Array: {1, 2, 3, 4}",
        "expected": "Element at index 2 is: 3\n"
      }
    ]
  },
  {
    "id": 161,
    "title": "Function Overloading (Polymorphism)",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Function Overloading** by defining two functions named `print_data`: one that takes an `int` and one that takes a `std::string`.",
    "inputFormat": "Internal calls to both functions.",
    "outputFormat": "Print the output of both calls.",
    "solution": {
      "explanation": "**Function Overloading** is a form of Compile-Time Polymorphism. It allows multiple functions to share the same name, provided their **parameter lists** (signature) are different (either by the number of arguments or the type of arguments). The compiler selects the correct function to call based on the types of the arguments provided at the call site.",
      "code": "#include <iostream>\n#include <string>\n\n// Overloaded Function 1: takes an integer\nvoid print_data(int data) {\n    std::cout << \"Printing integer: \" << data << std::endl;\n}\n\n// Overloaded Function 2: takes a string\nvoid print_data(const std::string& data) {\n    std::cout << \"Printing string: \" << data << std::endl;\n}\n\nint main() {\n    print_data(42);\n    print_data(\"Hello\");\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Call with int 42, Call with string \"Hello\"",
        "expected": "Printing integer: 42\nPrinting string: Hello\n"
      }
    ]
  },
  {
    "id": 162,
    "title": "Class Inheritance (Public)",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Public Inheritance** by creating a base class `Animal` with a public `eat()` method, and a derived class `Dog` that publicly inherits from `Animal`. Create a `Dog` object and call the inherited `eat()` method.",
    "inputFormat": "Internal creation of a `Dog` object.",
    "outputFormat": "The program must print the method's output.",
    "solution": {
      "explanation": "**Public Inheritance** (`class Dog : public Animal`) means all public and protected members of the base class (`Animal`) become public and protected members of the derived class (`Dog`), respectively. This allows the `Dog` object to access the inherited `eat()` method directly, establishing an 'is-a' relationship (a Dog *is a* type of Animal).",
      "code": "#include <iostream>\n\n// Base Class\nclass Animal {\npublic:\n    void eat() {\n        std::cout << \"Animal is eating.\" << std::endl;\n    }\n};\n\n// Derived Class (Public Inheritance)\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog is barking.\" << std::endl;\n    }\n};\n\nint main() {\n    Dog myDog;\n    // Accessing the inherited public method\n    myDog.eat(); \n    myDog.bark();\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Call dog.eat()",
        "expected": "Animal is eating.\nDog is barking.\n"
      }
    ]
  },
  {
    "id": 163,
    "title": "Virtual Function (Simple Polymorphism)",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate **Run-time Polymorphism** using a **virtual function**. Create a base class `Shape` with a `virtual` method `draw()`. Create two derived classes, `Circle` and `Square`, that override `draw()`. Use a `Shape*` pointer to call `draw()` on both derived objects.",
    "inputFormat": "Internal creation of a `Circle` and `Square` object and accessing them via a base pointer.",
    "outputFormat": "The program must print the output of the two calls.",
    "solution": {
      "explanation": "Run-time Polymorphism is achieved using the **`virtual`** keyword in the base class. When a **virtual function** (`draw()`) is called via a **base class pointer or reference** (`Shape* ptr`), the program determines the actual method to execute at runtime based on the object's actual type (`Circle` or `Square`). This is known as **dynamic dispatch**.",
      "code": "#include <iostream>\n\nclass Shape {\npublic:\n    // Virtual function enables run-time polymorphism\n    virtual void draw() {\n        std::cout << \"Drawing a generic shape.\" << std::endl;\n    }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a Circle.\" << std::endl;\n    }\n};\n\nclass Square : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a Square.\" << std::endl;\n    }\n};\n\nint main() {\n    Circle circle_obj;\n    Square square_obj;\n    \n    // Base class pointer\n    Shape* ptr;\n    \n    // Polymorphic Call 1\n    ptr = &circle_obj;\n    ptr->draw();\n    \n    // Polymorphic Call 2\n    ptr = &square_obj;\n    ptr->draw();\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Base pointer pointing to Circle, then Square",
        "expected": "Drawing a Circle.\nDrawing a Square.\n"
      }
    ]
  },
  {
    "id": 164,
    "title": "STL Vector Insertion/Deletion",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Write a C++ program that demonstrates inserting an element into a `std::vector` at a specific position (using `insert()`) and removing an element (using `erase()`). Print the vector after each operation.",
    "inputFormat": "The initial vector is hardcoded.",
    "outputFormat": "Print the vector state after insertion and deletion.",
    "solution": {
      "explanation": "The `std::vector` container is a dynamic array. **`insert()`** and **`erase()`** operations require an **iterator** to specify the position. We use the expression `vec.begin() + index` to get an iterator pointing to the required position. Note that both operations can be relatively slow, with $O(N)$ complexity, because all subsequent elements must be physically shifted in memory.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid printVector(const std::vector<int>& vec) {\n    for (int num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> vec = {1, 2, 4};\n    \n    // 1. Insert 3 at index 2 (position vec.begin() + 2)\n    vec.insert(vec.begin() + 2, 3);\n    std::cout << \"After insert: \";\n    printVector(vec);\n    \n    // 2. Erase element at index 1 (value 2)\n    vec.erase(vec.begin() + 1);\n    std::cout << \"After erase: \";\n    printVector(vec);\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Initial: {1, 2, 4}. Insert 3 at index 2. Erase element at index 1 (value 2).",
        "expected": "After insert: 1 2 3 4 \nAfter erase: 1 3 4 \n"
      }
    ]
  },
  {
    "id": 165,
    "title": "STL Map Word Counting",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Write a C++ program that counts the frequency of each unique word in a given string using `std::map<std::string, int>`. Print the map contents.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print the contents of the map.",
    "solution": {
      "explanation": "The **`std::map`** (or `std::unordered_map` for hash-based) is ideal for counting frequency. The expression **`wordCounts[word]++`** is highly efficient: if the key `word` doesn't exist, `std::map` automatically default-constructs a value of 0 for it, and then increments it to 1. If the key exists, the value is simply incremented. `std::map` keeps keys sorted, which is visible in the output.",
      "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n\nint main() {\n    std::string text = \"The quick brown fox and the lazy fox.\";\n    std::map<std::string, int> wordCounts;\n    std::string word;\n    \n    // Use stringstream to easily split the string into words\n    std::stringstream ss(text);\n    \n    while (ss >> word) {\n        // Convert to lowercase and remove simple punctuation for better counting\n        if (word.back() == '.') {\n            word.pop_back();\n        }\n        // Efficiently count the word\n        wordCounts[word]++;\n    }\n    \n    // Print the map contents\n    for (const auto& pair : wordCounts) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "The quick brown fox and the lazy fox.",
        "expected": "and: 1\nbrown: 1\nfox: 2\nlazy: 1\nquick: 1\nthe: 2\n"
      }
    ]
  },
  {
    "id": 166,
    "title": "Casting and Type Conversions",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate the use of C-style cast, `static_cast`, and automatic type conversion by performing the following operations: \n1. Calculate the correct floating-point division of two integers (10 and 3).\n2. Convert a `double` (4.5) to an `int` using `static_cast`.",
    "inputFormat": "No user input required.",
    "outputFormat": "Print the result of the division and the result of the cast.",
    "solution": {
      "explanation": "C++ offers type-safe casting. **`static_cast<double>(a)`** is used to temporarily convert an integer `a` to a double, ensuring that the subsequent division is performed using floating-point arithmetic, which prevents integer truncation. **`static_cast<int>(d)`** explicitly converts the floating-point number `d` to an integer, which results in the fractional part being truncated (rounded towards zero).",
      "code": "#include <iostream>\n\nint main() {\n    int a = 10;\n    int b = 3;\n    double d = 4.5;\n    \n    // 1. Correct floating-point division\n    double result = static_cast<double>(a) / b;\n    std::cout << \"Division result: \" << result << std::endl;\n    \n    // 2. static_cast conversion (truncates the decimal)\n    int casted_int = static_cast<int>(d);\n    std::cout << \"Casted integer: \" << casted_int << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "10/3 division and static_cast(4.5)",
        "expected": "Division result: 3.33333\nCasted integer: 4\n"
      }
    ]
  },
  {
    "id": 167,
    "title": "Template Function (Generic Swap)",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Write a **Template Function** named `generic_swap` that can swap the values of two variables of **any type** (int, double, etc.) without writing separate functions for each type.",
    "inputFormat": "Internal calls swapping two integers and two strings.",
    "outputFormat": "Print the values before and after each swap.",
    "solution": {
      "explanation": "A **Template Function** uses type parameters (`typename T`) to enable **Generic Programming**. The compiler automatically generates (instantiates) a separate, optimized version of the `generic_swap` function for each data type (int, `std::string`) used to call it. This avoids writing redundant code for the same logic across different types.",
      "code": "#include <iostream>\n#include <string>\n\n// Template function definition\ntemplate <typename T>\nvoid generic_swap(T& a, T& b) {\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    // 1. Swap Integers\n    int i1 = 10;\n    int i2 = 20;\n    generic_swap(i1, i2);\n    std::cout << \"Ints after swap: a=\" << i1 << \", b=\" << i2 << std::endl;\n    \n    // 2. Swap Strings\n    std::string s1 = \"A\";\n    std::string s2 = \"B\";\n    generic_swap(s1, s2);\n    std::cout << \"Strings after swap: s1=\" << s1 << \", s2=\" << s2 << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "int a=10, b=20; string s1=\"A\", s2=\"B\"",
        "expected": "Ints after swap: a=20, b=10\nStrings after swap: s1=B, s2=A\n"
      }
    ]
  },
  {
    "id": 168,
    "title": "Exception Handling (Division by Zero)",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Write a C++ program that attempts to perform division. Use a **`try-catch`** block to handle a scenario where the divisor is zero, throwing a custom `std::runtime_error`.",
    "inputFormat": "Internal hardcoded division (10 / 0).",
    "outputFormat": "Print the caught exception message.",
    "solution": {
      "explanation": "C++ uses `try`, `throw`, and `catch` for exception handling. When the error condition (`denominator == 0`) is detected, the **`throw`** keyword creates and throws an exception object (`std::runtime_error`), which immediately transfers control out of the `try` block. The program searches for a matching **`catch`** block that can handle the specific exception type, thus preventing program termination.",
      "code": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    int numerator = 10;\n    int denominator = 0;\n    \n    try {\n        if (denominator == 0) {\n            throw std::runtime_error(\"Division by zero is not allowed.\");\n        }\n        int result = numerator / denominator;\n        std::cout << \"Result: \" << result << std::endl;\n    } catch (const std::runtime_error& e) {\n        // Catch the specific exception type and print its message\n        std::cerr << \"Caught Error: \" << e.what() << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "10 / 0",
        "expected": "Caught Error: Division by zero is not allowed.\n"
      }
    ]
  },
  {
    "id": 169,
    "title": "Unique Elements using std::set",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Given a `std::vector<int>` with duplicates, write a C++ program to find and print all unique elements by transferring them into a `std::set<int>`. Print the size of the set.",
    "inputFormat": "The vector is hardcoded.",
    "outputFormat": "Print the unique elements and the size of the set.",
    "solution": {
      "explanation": "The **`std::set`** container, part of the C++ STL, is specifically designed to store only **unique, ordered elements**. By passing the iterators of the original vector to the set's constructor, all duplicates are automatically removed during the construction process. Iterating over the set yields the unique elements in sorted order.",
      "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 2, 3, 4, 4, 4, 5};\n    \n    // Create a set from the vector (automatically handles uniqueness)\n    std::set<int> unique_elements(numbers.begin(), numbers.end());\n    \n    std::cout << \"Unique elements: \";\n    for (int num : unique_elements) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    std::cout << \"Set size: \" << unique_elements.size() << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {1, 2, 2, 3, 4, 4, 4, 5}",
        "expected": "Unique elements: 1 2 3 4 5 \nSet size: 5\n"
      }
    ]
  },
  {
    "id": 170,
    "title": "OOP: Destructor and Resource Cleanup",
    "language": "C++",
    "difficulty": "Medium",
    "problemStatement": "Demonstrate the use of a **Destructor** in a C++ class `Resource`. The destructor should print a message when the object is destroyed, simulating resource cleanup. Use RAII (Resource Acquisition Is Initialization) implicitly by creating an object on the stack.",
    "inputFormat": "Internal creation and scope exit.",
    "outputFormat": "Print the constructor and destructor messages.",
    "solution": {
      "explanation": "A **Destructor** (`~Resource()`) is automatically called when an object goes out of scope (for stack-allocated objects) or when `delete` is called (for heap-allocated objects). Destructors are essential for performing resource management and **cleanup**, such as deallocating dynamically allocated memory, closing file handles, or releasing network connections, adhering to the **RAII** (Resource Acquisition Is Initialization) principle.",
      "code": "#include <iostream>\n\nclass Resource {\npublic:\n    // Constructor\n    Resource() {\n        std::cout << \"Resource constructed.\" << std::endl;\n    }\n    \n    // Destructor\n    ~Resource() {\n        std::cout << \"Resource destroyed (cleanup successful).\" << std::endl;\n    }\n};\n\nvoid function_scope() {\n    std::cout << \"Entering function scope...\" << std::endl;\n    Resource r; // Object created on the stack\n    std::cout << \"Exiting function scope...\" << std::endl;\n    // r is destroyed automatically here\n}\n\nint main() {\n    function_scope();\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Object created in scope",
        "expected": "Entering function scope...\nResource constructed.\nExiting function scope...\nResource destroyed (cleanup successful).\n"
      }
    ]
  },
  {
    "id": 171,
    "title": "Binary Search (Iterative)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write an iterative C++ function `binarySearch(vec, target)` that searches for a target value in a **sorted** `std::vector<int>`. Return the index of the target if found, or -1 otherwise.",
    "inputFormat": "The vector and target are hardcoded.",
    "outputFormat": "The program must print the index or -1.",
    "solution": {
      "explanation": "Iterative **Binary Search** maintains `low`, `high`, and `mid` pointers. The `while (low <= high)` loop iteratively halves the search space. The `mid` is recalculated in each iteration. The process stops when the target is found or when `low` exceeds `high`.",
      "code": "#include <iostream>\n#include <vector>\n\nint binarySearch(const std::vector<int>& arr, int target) {\n    int low = 0;\n    int high = arr.size() - 1;\n    \n    while (low <= high) {\n        // Safe calculation of mid\n        int mid = low + (high - low) / 2;\n        \n        if (arr[mid] == target) {\n            return mid; // Found\n        } else if (arr[mid] < target) {\n            low = mid + 1; // Target is in the upper half\n        } else {\n            high = mid - 1; // Target is in the lower half\n        }\n    }\n    \n    return -1; // Not found\n}\n\nint main() {\n    std::vector<int> numbers = {2, 5, 8, 12, 16};\n    int target = 12;\n    int index = binarySearch(numbers, target);\n    std::cout << \"Element \" << target << \" found at index: \" << index << std::endl;\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {2, 5, 8, 12, 16}, Target: 12",
        "expected": "Element 12 found at index: 3\n"
      }
    ]
  },
  {
    "id": 172,
    "title": "STL Sort and Reverse Algorithms",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program that demonstrates the usage of `std::sort` to sort a vector of integers, and `std::reverse` to reverse the sorted vector. Use iterators (`begin()` and `end()`) with these algorithms.",
    "inputFormat": "The vector is hardcoded.",
    "outputFormat": "Print the vector after sorting and after reversing.",
    "solution": {
      "explanation": "The `<algorithm>` header contains powerful functions. **`std::sort`** typically uses an IntroSort implementation (hybrid of QuickSort, HeapSort, and InsertionSort) for $O(N \\log N)$ average performance. **`std::reverse`** reverses the elements in linear $O(N)$ time. Both algorithms operate on ranges defined by **iterators** (`.begin()` and `.end()`), making them highly generic for STL containers.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid printVector(const std::vector<int>& vec, const std::string& label) {\n    std::cout << label << \": \";\n    for (int num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> numbers = {6, 1, 4, 3, 5, 2};\n    \n    // 1. Sort the vector in ascending order (QuickSort/IntroSort implementation)\n    std::sort(numbers.begin(), numbers.end());\n    printVector(numbers, \"Sorted\");\n    \n    // 2. Reverse the entire sorted vector\n    std::reverse(numbers.begin(), numbers.end());\n    printVector(numbers, \"Reversed\");\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {6, 1, 4, 3, 5, 2}",
        "expected": "Sorted: 1 2 3 4 5 6 \nReversed: 6 5 4 3 2 1 \n"
      }
    ]
  },
  {
    "id": 173,
    "title": "Binary Search Tree (BST) Class",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program that implements the **Binary Search Tree (BST)** using a class structure. The implementation must include nested structs for the `Node` and methods for `insert(key)` and `inorderTraversal()`.",
    "inputFormat": "Internal insertion of keys (50, 30, 70, 20, 40, 60, 80).",
    "outputFormat": "Print the keys using Inorder Traversal.",
    "solution": {
      "explanation": "The BST is implemented as a class wrapping a recursive pointer structure. **Insertion** is recursive: if the key is smaller, traverse left; if larger, traverse right, until a null pointer is found. **Inorder Traversal** is also recursive (Left -> Root -> Right), which naturally yields the tree elements in sorted order. Nested structs are used to encapsulate the node definition within the `BST` class.",
      "code": "#include <iostream>\n#include <algorithm>\n\nclass BST {\nprivate:\n    struct Node {\n        int key;\n        Node *left, *right;\n        Node(int k) : key(k), left(nullptr), right(nullptr) {}\n    };\n    \n    Node* root;\n    \n    // Private recursive helper for insertion\n    Node* insertRecursive(Node* node, int key) {\n        if (node == nullptr) {\n            return new Node(key);\n        }\n        if (key < node->key) {\n            node->left = insertRecursive(node->left, key);\n        } else if (key > node->key) {\n            node->right = insertRecursive(node->right, key);\n        }\n        return node;\n    }\n    \n    // Private recursive helper for traversal\n    void inorderRecursive(Node* node) {\n        if (node != nullptr) {\n            inorderRecursive(node->left);\n            std::cout << node->key << \" \";\n            inorderRecursive(node->right);\n        }\n    }\n\npublic:\n    BST() : root(nullptr) {}\n    \n    void insert(int key) {\n        root = insertRecursive(root, key);\n    }\n    \n    void inorderTraversal() {\n        inorderRecursive(root);\n        std::cout << std::endl;\n    }\n    \n    // Destructor (important for memory cleanup)\n    ~BST() { /* Cleanup logic (e.g., postorder traversal to delete all nodes) */ }\n};\n\nint main() {\n    BST tree;\n    int keys[] = {50, 30, 70, 20, 40, 60, 80};\n    \n    for (int key : keys) {\n        tree.insert(key);\n    }\n    \n    std::cout << \"Inorder Traversal: \";\n    tree.inorderTraversal();\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Keys: 50, 30, 70, 20, 40, 60, 80",
        "expected": "Inorder Traversal: 20 30 40 50 60 70 80 \n"
      }
    ]
  },
  {
    "id": 174,
    "title": "Stack implementation using std::vector",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement a Stack (LIFO) in C++ using the `std::vector` class as the underlying data structure. Implement the methods `push()`, `pop()`, and `top()`. Handle underflow exceptions for `pop()` and `top()`.",
    "inputFormat": "Internal sequence of stack operations.",
    "outputFormat": "Print the result of the stack operations, including error handling.",
    "solution": {
      "explanation": "A **Stack** (LIFO) is easily implemented using `std::vector` by leveraging its efficient $O(1)$ end operations: **`push`** uses `vector.push_back()`, **`pop`** uses `vector.pop_back()` (when paired with `back()` for return value), and **`top`** uses `vector.back()`. The crucial safety mechanism involves explicitly checking `data.empty()` and throwing an **`std::out_of_range`** exception to prevent underflow crashes.",
      "code": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass CustomStack {\nprivate:\n    std::vector<int> data;\n\npublic:\n    void push(int val) {\n        data.push_back(val);\n    }\n    \n    int pop() {\n        if (data.empty()) {\n            throw std::out_of_range(\"Stack Underflow\");\n        }\n        int val = data.back();\n        data.pop_back();\n        return val;\n    }\n    \n    int top() const {\n        if (data.empty()) {\n            throw std::out_of_range(\"Stack is Empty\");\n        }\n        return data.back();\n    }\n};\n\nint main() {\n    CustomStack stack;\n    stack.push(10);\n    stack.push(20);\n    \n    try {\n        std::cout << \"Popped: \" << stack.pop() << std::endl; \n        std::cout << \"Top element: \" << stack.top() << std::endl; \n        stack.pop();\n        stack.pop(); // Throws exception\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Push 10, Push 20, Pop, Top",
        "expected": "Popped: 20\nTop element: 10\nError: Stack Underflow\n"
      }
    ]
  },
  {
    "id": 175,
    "title": "Queue implementation using std::deque",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement a Queue (FIFO) in C++ using the `std::deque` (double-ended queue) class. Implement the methods `enqueue()`, `dequeue()`, and `front()`. Handle underflow exceptions.",
    "inputFormat": "Internal sequence of queue operations.",
    "outputFormat": "Print the result of the queue operations.",
    "solution": {
      "explanation": "A **Queue** (FIFO) is implemented using **`std::deque`** because it provides efficient $O(1)$ time complexity for insertions and deletions at both ends. **`enqueue`** (adding to the rear) uses `deque.push_back()`, and **`dequeue`** (removing from the front) uses `deque.pop_front()`. Accessing the front element is done with `deque.front()`. Exception handling ensures robustness against underflow.",
      "code": "#include <iostream>\n#include <deque>\n#include <stdexcept>\n\nclass CustomQueue {\nprivate:\n    std::deque<int> data;\n\npublic:\n    void enqueue(int val) {\n        data.push_back(val); // Add to rear (end)\n    }\n    \n    int dequeue() {\n        if (data.empty()) {\n            throw std::out_of_range(\"Queue Underflow\");\n        }\n        int val = data.front();\n        data.pop_front(); // Remove from front\n        return val;\n    }\n    \n    int front() const {\n        if (data.empty()) {\n            throw std::out_of_range(\"Queue is Empty\");\n        }\n        return data.front();\n    }\n};\n\nint main() {\n    CustomQueue queue;\n    queue.enqueue(10);\n    queue.enqueue(20);\n    \n    std::cout << \"Dequeued: \" << queue.dequeue() << std::endl; \n    std::cout << \"Front element: \" << queue.front() << std::endl; \n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Enqueue 10, Enqueue 20, Dequeue, Front",
        "expected": "Dequeued: 10\nFront element: 20\n"
      }
    ]
  },
  {
    "id": 176,
    "title": "Vector Rotation (std::rotate)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program to rotate a `std::vector<int>` to the **left** by 2 positions using the `std::rotate` algorithm. Print the vector before and after rotation.",
    "inputFormat": "The vector is hardcoded.",
    "outputFormat": "Print the vector state before and after rotation.",
    "solution": {
      "explanation": "The **`std::rotate`** algorithm performs a left rotation in linear $O(N)$ time. It takes three iterators: `first` (start of the range), `middle` (the element that *will* become the new first element), and `last` (one past the end). For a left rotation by $K$ positions, the `middle` iterator is calculated as `vec.begin() + K`, moving that element to the front.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid printVector(const std::vector<int>& vec) {\n    for (int num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    int k = 2; // Left rotation by 2 positions\n    \n    std::cout << \"Before: \";\n    printVector(numbers);\n    \n    // std::rotate shifts the element at begin() + k to the beginning\n    std::rotate(numbers.begin(), numbers.begin() + k, numbers.end());\n    \n    std::cout << \"After: \";\n    printVector(numbers);\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {1, 2, 3, 4, 5}, 2 positions left",
        "expected": "Before: 1 2 3 4 5 \nAfter: 3 4 5 1 2 \n"
      }
    ]
  },
  {
    "id": 177,
    "title": "Longest Common Subsequence (Recursive)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a **recursive** C++ function `lcs(s1, s2, m, n)` to find the length of the **Longest Common Subsequence (LCS)** of two strings. **Do not use dynamic programming or memoization** (to focus on the recursive structure).",
    "inputFormat": "The strings are hardcoded.",
    "outputFormat": "The program must print the length of the LCS.",
    "solution": {
      "explanation": "The purely recursive **LCS** solution is defined by two cases: 1. **Match:** If the last characters match, the length is $1 + lcs(s1_{m-1}, s2_{n-1})$. 2. **Mismatch:** If the characters don't match, the length is the maximum of the two recursive calls, $\\max(lcs(s1_{m-1}, s2_n), lcs(s1_m, s2_{n-1}))$. This approach suffers from exponential $O(2^{\\min(M, N)})$ time complexity due to redundant subproblem recomputations.",
      "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Recursive function to find the length of LCS\nint lcs(const std::string& s1, const std::string& s2, int m, int n) {\n    // Base Case: one of the strings is empty\n    if (m == 0 || n == 0) {\n        return 0;\n    }\n    \n    // Case 1: Characters match\n    if (s1[m - 1] == s2[n - 1]) {\n        return 1 + lcs(s1, s2, m - 1, n - 1);\n    }\n    // Case 2: Characters don't match\n    else {\n        return std::max(lcs(s1, s2, m - 1, n), lcs(s1, s2, m, n - 1));\n    }\n}\n\nint main() {\n    std::string s1 = \"AGGTAB\";\n    std::string s2 = \"GXTXAYB\";\n    \n    int result = lcs(s1, s2, s1.length(), s2.length());\n    std::cout << \"LCS Length (Recursive): \" << result << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "s1=AGGTAB, s2=GXTXAYB",
        "expected": "LCS Length (Recursive): 4\n"
      }
    ]
  },
  {
    "id": 178,
    "title": "OOP: Operator Overloading (+)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate **Operator Overloading** by defining a class `Vector2D` (with `x` and `y` coordinates). Overload the addition operator (`+`) so that adding two `Vector2D` objects results in a new `Vector2D` object with their components summed.",
    "inputFormat": "Internal addition of two `Vector2D` objects.",
    "outputFormat": "Print the coordinates of the resulting vector.",
    "solution": {
      "explanation": "Operator overloading is performed by defining a method named **`operator+(arguments)`** within the class. This allows the built-in operator (`+`) to be used with user-defined types. The function returns a new `Vector2D` object, which is the result of the component-wise addition of the current object and the `other` operand.",
      "code": "#include <iostream>\n\nclass Vector2D {\npublic:\n    int x;\n    int y;\n\n    Vector2D(int x_coord, int y_coord) : x(x_coord), y(y_coord) {}\n\n    // Operator Overloading for the '+' operator\n    Vector2D operator+(const Vector2D& other) const {\n        // Returns a new Vector2D object\n        return Vector2D(x + other.x, y + other.y);\n    }\n};\n\nint main() {\n    Vector2D v1(1, 2);\n    Vector2D v2(3, 4);\n    \n    // Uses the overloaded '+' operator\n    Vector2D v3 = v1 + v2;\n    \n    std::cout << \"Result Vector: (\" << v3.x << \", \" << v3.y << \")\" << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "V1(1, 2) + V2(3, 4)",
        "expected": "Result Vector: (4, 6)\n"
      }
    ]
  },
  {
    "id": 179,
    "title": "OOP: Copy Constructor and Deep/Shallow Copy",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate a **Copy Constructor** by creating a class `ArrayWrapper` that manages a dynamically allocated integer array. Implement the copy constructor to perform a **Deep Copy**, ensuring that the copied object has its own separate memory for the array.",
    "inputFormat": "Internal creation of one object and copy-initialization of another.",
    "outputFormat": "Print the values of the two objects' arrays after modifying the copied object.",
    "solution": {
      "explanation": "A **Copy Constructor** (`ClassName(const ClassName& other)`) is necessary when a class manages resources like heap memory. To prevent both objects from sharing and illegally deleting the same memory (the **Shallow Copy** problem), we must implement a **Deep Copy**. This involves allocating new memory for the destination object (`new int[other.size]`) and then manually copying the *content* of the source array using `std::copy`, ensuring true independence.",
      "code": "#include <iostream>\n#include <algorithm>\n\nclass ArrayWrapper {\nprivate:\n    int* data;\n    size_t size;\n    \npublic:\n    // Constructor\n    ArrayWrapper(size_t s) : size(s), data(new int[s]) {\n        for (size_t i = 0; i < s; ++i) data[i] = i + 1;\n    }\n    \n    // Destructor: Clean up the dynamically allocated memory\n    ~ArrayWrapper() { delete[] data; }\n\n    // CRITICAL: Copy Constructor for Deep Copy\n    ArrayWrapper(const ArrayWrapper& other) : size(other.size), data(new int[other.size]) {\n        // Copy the contents of the array from 'other' into the 'this->data' new memory\n        std::copy(other.data, other.data + size, data);\n    }\n    \n    // Accessor for simplicity\n    void set(int index, int val) { if (index < size) data[index] = val; }\n    int get(int index) const { return (index < size) ? data[index] : -1; }\n    size_t getSize() const { return size; }\n};\n\nint main() {\n    // Original object\n    ArrayWrapper obj1(3);\n    \n    // Copy Initialization (calls the Copy Constructor)\n    ArrayWrapper obj2 = obj1; \n    \n    // Modify obj2 (This only modifies obj2's separate memory)\n    obj2.set(0, 99);\n    \n    // Output\n    std::cout << \"Obj1 Array: \";\n    for (size_t i = 0; i < obj1.getSize(); ++i) std::cout << obj1.get(i) << \" \";\n    std::cout << std::endl;\n\n    std::cout << \"Obj2 Array: \";\n    for (size_t i = 0; i < obj2.getSize(); ++i) std::cout << obj2.get(i) << \" \";\n    std::cout << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Obj1 array: {1, 2, 3}. Obj2 is a copy of Obj1. Modify Obj2[0] = 99.",
        "expected": "Obj1 Array: 1 2 3 \nObj2 Array: 99 2 3 \n"
      }
    ]
  },
  {
    "id": 180,
    "title": "Template Class (Generic Stack)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a **Template Class** named `GenericStack` that implements a basic Stack (LIFO). The class should be able to store elements of any data type (int, string, double) using `std::vector` as the underlying container.",
    "inputFormat": "Internal creation of a stack for integers and a stack for strings.",
    "outputFormat": "Print the elements popped from both stacks.",
    "solution": {
      "explanation": "A **Template Class** (`template <typename T>`) allows the class structure to be generic, operating on elements of any data type (`T`). The compiler instantiates a specific version of the `GenericStack` for each type it is used with (e.g., `GenericStack<int>`, `GenericStack<std::string>`). The internal logic (using `std::vector::push_back` and `std::vector::pop_back`) remains identical regardless of the type being stored.",
      "code": "#include <iostream>\n#include <vector>\n#include <string>\n\n// Template Class definition\ntemplate <typename T>\nclass GenericStack {\nprivate:\n    std::vector<T> data;\n\npublic:\n    void push(const T& val) {\n        data.push_back(val);\n    }\n    \n    T pop() {\n        if (data.empty()) {\n            throw std::out_of_range(\"Stack Underflow\");\n        }\n        T val = data.back();\n        data.pop_back();\n        return val;\n    }\n    \n    bool empty() const { return data.empty(); }\n};\n\nint main() {\n    // 1. Instantiate a stack for Integers\n    GenericStack<int> intStack;\n    intStack.push(10);\n    intStack.push(20);\n    std::cout << \"Popped Int: \" << intStack.pop() << std::endl;\n    \n    // 2. Instantiate a stack for Strings\n    GenericStack<std::string> stringStack;\n    stringStack.push(\"A\");\n    stringStack.push(\"B\");\n    std::cout << \"Popped String: \" << stringStack.pop() << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Int Stack: Push 10, Push 20. String Stack: Push \"A\", Push \"B\"",
        "expected": "Popped Int: 20\nPopped String: B\n"
      }
    ]
  },
  {
    "id": 181,
    "title": "Two Sum Problem (Map/Hash Table)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Given a `std::vector<int>` (e.g., `{2, 7, 11, 15}`) and a `target` (e.g., 9), find the indices of the two numbers that add up to the target. Implement this using a **`std::unordered_map` (Hash Table)** for $O(N)$ complexity.",
    "inputFormat": "The vector and target are hardcoded.",
    "outputFormat": "Print the indices of the two numbers.",
    "solution": {
      "explanation": "The **Two Sum** problem is solved efficiently in $O(N)$ time using a **Hash Table** (`std::unordered_map`). For each number $x$ in the array, the algorithm checks if the **complement** ($target - x$) already exists in the map. If it exists, the pair is found. Otherwise, the current number $x$ is inserted into the map along with its index, ready to be the complement for future numbers.",
      "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(const std::vector<int>& nums, int target) {\n    // Map stores: {complement value: index}\n    std::unordered_map<int, int> complements;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        int complement = target - nums[i];\n        \n        // Check if the required complement is already in the map\n        if (complements.count(nums[i])) {\n            // Match found! Return the complement's index and the current index\n            return {complements[nums[i]], i};\n        }\n        \n        // No match yet, store the complement and the current index\n        complements[complement] = i;\n    }\n    \n    return {}; // Should not happen for a valid test case\n}\n\nint main() {\n    std::vector<int> nums = {2, 7, 11, 15};\n    int target = 9;\n    \n    std::vector<int> result = twoSum(nums, target);\n    \n    if (result.size() == 2) {\n        std::cout << \"Indices: \" << result[0] << \", \" << result[1] << std::endl;\n    } else {\n        std::cout << \"No solution found.\" << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {2, 7, 11, 15}, Target: 9",
        "expected": "Indices: 0, 1\n"
      },
      {
        "input": "Vector: {3, 2, 4}, Target: 6",
        "expected": "Indices: 1, 2\n"
      },
      {
        "input": "Vector: {1, 5, 8}, Target: 10",
        "expected": "Indices: 0, 2\n"
      }
    ]
  },
  {
    "id": 182,
    "title": "Sliding Window (Max Subarray Sum of size K)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program using the **Sliding Window** technique to find the maximum sum of any contiguous subarray of a fixed size `K` (e.g., 3) within a `std::vector<int>`.",
    "inputFormat": "The vector and size K are hardcoded.",
    "outputFormat": "Print the maximum sum found.",
    "solution": {
      "explanation": "The **Sliding Window** technique provides an $O(N)$ solution. It calculates the sum of the first window once. Then, it iteratively 'slides' the window one step by performing an $O(1)$ update: **subtracting the element leaving** the window and **adding the new element entering** it. This avoids recalculating the entire sum for every subarray, achieving optimal linear performance.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxSubarraySum(const std::vector<int>& arr, int K) {\n    if (K > arr.size()) {\n        return 0; // Handle invalid input\n    }\n    \n    // 1. Calculate sum of the initial window [0, K-1]\n    int currentSum = 0;\n    for (int i = 0; i < K; ++i) {\n        currentSum += arr[i];\n    }\n    int maxSum = currentSum;\n    \n    // 2. Slide the window from index K to the end\n    for (int i = K; i < arr.size(); ++i) {\n        // Subtract element leaving the window (arr[i-K])\n        // Add element entering the window (arr[i])\n        currentSum = currentSum - arr[i - K] + arr[i];\n        \n        // Update the overall maximum sum\n        maxSum = std::max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}\n\nint main() {\n    std::vector<int> arr = {1, 4, 2, 10, 23, 3, 1, 0, 20};\n    int K = 4;\n    \n    int result = maxSubarraySum(arr, K);\n    std::cout << \"Maximum sum of subarray size \" << K << \" is: \" << result << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {1, 4, 2, 10, 23, 3, 1, 0, 20}, K=4",
        "expected": "Maximum sum of subarray size 4 is: 38\n"
      },
      {
        "input": "Vector: {1, 2, 3, 4}, K=2",
        "expected": "Maximum sum of subarray size 2 is: 7\n"
      }
    ]
  },
  {
    "id": 183,
    "title": "Kadane's Algorithm (Max Contiguous Subarray Sum)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement **Kadane's Algorithm** in C++ to find the maximum sum of any contiguous subarray within a given array of integers. The array can contain negative numbers.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "Print the maximum contiguous sum.",
    "solution": {
      "explanation": "**Kadane's Algorithm** is a classic **Dynamic Programming** approach that runs in $O(N)$ time. It tracks two sums: `current_max` (the max sum of a subarray ending at the current element) and `max_so_far` (the overall maximum). At each step, `current_max` is updated by choosing the greater of: 1. starting a new subarray at the current element, or 2. extending the previous subarray (`current_max + arr[i]`).",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint maxContiguousSum(const std::vector<int>& arr) {\n    if (arr.empty()) return 0;\n    \n    int max_so_far = arr[0];\n    int current_max = arr[0];\n    \n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Determine max sum ending at index i: either start a new sequence at arr[i] \n        // or extend the previous one.\n        current_max = std::max(arr[i], current_max + arr[i]);\n        \n        // Update the overall max sum found so far\n        max_so_far = std::max(max_so_far, current_max);\n    }\n    \n    return max_so_far;\n}\n\nint main() {\n    std::vector<int> arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result = maxContiguousSum(arr);\n    std::cout << \"Max Contiguous Sum: \" << result << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Array: {-2, 1, -3, 4, -1, 2, 1, -5, 4}",
        "expected": "Max Contiguous Sum: 6\n"
      },
      {
        "input": "Array: {1, 2, 3}",
        "expected": "Max Contiguous Sum: 6\n"
      },
      {
        "input": "Array: {-10, -5, -2}",
        "expected": "Max Contiguous Sum: -2\n"
      }
    ]
  },
  {
    "id": 184,
    "title": "Merge Sort Implementation",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement the **Merge Sort** algorithm in C++. The implementation must include both the `merge` function (to combine two sorted subarrays) and the recursive `mergeSort` function.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "Print the vector after sorting.",
    "solution": {
      "explanation": "**Merge Sort** is a $O(N \\log N)$ **Divide and Conquer** algorithm. It recursively splits the array in half (Divide), sorts them (via recursion), and then combines the two sorted halves back into a single sorted array using the linear-time **`merge` function**.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// 1. Merge function (O(N))\nvoid merge(std::vector<int>& arr, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    // Create temporary arrays L and R\n    std::vector<int> L(n1);\n    std::vector<int> R(n2);\n    \n    for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n    \n    int i = 0, j = 0, k = left;\n    \n    // Merge L and R back into arr[left..right]\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k++] = L[i++];\n        } else {\n            arr[k++] = R[j++];\n        }\n    }\n    \n    // Copy remaining elements\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}\n\n// 2. Merge Sort function (Recursive)\nvoid mergeSort(std::vector<int>& arr, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        \n        // Divide and Conquer\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        \n        // Combine\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    std::vector<int> arr = {12, 11, 13, 5, 6, 7};\n    mergeSort(arr, 0, arr.size() - 1);\n    \n    std::cout << \"Sorted Array: \";\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {12, 11, 13, 5, 6, 7}",
        "expected": "Sorted Array: 5 6 7 11 12 13 \n"
      },
      {
        "input": "Vector: {5, 4, 3, 2, 1}",
        "expected": "Sorted Array: 1 2 3 4 5 \n"
      }
    ]
  },
  {
    "id": 185,
    "title": "Quick Sort Implementation",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement the **Quick Sort** algorithm in C++. The implementation must include the `partition` function (to place the pivot in its correct position) and the recursive `quickSort` function.",
    "inputFormat": "The array is hardcoded.",
    "outputFormat": "Print the vector after sorting.",
    "solution": {
      "explanation": "**Quick Sort** is an $O(N \\log N)$ (average case) **in-place** sorting algorithm. It relies on the **`partition` function**, which selects a pivot element and rearranges the array so that all elements smaller than the pivot come before it, and all greater elements come after it. The `quickSort` function then recursively calls itself on the two subarrays formed by the partition until the array is fully sorted.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Partition function (Hoare or Lomuto partition scheme)\nint partition(std::vector<int>& arr, int low, int high) {\n    int pivot = arr[high]; // Choose the last element as the pivot\n    int i = (low - 1); // Index of smaller element\n    \n    for (int j = low; j <= high - 1; j++) {\n        // If current element is smaller than or equal to pivot\n        if (arr[j] <= pivot) {\n            i++; // Increment index of smaller element\n            std::swap(arr[i], arr[j]);\n        }\n    }\n    std::swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(std::vector<int>& arr, int low, int high) {\n    if (low < high) {\n        // pi is partitioning index, arr[p] is now at right place\n        int pi = partition(arr, low, high);\n        \n        // Separately sort elements before and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    std::vector<int> arr = {10, 80, 30, 90, 40, 50, 70};\n    quickSort(arr, 0, arr.size() - 1);\n    \n    std::cout << \"Sorted Array: \";\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {10, 80, 30, 90, 40, 50, 70}",
        "expected": "Sorted Array: 10 30 40 50 70 80 90 \n"
      },
      {
        "input": "Vector: {5, 4, 3, 2, 1}",
        "expected": "Sorted Array: 1 2 3 4 5 \n"
      }
    ]
  },
  {
    "id": 186,
    "title": "Template Function: Generic Max Element",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a **Template Function** named `findMax` that takes a `std::vector` of any type `T` and returns the largest element within that vector. Demonstrate its use with a vector of `int` and a vector of `double`.",
    "inputFormat": "Two hardcoded vectors (int and double).",
    "outputFormat": "Print the maximum element of both vectors.",
    "solution": {
      "explanation": "A **Template Function** (`template <typename T>`) allows the function body to operate generically on any data type (`T`). The compiler instantiates a specific version of `findMax` at compile time for each type used (int, double). The logic remains a simple $O(N)$ linear scan, requiring only that the type `T` supports the comparison operator (`>`).",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Template function to find the maximum element in a vector of any comparable type T\ntemplate <typename T>\nT findMax(const std::vector<T>& vec) {\n    if (vec.empty()) {\n        throw std::runtime_error(\"Vector is empty\");\n    }\n    T max_val = vec[0];\n    for (const T& val : vec) {\n        if (val > max_val) {\n            max_val = val;\n        }\n    }\n    return max_val;\n}\n\nint main() {\n    std::vector<int> ints = {1, 5, 3};\n    std::vector<double> doubles = {1.1, 5.5, 3.3};\n    \n    try {\n        std::cout << \"Max Int: \" << findMax(ints) << std::endl;\n        std::cout << \"Max Double: \" << findMax(doubles) << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Int Vec: {1, 5, 3}. Double Vec: {1.1, 5.5, 3.3}",
        "expected": "Max Int: 5\nMax Double: 5.5\n"
      }
    ]
  },
  {
    "id": 187,
    "title": "Exception: Try-Catch with multiple handlers",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program that defines two custom exception classes, `InputError` and `LogicError`. Write a function that throws one of the two based on a condition. Use a single `try` block with **two separate `catch` blocks** to handle each exception type individually.",
    "inputFormat": "Internal call to a function that throws `InputError`.",
    "outputFormat": "Print the message specific to the caught exception.",
    "solution": {
      "explanation": "C++ allows for specialized error handling through **multiple `catch` blocks**. When an exception object is thrown, the program checks the `catch` blocks in order. By defining custom exception classes (`InputError`, `LogicError`), the program can precisely handle different failure types, executing code specific to the caught exception, which improves error recovery and logging.",
      "code": "#include <iostream>\n#include <string>\n\n// 1. Custom Exception Classes\nclass InputError : public std::exception {\npublic:\n    const char* what() const noexcept override { return \"Input Error: Invalid value provided.\"; }\n};\n\nclass LogicError : public std::exception {\npublic:\n    const char* what() const noexcept override { return \"Logic Error: Condition failed.\"; }\n};\n\nvoid process(int code) {\n    if (code == 1) {\n        throw InputError();\n    } else if (code == 2) {\n        throw LogicError();\n    }\n}\n\nint main() {\n    try {\n        process(1); // Throws InputError\n        // process(2); // If you change this to 2, the LogicError catch block executes\n    } \n    // Catch 1: Handles InputError\n    catch (const InputError& e) {\n        std::cerr << \"Caught Input Error: \" << e.what() << std::endl;\n    }\n    // Catch 2: Handles LogicError\n    catch (const LogicError& e) {\n        std::cerr << \"Caught Logic Error: \" << e.what() << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Condition throws InputError",
        "expected": "Caught Input Error: Input Error: Invalid value provided.\n"
      }
    ]
  },
  {
    "id": 188,
    "title": "Casting: static_cast and dynamic_cast",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate C++ casting: \n1. Use **`static_cast`** to safely cast a `void*` (pointer to memory) back to an `int*`.\n2. Use **`dynamic_cast`** to safely cast a base class pointer (`Parent*`) to a derived class pointer (`Child*`), using a simple inheritance structure with at least one virtual function.",
    "inputFormat": "Internal memory allocation and object creation.",
    "outputFormat": "Print the dereferenced integer value and the success/failure of the dynamic cast.",
    "solution": {
      "explanation": "Casting in C++ is formalized with operators. **`static_cast`** performs compile-time conversions. **`dynamic_cast`** performs run-time checked conversions for polymorphic types (requiring a virtual function in the base class) and returns `nullptr` on failure, ensuring type safety.",
      "code": "#include <iostream>\n\n// --- Dynamic Cast Setup ---\nclass Base {\npublic:\n    virtual void print() { std::cout << \"Base\"; } // Required for dynamic_cast\n    virtual ~Base() {} // Good practice\n};\n\nclass Derived : public Base {\npublic:\n    void print() override { std::cout << \"Derived\"; }\n    void derivedMethod() { std::cout << \" (Derived Method)\"; }\n};\n\nint main() {\n    // 1. Static Cast Demonstration (Void* to int*)\n    int i = 42;\n    void* vptr = &i;\n    int* iptr = static_cast<int*>(vptr);\n    std::cout << \"Static cast result: \" << *iptr << std::endl;\n\n    // 2. Dynamic Cast Demonstration (Safe Downcasting)\n    Base* base_ptr = new Derived(); // Base pointer pointing to Derived object\n    \n    // Attempt to cast base_ptr to Derived*\n    Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);\n    \n    if (derived_ptr) {\n        std::cout << \"Dynamic cast successful: Yes\";\n        derived_ptr->derivedMethod();\n        std::cout << std::endl;\n    } else {\n        std::cout << \"Dynamic cast successful: No\" << std::endl;\n    }\n    \n    delete base_ptr;\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Static Cast to int*, Dynamic Cast Parent* to Child*",
        "expected": "Static cast result: 42\nDynamic cast successful: Yes (Derived Method)\n"
      }
    ]
  },
  {
    "id": 189,
    "title": "Priority Queue (Max Heap)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program to use `std::priority_queue` to implement a **Max Heap**. Insert several integers and then extract the maximum element three times.",
    "inputFormat": "The integers are hardcoded.",
    "outputFormat": "Print the elements extracted from the queue.",
    "solution": {
      "explanation": "By default, **`std::priority_queue<T>`** implements a **Max Heap** (the largest element is always at the top). We use `push()` to insert, `top()` to view the maximum element, and `pop()` to remove it. Both insertion and removal take $O(\\log N)$ time, making it efficient for problems requiring frequent maximum (or minimum) element retrieval.",
      "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nint main() {\n    // Priority Queue (Max Heap by default)\n    std::priority_queue<int> pq;\n    \n    pq.push(10);\n    pq.push(50);\n    pq.push(20);\n    pq.push(40);\n    pq.push(30);\n    \n    // Extract the top 3 elements\n    for (int i = 0; i < 3; ++i) {\n        std::cout << \"Extracted Max: \" << pq.top() << std::endl;\n        pq.pop();\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Insert: 10, 50, 20, 40, 30",
        "expected": "Extracted Max: 50\nExtracted Max: 40\nExtracted Max: 30\n"
      }
    ]
  },
  {
    "id": 190,
    "title": "Two Pointers: Find Pair Sum (Sorted Vector)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Given a **sorted** `std::vector<int>` and a `target`, use the **Two-Pointers** technique to find if a pair exists that sums to the target.",
    "inputFormat": "The vector and target are hardcoded.",
    "outputFormat": "Print the found pair or a failure message.",
    "solution": {
      "explanation": "The **Two-Pointers** technique is an optimal $O(N)$ solution that requires the input vector to be **sorted**. Pointers `left` and `right` start at the opposite ends. If the `currentSum` is less than the target, `left` moves right (seeking a larger value). If the sum is greater than the target, `right` moves left (seeking a smaller value). This movement strategy guarantees that the correct pair is found, if it exists.",
      "code": "#include <iostream>\n#include <vector>\n\nvoid findPairSum(const std::vector<int>& arr, int target) {\n    int left = 0;\n    int right = arr.size() - 1;\n    \n    while (left < right) {\n        int currentSum = arr[left] + arr[right];\n        \n        if (currentSum == target) {\n            std::cout << \"Pair found: (\" << arr[left] << \", \" << arr[right] << \")\" << std::endl;\n            return;\n        } else if (currentSum < target) {\n            left++; // Need a larger sum\n        } else {\n            right--; // Need a smaller sum\n        }\n    }\n    \n    std::cout << \"No pair found.\" << std::endl;\n}\n\nint main() {\n    std::vector<int> arr = {2, 7, 11, 15};\n    int target = 18;\n    \n    findPairSum(arr, target);\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {2, 7, 11, 15}, Target: 18",
        "expected": "Pair found: (7, 11)\n"
      },
      {
        "input": "Vector: {1, 2, 3, 4}, Target: 7",
        "expected": "Pair found: (3, 4)\n"
      },
      {
        "input": "Vector: {1, 2, 3}, Target: 10",
        "expected": "No pair found.\n"
      }
    ]
  },
  {
    "id": 191,
    "title": "N-Queens Problem (Backtracking)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement the **N-Queens Problem** using **Backtracking** in C++ to find and print one valid configuration for an $N=4$ chessboard. Use a `std::vector<std::string>` to represent the board.",
    "inputFormat": "Hardcoded $N=4$.",
    "outputFormat": "Print one valid configuration of the chessboard.",
    "solution": {
      "explanation": "The **N-Queens Problem** is solved using a **backtracking** (recursive) approach. It tries to place one queen per row. The **`isSafe`** function checks for conflicts in the column and both diagonals against all previously placed queens. If a safe position is found, the queen is placed, and the function recurses to the next row. If the recursion fails, the queen is removed (backtracking), and the process tries the next column.",
      "code": "#include <iostream>\n#include <vector>\n#include <string>\n\n// Function to check if a queen can be safely placed at board[row][col]\nbool isSafe(const std::vector<std::string>& board, int row, int col) {\n    int n = board.size();\n    \n    // Check column above\n    for (int i = 0; i < row; ++i) {\n        if (board[i][col] == 'Q') return false;\n    }\n    \n    // Check upper left diagonal\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    // Check upper right diagonal\n    for (int i = row, j = col; i >= 0 && j < n; --i, ++j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    return true;\n}\n\n// Main recursive backtracking function\nbool solve(std::vector<std::string>& board, int row) {\n    int n = board.size();\n    \n    // Base Case: All rows are filled (solution found)\n    if (row == n) {\n        return true;\n    }\n    \n    // Try placing a queen in every column of the current row\n    for (int col = 0; col < n; ++col) {\n        if (isSafe(board, row, col)) {\n            // Place Queen (Choose)\n            board[row][col] = 'Q';\n            \n            // Recurse for the next row\n            if (solve(board, row + 1)) {\n                return true; // Solution found\n            }\n            \n            // Backtrack (Un-choose)\n            board[row][col] = '.';\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    const int N = 4;\n    // Initialize N x N board with '.'\n    std::vector<std::string> board(N, std::string(N, '.')); \n    \n    if (solve(board, 0)) {\n        for (const std::string& row : board) {\n            std::cout << row << std::endl;\n        }\n    } else {\n        std::cout << \"No solution found.\" << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "N=4",
        "expected": ". Q . \n. . . Q \nQ . . \n. . Q \n"
      }
    ]
  },
  {
    "id": 192,
    "title": "Graph BFS (Adjacency List)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement **Breadth-First Search (BFS)** in C++ for an undirected graph using an adjacency list (`std::vector<std::vector<int>>`) and a queue (`std::queue`). Start the traversal from node 0.",
    "inputFormat": "The graph structure is hardcoded.",
    "outputFormat": "Print the visited nodes in BFS order.",
    "solution": {
      "explanation": "**Breadth-First Search (BFS)** explores a graph level by level and uses a **Queue** (`std::queue`) to store nodes to visit. The start node is enqueued, and a `visited` array prevents cycles. In the main loop, a node is dequeued, processed, and all its unvisited neighbors are immediately enqueued. This guarantees that all nodes at depth $k$ are visited before any node at depth $k+1$.",
      "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nvoid bfs(const std::vector<std::vector<int>>& adj, int start) {\n    int V = adj.size();\n    std::vector<bool> visited(V, false);\n    std::queue<int> q;\n    \n    // Start node\n    q.push(start);\n    visited[start] = true;\n    \n    std::cout << \"BFS Traversal: \";\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        std::cout << u << \" \";\n        \n        // Visit all neighbors\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    // Adjacency list for a 5-node graph (0 to 4)\n    std::vector<std::vector<int>> adj = {\n        {1, 2},    // Node 0\n        {0, 3},    // Node 1\n        {0, 4},    // Node 2\n        {1},       // Node 3\n        {2}        // Node 4\n    };\n    \n    bfs(adj, 0);\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Graph: 0-[1, 2], 1-[3], 2-[4]",
        "expected": "BFS Traversal: 0 1 2 3 4 \n"
      }
    ]
  },
  {
    "id": 193,
    "title": "Graph DFS (Recursive)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement a **recursive Depth-First Search (DFS)** function in C++ for an undirected graph using an adjacency list (`std::vector<std::vector<int>>`). Start the traversal from node 0.",
    "inputFormat": "The graph structure is hardcoded.",
    "outputFormat": "Print the visited nodes in DFS order.",
    "solution": {
      "explanation": "**Depth-First Search (DFS)** explores a graph as deep as possible down a path before backtracking. It is most simply implemented using a **recursive function**. The function marks the current node as `visited`, processes it, and then recursively calls itself on each **unvisited neighbor**. The function calls themselves form an implicit stack that drives the depth-first traversal.",
      "code": "#include <iostream>\n#include <vector>\n\nvoid dfsRecursive(const std::vector<std::vector<int>>& adj, int u, std::vector<bool>& visited) {\n    visited[u] = true;\n    std::cout << u << \" \";\n    \n    // Recur for all neighbors\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfsRecursive(adj, v, visited);\n        }\n    }\n}\n\nvoid dfs(const std::vector<std::vector<int>>& adj, int start) {\n    int V = adj.size();\n    std::vector<bool> visited(V, false);\n    \n    std::cout << \"DFS Traversal: \";\n    dfsRecursive(adj, start, visited);\n    std::cout << std::endl;\n}\n\nint main() {\n    // Adjacency list for a 5-node graph (0 to 4)\n    std::vector<std::vector<int>> adj = {\n        {1, 2},    // Node 0\n        {0, 3},    // Node 1\n        {0, 4},    // Node 2\n        {1},       // Node 3\n        {2}        // Node 4\n    };\n    \n    dfs(adj, 0);\n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Graph: 0-[1, 2], 1-[3], 2-[4]",
        "expected": "DFS Traversal: 0 1 3 2 4 \n"
      }
    ]
  },
  {
    "id": 194,
    "title": "Min Heap Priority Queue (Custom Comparator)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program to implement a **Min Heap** using `std::priority_queue`. Since the standard implementation is a Max Heap, you must use a custom comparator (`std::greater<int>`) to reverse the ordering.",
    "inputFormat": "The integers are hardcoded.",
    "outputFormat": "Print the minimum element extracted three times.",
    "solution": {
      "explanation": "To create a **Min Heap** using `std::priority_queue`, we must override the default Max Heap behavior. This is done by specifying a custom comparator, **`std::greater<int>`**. This comparator reverses the ordering logic, forcing the logically *smallest* element to be considered the 'greatest' and placed at the top (`top()`), allowing for efficient extraction of the minimum element in $O(\\log N)$ time.",
      "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n\nint main() {\n    // Min Heap using std::priority_queue:\n    // Syntax: std::priority_queue<Type, Container, Comparator>\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;\n    \n    min_pq.push(10);\n    min_pq.push(50);\n    min_pq.push(20);\n    min_pq.push(40);\n    min_pq.push(30);\n    \n    // Extract the top 3 elements (which are the minimum)\n    for (int i = 0; i < 3; ++i) {\n        std::cout << \"Extracted Min: \" << min_pq.top() << std::endl;\n        min_pq.pop();\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Insert: 10, 50, 20, 40, 30",
        "expected": "Extracted Min: 10\nExtracted Min: 20\nExtracted Min: 30\n"
      }
    ]
  },
  {
    "id": 195,
    "title": "OOP: Polymorphic Vector (Base Pointers)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate **Polymorphism** in a vector. Using the `Shape` class structure from a previous problem (with a virtual `draw()` method), create a `std::vector` of **`Shape*` pointers**. Populate it with pointers to `Circle` and `Square` objects, and then iterate through the vector to call `draw()` polymorphically.",
    "inputFormat": "Internal creation of objects and vector population.",
    "outputFormat": "Print the output of the polymorphic calls.",
    "solution": {
      "explanation": "This is the essence of **Run-time Polymorphism**. A vector of **base class pointers** (`std::vector<Shape*>`) can hold objects of any derived type (`Circle`, `Square`). When the virtual method (`draw()`) is called via the base pointer (`shape->draw()`), the virtual function mechanism ensures the correct derived class method is executed at run-time.",
      "code": "#include <iostream>\n#include <vector>\n\n// Base Class (Virtual required for polymorphism)\nclass Shape {\npublic:\n    virtual void draw() const { std::cout << \"Drawing a generic shape.\" << std::endl; }\n    virtual ~Shape() {} // Good practice for base class\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() const override { std::cout << \"Drawing a Circle.\" << std::endl; }\n};\n\nclass Square : public Shape {\npublic:\n    void draw() const override { std::cout << \"Drawing a Square.\" << std::endl; }\n};\n\nint main() {\n    // Vector of Base Class Pointers\n    std::vector<Shape*> shapes;\n    \n    // Populate with derived objects (using new since Base/Derived pointers are stored)\n    shapes.push_back(new Circle());\n    shapes.push_back(new Square());\n    \n    std::cout << \"Polymorphic Draw Calls:\" << std::endl;\n    \n    // Iterate and call draw() polymorphically\n    for (Shape* shape : shapes) {\n        shape->draw(); \n    }\n    \n    // Memory Cleanup\n    for (Shape* shape : shapes) {\n        delete shape; \n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector of Shape* holding Circle and Square",
        "expected": "Polymorphic Draw Calls:\nDrawing a Circle.\nDrawing a Square.\n"
      }
    ]
  },
  {
    "id": 196,
    "title": "Template Function: Generic Min/Max Pair",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a **Template Function** `findMinMax` that takes a `std::vector` of type `T` and returns a `std::pair<T, T>` containing the minimum and maximum elements in the vector. Demonstrate with integers.",
    "inputFormat": "The vector is hardcoded.",
    "outputFormat": "Print the minimum and maximum pair.",
    "solution": {
      "explanation": "This **Template Function** uses `typename T` to define a function that works generically. It returns a **`std::pair<T, T>`** to combine the minimum and maximum values found during the single-pass linear scan. This demonstrates combining STL containers with template functions for generic, type-safe data handling.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility> // Required for std::pair\n#include <stdexcept> // For runtime_error\n\n// Template function returning a pair of min and max elements\ntemplate <typename T>\nstd::pair<T, T> findMinMax(const std::vector<T>& vec) {\n    if (vec.empty()) {\n        throw std::runtime_error(\"Vector is empty\");\n    }\n    \n    T min_val = vec[0];\n    T max_val = vec[0];\n    \n    for (size_t i = 1; i < vec.size(); ++i) {\n        if (vec[i] < min_val) {\n            min_val = vec[i];\n        }\n        if (vec[i] > max_val) {\n            max_val = vec[i];\n        }\n    }\n    \n    return std::make_pair(min_val, max_val);\n}\n\nint main() {\n    std::vector<int> numbers = {5, 1, 9, 3, 7};\n    \n    try {\n        std::pair<int, int> result = findMinMax(numbers);\n        std::cout << \"Min: \" << result.first << \", Max: \" << result.second << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {5, 1, 9, 3, 7}",
        "expected": "Min: 1, Max: 9\n"
      }
    ]
  },
  {
    "id": 197,
    "title": "Use std::unique and erase to remove duplicates",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program to remove duplicate elements from a `std::vector<int>` using the combination of **`std::sort`**, **`std::unique`**, and **`vector::erase`**.",
    "inputFormat": "The vector is hardcoded.",
    "outputFormat": "Print the vector after removing duplicates.",
    "solution": {
      "explanation": "This is the canonical C++ approach to removing duplicates: 1. **`std::sort`** groups duplicates together. 2. **`std::unique`** moves unique elements to the beginning and returns an iterator to the new logical end. 3. **`vector::erase`** physically removes the elements between the logical end and the true end, resizing the vector. This is known as the erase-remove idiom.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid printVector(const std::vector<int>& vec) {\n    for (int num : vec) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> numbers = {1, 3, 2, 2, 3, 1, 4};\n    \n    // 1. Sort the vector (1 1 2 2 3 3 4)\n    std::sort(numbers.begin(), numbers.end());\n    \n    // 2. Use std::unique: moves unique elements to the front and returns the iterator to the new end\n    // The vector now looks logically like: 1 2 3 4 [garbage]\n    auto last = std::unique(numbers.begin(), numbers.end());\n    \n    // 3. Erase the unwanted elements\n    numbers.erase(last, numbers.end());\n    \n    std::cout << \"Unique Vector: \";\n    printVector(numbers);\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Vector: {1, 3, 2, 2, 3, 1, 4}",
        "expected": "Unique Vector: 1 2 3 4 \n"
      }
    ]
  },
  {
    "id": 198,
    "title": "Matrix Transpose (In-place on square matrix)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ program to perform the **Transpose of a Square Matrix** ($N \\times N$) **in-place** (without using a second matrix). Only swap the necessary elements ($A[i][j]$ with $A[j][i]$) below the main diagonal ($j < i$).",
    "inputFormat": "The $3 \\times 3$ matrix is hardcoded.",
    "outputFormat": "Print the matrix after the in-place transpose.",
    "solution": {
      "explanation": "For an **in-place transpose** of a square matrix, elements are swapped across the main diagonal. The solution uses two nested loops where the inner loop iterates only for $j < i$ (the lower triangle). This ensures that every pair of elements ($A[i][j]$ and $A[j][i]$) is swapped **exactly once**, achieving the $O(N^2)$ operation without requiring extra memory for a secondary matrix.",
      "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid transposeInPlace(std::vector<std::vector<int>>& matrix) {\n    int N = matrix.size();\n    \n    for (int i = 0; i < N; ++i) {\n        // Inner loop: j goes from 0 up to i-1 (only the lower triangle)\n        for (int j = 0; j < i; ++j) {\n            // Swap matrix[i][j] with matrix[j][i]\n            std::swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n}\n\nvoid printMatrix(const std::vector<std::vector<int>>& matrix) {\n    for (const auto& row : matrix) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> A = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    \n    transposeInPlace(A);\n    printMatrix(A);\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "Matrix A={{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}",
        "expected": "1 4 7 \n2 5 8 \n3 6 9 \n"
      }
    ]
  },
  {
    "id": 199,
    "title": "Longest Common Subsequence (DP with Memoization)",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Write a C++ function to find the length of the **Longest Common Subsequence (LCS)** of two strings using **Memoization** (Top-Down Dynamic Programming) with a 2D array to store results.",
    "inputFormat": "The strings are hardcoded.",
    "outputFormat": "Print the length of the LCS.",
    "solution": {
      "explanation": "**Memoization** is a top-down **Dynamic Programming** technique that optimizes recursion. The length of the **LCS** for each subproblem $lcs(i, j)$ is stored in a 2D lookup table (`memo`). Before calculating a value, the function checks the table. If the result is already stored, it is returned immediately, eliminating redundant recursive calls and reducing complexity from exponential to $O(M \\times N)$.",
      "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n// 2D vector for Memoization (initialized to -1)\nstd::vector<std::vector<int>> memo;\n\n// Recursive function with memoization\nint lcsMemoized(const std::string& s1, const std::string& s2, int m, int n) {\n    // Base Case\n    if (m == 0 || n == 0) {\n        return 0;\n    }\n    \n    // Check Memoization Table\n    if (memo[m][n] != -1) {\n        return memo[m][n];\n    }\n    \n    // Case 1: Match\n    if (s1[m - 1] == s2[n - 1]) {\n        memo[m][n] = 1 + lcsMemoized(s1, s2, m - 1, n - 1);\n    }\n    // Case 2: Mismatch\n    else {\n        memo[m][n] = std::max(lcsMemoized(s1, s2, m - 1, n), lcsMemoized(s1, s2, m, n - 1));\n    }\n    \n    return memo[m][n];\n}\n\nint main() {\n    std::string s1 = \"AGGTAB\";\n    std::string s2 = \"GXTXAYB\";\n    int m = s1.length();\n    int n = s2.length();\n    \n    // Initialize memoization table with dimensions (m+1) x (n+1) and fill with -1\n    memo.assign(m + 1, std::vector<int>(n + 1, -1));\n    \n    int result = lcsMemoized(s1, s2, m, n);\n    std::cout << \"LCS Length (Memoized): \" << result << std::endl;\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "s1=AGGTAB, s2=GXTXAYB",
        "expected": "LCS Length (Memoized): 4\n"
      },
      {
        "input": "s1=ABCDE, s2=ACE",
        "expected": "LCS Length (Memoized): 3\n"
      }
    ]
  },
  {
    "id": 200,
    "title": "Union-Find (DSU) Implementation with Optimization",
    "language": "C++",
    "difficulty": "Hard",
    "problemStatement": "Implement the **Union-Find (Disjoint Set Union, DSU) data structure** in C++ using an array to store parent pointers. Include the two major optimizations:\n\n1.  **Path Compression** in the `find` operation.\n2.  **Union by Rank** in the `unite` operation.",
    "inputFormat": "Internal sequence of `unite` and `find` operations on 5 elements (0-4).",
    "outputFormat": "Print the result of the `find` calls and the state of the parent array.",
    "solution": {
      "explanation": "This DSU implementation achieves near-constant time complexity $O(\\alpha(N))$ using two optimizations:\n\n1.  **Path Compression (in `find`):** When finding the root, every node encountered is updated to point directly to the root, flattening the tree.\n2.  **Union by Rank (in `unite`):** The smaller tree (lower rank) is always attached to the root of the larger tree, minimizing the overall tree height and ensuring fast future `find` operations.",
      "code": "#include <iostream>\n#include <vector>\n#include <numeric> // For std::iota\n\nclass DSU {\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank; // Use 'rank' for union by rank optimization\n\npublic:\n    DSU(int n) {\n        parent.resize(n);\n        std::iota(parent.begin(), parent.end(), 0); // Initializes parent[i] = i\n        rank.assign(n, 0);\n    }\n\n    // Find with Path Compression\n    int find(int i) {\n        if (parent[i] == i) {\n            return i;\n        }\n        // Path Compression: Set parent[i] directly to the root\n        return parent[i] = find(parent[i]);\n    }\n\n    // Union by Rank\n    void unite(int i, int j) {\n        int root_i = find(i);\n        int root_j = find(j);\n\n        if (root_i != root_j) {\n            // Union by Rank: Attach smaller rank tree under root of higher rank tree\n            if (rank[root_i] < rank[root_j]) {\n                parent[root_i] = root_j;\n            } else if (rank[root_i] > rank[root_j]) {\n                parent[root_j] = root_i;\n            } else {\n                // If ranks are the same, make one the root and increment its rank\n                parent[root_j] = root_i;\n                rank[root_i]++;\n            }\n        }\n    }\n    \n    void printRanks() const {\n        std::cout << \"Final Ranks: \";\n        for(int r : rank) std::cout << r << \" \";\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    DSU dsu(5); // Elements 0, 1, 2, 3, 4\n    \n    dsu.unite(0, 1);\n    dsu.unite(2, 3);\n    dsu.unite(1, 4);\n    \n    std::cout << \"Representative of 4: \" << dsu.find(4) << std::endl;\n    std::cout << \"Representative of 0: \" << dsu.find(0) << std::endl; // Should point to the final root\n    \n    return 0;\n}"
    },
    "testCases": [
      {
        "input": "unite(0, 1), unite(2, 3), unite(1, 4)",
        "expected": "Representative of 4: 4\nRepresentative of 0: 4\n"
      }
    ]
  },
  {
    "id": 201,
    "title": "Basic Console Output",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Write a JavaScript program that prints the standard greeting: \"Hello, JavaScript!\".",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the specified greeting.",
    "solution": {
      "explanation": "The standard function for writing output to the console in JavaScript environments (browser, Node.js) is **`console.log()`**. This function accepts one or more arguments, converts them to a string representation, and prints them followed by a newline character.",
      "code": "console.log(\"Hello, JavaScript!\");"
    },
    "testCases": [
      {
        "input": "No input.",
        "expected": "Hello, JavaScript!\n"
      }
    ]
  },
  {
    "id": 202,
    "title": "Variable Declaration and Sum",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Declare two constants, `a` and `b`, with values 10 and 5, respectively. Calculate their sum and print the result. Use the `const` keyword.",
    "inputFormat": "No user input required.",
    "outputFormat": "The program must print the sum.",
    "solution": {
      "explanation": "The **`const`** keyword is the preferred way to declare variables in modern JavaScript when the variable's reference should not be reassigned. The arithmetic **`+`** operator performs simple addition. Template literals (backticks) combined with **string interpolation** (`${}`) are used for clear output.",
      "code": "const a = 10;\nconst b = 5;\nconst sum = a + b;\n\nconsole.log(`Sum: ${sum}`);"
    },
    "testCases": [
      {
        "input": "a=10, b=5",
        "expected": "Sum: 15\n"
      }
    ]
  },
  {
    "id": 203,
    "title": "Basic Function Definition",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Write a function `multiply(x, y)` that takes two numbers and returns their product. Call the function with 6 and 7, and print the result.",
    "inputFormat": "Internal function call.",
    "outputFormat": "The program must print the product.",
    "solution": {
      "explanation": "A standard function definition using the **`function`** keyword is used here. It takes two parameters and returns their product using the **`return`** keyword.",
      "code": "function multiply(x, y) {\n    return x * y;\n}\n\nconst result = multiply(6, 7);\nconsole.log(`Result: ${result}`);"
    },
    "testCases": [
      {
        "input": "multiply(6, 7)",
        "expected": "Result: 42\n"
      }
    ]
  },
  {
    "id": 204,
    "title": "Arrow Function (ES6)",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Define an **arrow function** named `subtract` that takes two parameters, `a` and `b`, and returns $a - b$. Use it to calculate $20 - 5$.",
    "inputFormat": "Internal function call.",
    "outputFormat": "The program must print the result.",
    "solution": {
      "explanation": "**Arrow functions** (`=>`) provide a concise syntax, introduced in ES6, for defining functions. For single-expression arrow functions, the **`return`** keyword and the curly braces are **implicit**, allowing the entire function logic to be written on one line for simplicity.",
      "code": "const subtract = (a, b) => a - b;\n\nconst result = subtract(20, 5);\nconsole.log(`Result: ${result}`);"
    },
    "testCases": [
      {
        "input": "20 - 5",
        "expected": "Result: 15\n"
      }
    ]
  },
  {
    "id": 205,
    "title": "Ternary Operator (Conditional)",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Given a score of 75, use the **ternary operator** to determine if the student passed (score $\\ge$ 70). Print 'Passed' or 'Failed'.",
    "inputFormat": "score = 75",
    "outputFormat": "The program must print the conditional result.",
    "solution": {
      "explanation": "The **Ternary Operator** is a single-line conditional operator with the format `condition ? value_if_true : value_if_false`. It is a compact and expressive alternative to an `if-else` statement when assigning a value based on a simple boolean condition.",
      "code": "const score = 75;\nconst status = score >= 70 ? 'Passed' : 'Failed';\n\nconsole.log(`Status: ${status}`);"
    },
    "testCases": [
      {
        "input": "score = 75",
        "expected": "Status: Passed\n"
      },
      {
        "input": "score = 69",
        "expected": "Status: Failed\n"
      }
    ]
  },
  {
    "id": 206,
    "title": "Array Iteration (for...of)",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Given an array of fruits, `['apple', 'banana', 'cherry']`, iterate over the array using the **`for...of`** loop and print each fruit.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print each element on a new line.",
    "solution": {
      "explanation": "The **`for...of`** loop is the standard, modern JavaScript mechanism for iterating directly over the **values** of iterable objects, such as Arrays, Strings, Maps, and Sets. It provides a cleaner syntax compared to traditional `for` loops or `for...in` loops (which iterate over keys/indices).",
      "code": "const fruits = ['apple', 'banana', 'cherry'];\n\nfor (const fruit of fruits) {\n    console.log(fruit);\n}"
    },
    "testCases": [
      {
        "input": "['apple', 'banana', 'cherry']",
        "expected": "apple\nbanana\ncherry\n"
      }
    ]
  },
  {
    "id": 207,
    "title": "Object Literal and Destructuring",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Define an object `user` with keys `id`, `name`, and `email`. Use **object destructuring** to extract the `name` and `email` properties into separate constants and print them.",
    "inputFormat": "Hardcoded object.",
    "outputFormat": "The program must print the name and email.",
    "solution": {
      "explanation": "**Object Destructuring** is a powerful ES6 feature that allows extracting multiple properties from an object and assigning them to distinct variables using a single concise expression. The variable names must match the property keys being extracted (`{ name, email } = user`).",
      "code": "const user = {\n    id: 1,\n    name: 'Alice',\n    email: 'a@test.com'\n};\n\n// Destructuring assignment\nconst { name, email } = user;\n\nconsole.log(`Name: ${name}, Email: ${email}`);"
    },
    "testCases": [
      {
        "input": "user = {id: 1, name: 'Alice', email: 'a@test.com'}",
        "expected": "Name: Alice, Email: a@test.com\n"
      }
    ]
  },
  {
    "id": 208,
    "title": "Array Map (Transform)",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Given an array of numbers `[1, 2, 3, 4, 5]`, use the **`.map()`** method to create a new array where each number is doubled. Print the new array.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the new array.",
    "solution": {
      "explanation": "The **`.map()`** method is the standard functional approach to transform every element in an array and return a brand **new array** of the same length.",
      "code": "const numbers = [1, 2, 3, 4, 5];\n\n// Use map to return a new array with doubled values\nconst doubled = numbers.map(num => num * 2);\n\nconsole.log(doubled);"
    },
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expected": "[2, 4, 6, 8, 10]\n"
      }
    ]
  },
  {
    "id": 209,
    "title": "Array Filter (Select)",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Given an array of temperatures `[10, 25, 30, 8, 15]`, use the **`.filter()`** method to create a new array containing only temperatures above 20. Print the new array.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the new array.",
    "solution": {
      "explanation": "The **`.filter()`** method executes a callback function on every element and creates a **new array** containing only the elements for which the callback returns a **truthy** value. It is the standard functional method for selecting or refining a subset of data from an array.",
      "code": "const temps = [10, 25, 30, 8, 15];\n\n// Use filter to keep only temps > 20\nconst hotTemps = temps.filter(temp => temp > 20);\n\nconsole.log(hotTemps);"
    },
    "testCases": [
      {
        "input": "[10, 25, 30, 8, 15]",
        "expected": "[25, 30]\n"
      },
      {
        "input": "[1, 5, 10]",
        "expected": "[]\n"
      }
    ]
  },
  {
    "id": 210,
    "title": "Array Reduce (Accumulate)",
    "language": "JavaScript",
    "difficulty": "Easy",
    "problemStatement": "Given an array of prices `[10.50, 5.00, 2.00]`, use the **`.reduce()`** method to calculate the total sum of all prices. Print the result.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the total sum.",
    "solution": {
      "explanation": "The **`.reduce()`** method applies a callback function against an accumulator and each element in the array to reduce it to a single value. The second argument, `0`, initializes the accumulator (the running total).",
      "code": "const prices = [10.50, 5.00, 2.00];\n\n// Use reduce to accumulate the total sum\nconst total = prices.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n\nconsole.log(`Total: ${total}`);"
    },
    "testCases": [
      {
        "input": "[10.50, 5.00, 2.00]",
        "expected": "Total: 17.5\n"
      }
    ]
  },
  {
    "id": 211,
    "title": "Set Creation and Uniqueness",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Given a list with duplicates, `[1, 2, 2, 3, 4, 4, 5]`, use the **`Set`** object to remove all duplicates and convert the result back to an array. Print the unique array.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the unique array.",
    "solution": {
      "explanation": "The **`Set`** object is the standard way in JavaScript to enforce uniqueness, as it only stores distinct values. The **spread operator** (`...`) is then used to convert the set back into a standard array, effectively removing all duplicates in one concise, functional expression.",
      "code": "const data = [1, 2, 2, 3, 4, 4, 5];\n\n// 1. Create a Set from the array (removes duplicates)\nconst uniqueSet = new Set(data);\n\n// 2. Convert the Set back to an Array\nconst uniqueArray = [...uniqueSet];\n\nconsole.log(uniqueArray);"
    },
    "testCases": [
      {
        "input": "[1, 2, 2, 3, 4, 4, 5]",
        "expected": "[1, 2, 3, 4, 5]\n"
      }
    ]
  },
  {
    "id": 212,
    "title": "Object Spread Operator (Merging)",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Given two objects, `user = {name: 'Alice', age: 30}` and `updates = {age: 31, city: 'NY'}`, merge them using the **spread operator (`...`)** to create a single object where properties in `updates` overwrite `user` properties.",
    "inputFormat": "Hardcoded objects.",
    "outputFormat": "The program must print the merged object.",
    "solution": {
      "explanation": "The **Spread Operator** (`...`) is used within an object literal to merge two or more objects. Since object keys must be unique, any properties from the object that is **spread last** (`updates`) will overwrite conflicting properties from preceding objects (`user`), making the order of spreading significant.",
      "code": "const user = { name: 'Alice', age: 30 };\nconst updates = { age: 31, city: 'NY' };\n\n// Spread user, then spread updates (updates overwrites user)\nconst merged = { ...user, ...updates };\n\nconsole.log(merged);"
    },
    "testCases": [
      {
        "input": "user and updates",
        "expected": "{ name: 'Alice', age: 31, city: 'NY' }\n"
      }
    ]
  },
  {
    "id": 213,
    "title": "Template Literals and Interpolation",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Given variables `product` and `price`, use a **template literal** (backticks) and **string interpolation** (`${}`) to print a sentence describing the product and its price.",
    "inputFormat": "Hardcoded variables.",
    "outputFormat": "The program must print the formatted string.",
    "solution": {
      "explanation": "**Template Literals** are strings enclosed by **backticks** (\\`) and allow for **string interpolation** using the syntax **`${expression}`**. This is the modern, readable, and highly recommended way to embed variable values or JavaScript expressions directly into a string, eliminating the need for string concatenation (`+`).",
      "code": "const product = 'Laptop';\nconst price = 1200;\n\n// Use backticks and ${} for interpolation\nconst message = `The ${product} costs $${price}.`;\n\nconsole.log(message);"
    },
    "testCases": [
      {
        "input": "product = 'Laptop', price = 1200",
        "expected": "The Laptop costs $1200.\n"
      }
    ]
  },
  {
    "id": 214,
    "title": "Asynchronous: setTimeout (Delay)",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Write a JavaScript program that uses **`setTimeout`** to print the message 'Delayed message' after a 1-second delay. Ensure the message 'Start' is printed immediately and 'End' is printed after 1 second.",
    "inputFormat": "No user input required.",
    "outputFormat": "Start\nEnd\nDelayed message",
    "solution": {
      "explanation": "This demonstrates JavaScript's **asynchronous** nature. **`setTimeout`** schedules the callback to run after the specified delay, but it does not block the main thread. The synchronous code (`console.log('End')`) executes immediately after `setTimeout` returns, while the callback waits in the **Macrotask Queue** to be processed later by the Event Loop.",
      "code": "console.log('Start');\n\n// Schedule the function to run after 1000 milliseconds (1 second)\nsetTimeout(() => {\n    console.log('Delayed message');\n}, 1000);\n\n// This line executes immediately, before the setTimeout callback\nconsole.log('End');"
    },
    "testCases": [
      {
        "input": "Internal calls",
        "expected": "Start\nEnd\nDelayed message\n"
      }
    ]
  },
  {
    "id": 215,
    "title": "Closure: Counter Function",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Write a function `createCounter()` that returns an inner function. The inner function, when called, should increment a private counter variable by 1 and return the new value. Use the concept of a **closure** to maintain the counter's state.",
    "inputFormat": "Internal calls to the created counter function.",
    "outputFormat": "The program must print the counter values after two calls.",
    "solution": {
      "explanation": "A **Closure** is created when an inner function (the returned function) retains access to the variables (`count`) from its outer lexical scope, even after the outer function (`createCounter`) has finished executing. This mechanism is used to create **private variables** that can only be accessed or modified by the returned methods, enforcing encapsulation.",
      "code": "function createCounter() {\n    let count = 0; // Private state variable\n    \n    // The inner function closes over the 'count' variable\n    return function() {\n        count = count + 1;\n        return count;\n    };\n}\n\nconst counter = createCounter();\n\nconsole.log(`Count 1: ${counter()}`);\nconsole.log(`Count 2: ${counter()}`);"
    },
    "testCases": [
      {
        "input": "counter(), counter()",
        "expected": "Count 1: 1\nCount 2: 2\n"
      }
    ]
  },
  {
    "id": 216,
    "title": "Higher-Order Function (Logger)",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Write a **Higher-Order Function (HOF)** named `withLogging(fn)` that takes a function `fn` and returns a new function that logs the function's arguments and result before and after execution. Apply it to a simple `add(a, b)` function.",
    "inputFormat": "Internal call to the decorated `loggedAdd` function.",
    "outputFormat": "Print the log messages and the final result.",
    "solution": {
      "explanation": "A **Higher-Order Function (HOF)** is a function that either takes a function as an argument or returns a function. `withLogging` is a HOF that takes a function (`fn`) and returns a new **wrapper** function. This wrapper executes the original function while adding new behavior (logging the input and output) around it, without modifying the original `add` function.",
      "code": "function add(a, b) {\n    return a + b;\n}\n\nfunction withLogging(fn) {\n    return function(...args) {\n        console.log(`Calling ${fn.name} with args: ${args.join(', ')}`);\n        const result = fn(...args);\n        console.log(`Result: ${result}`);\n        return result;\n    };\n}\n\nconst loggedAdd = withLogging(add);\n\nconst finalResult = loggedAdd(5, 3);\nconsole.log(`Final result: ${finalResult}`);"
    },
    "testCases": [
      {
        "input": "loggedAdd(5, 3)",
        "expected": "Calling add with args: 5, 3\nResult: 8\nFinal result: 8\n"
      }
    ]
  },
  {
    "id": 217,
    "title": "String Reversal (Array Methods)",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Write a function `reverseString(str)` that reverses a string using three core Array methods: **`.split()`**, **`.reverse()`**, and **`.join()`**.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print the reversed string.",
    "solution": {
      "explanation": "This method chains together three functions: 1. **`.split('')`** turns the string into an array of characters. 2. **`.reverse()`** reverses the array in-place. 3. **`.join('')`** stitches the characters back into a string. This is the idiomatic, functional way to reverse a string in JavaScript.",
      "code": "function reverseString(str) {\n    // 1. Split the string into an array of characters\n    const charArray = str.split('');\n    \n    // 2. Reverse the array\n    const reversedArray = charArray.reverse();\n    \n    // 3. Join the array back into a string\n    const reversedString = reversedArray.join('');\n    \n    return reversedString;\n}\n\nconsole.log(reverseString(\"javascript\"));"
    },
    "testCases": [
      {
        "input": "javascript",
        "expected": "tpircsavaj\n"
      }
    ]
  },
  {
    "id": 218,
    "title": "Max Element in Array (Reduce)",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Given an array of numbers `[10, 5, 20, 8, 15]`, use the **`.reduce()`** method to find and return the maximum element.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the maximum element.",
    "solution": {
      "explanation": "The reducer function compares the current accumulator (`max`) with the current array element (`current`). It returns the larger of the two, effectively carrying the maximum value found so far to the next iteration. This allows the maximum element to be found in a single pass.",
      "code": "const numbers = [10, 5, 20, 8, 15];\n\n// Use reduce to find the max element\nconst max = numbers.reduce((max, current) => {\n    return current > max ? current : max; // Equivalent to Math.max(max, current)\n});\n\nconsole.log(`Max: ${max}`);"
    },
    "testCases": [
      {
        "input": "[10, 5, 20, 8, 15]",
        "expected": "Max: 20\n"
      }
    ]
  },
  {
    "id": 219,
    "title": "Count Vowels",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Write a function that counts the number of vowels (a, e, i, o, u, case-insensitive) in a given string. Use regular expressions (`.match()` with a global and case-insensitive flag).",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print the count of vowels.",
    "solution": {
      "explanation": "The most effective solution uses a **Regular Expression** (`/[aeiou]/gi`) with the global (`g`) and case-insensitive (`i`) flags. The **`.match()`** method, when used with the global flag, returns an array of all matches. The length of this array (or 0 if `match` returns `null`) gives the total count of vowels.",
      "code": "function countVowels(str) {\n    // Regex: find any vowel (a, e, i, o, u) globally (g) and case-insensitively (i)\n    const matches = str.match(/[aeiou]/gi);\n    \n    // If no matches, .match() returns null, so we return 0. Otherwise, return the length of the array.\n    return matches ? matches.length : 0;\n}\n\nconsole.log(`Vowel Count: ${countVowels('Programming')}`);"
    },
    "testCases": [
      {
        "input": "Programming",
        "expected": "Vowel Count: 4\n"
      },
      {
        "input": "AEIOUaeiou",
        "expected": "Vowel Count: 10\n"
      },
      {
        "input": "XYZ",
        "expected": "Vowel Count: 0\n"
      }
    ]
  },
  {
    "id": 220,
    "title": "Check Anagrams (Frequency Map)",
    "language": "JavaScript",
    "difficulty": "Medium",
    "problemStatement": "Write a function `areAnagrams(s1, s2)` that checks if two strings are anagrams of each other. Use a **frequency map (object)** to store character counts for efficient comparison.",
    "inputFormat": "The strings are hardcoded.",
    "outputFormat": "The program must print the boolean result.",
    "solution": {
      "explanation": "To check if two strings are anagrams, their character frequency counts must be identical. This approach uses a **Frequency Map (Object)** for each string to store the counts of each character (after cleaning and lowercasing). The final check compares the keys and values of the two maps. If the map sizes are unequal or any corresponding count is different, they are not anagrams.",
      "code": "function cleanString(str) {\n    return str.replace(/[^\\w]/g, '').toLowerCase();\n}\n\nfunction getCharMap(str) {\n    const charMap = {};\n    for (let char of cleanString(str)) {\n        charMap[char] = charMap[char] + 1 || 1;\n    }\n    return charMap;\n}\n\nfunction areAnagrams(s1, s2) {\n    const map1 = getCharMap(s1);\n    const map2 = getCharMap(s2);\n    \n    if (Object.keys(map1).length !== Object.keys(map2).length) {\n        return false;\n    }\n    \n    for (let char in map1) {\n        if (map1[char] !== map2[char]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(`Are Anagrams: ${areAnagrams('listen', 'silent')}`);"
    },
    "testCases": [
      {
        "input": "listen, silent",
        "expected": "Are Anagrams: true\n"
      },
      {
        "input": "Debit Card, Bad Credit",
        "expected": "Are Anagrams: true\n"
      },
      {
        "input": "hello, world",
        "expected": "Are Anagrams: false\n"
      }
    ]
  },
  {
    "id": 221,
    "title": "Two Sum Problem (Hash Map)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array of numbers `[2, 7, 11, 15]` and a `target` of 9, find the indices of the two numbers that add up to the target. Implement this using a **Map (Hash Map)** for $O(N)$ complexity.",
    "inputFormat": "Hardcoded array and target.",
    "outputFormat": "The program must print the indices as an array.",
    "solution": {
      "explanation": "The most efficient solution is $O(N)$ using a **Map (Hash Table)**. For each number (`current`), we calculate the `complement` (`target - current`). We check if this `complement` is already in the map. If it is, the indices are returned. If not, the current number and its index are stored in the map, ready to be the complement for a subsequent number.",
      "code": "function twoSum(nums, target) {\n    const map = new Map(); // Stores: (complement, index)\n    \n    for (let i = 0; i < nums.length; i++) {\n        const current = nums[i];\n        const complement = target - current;\n        \n        // Check if the required complement is already stored\n        if (map.has(complement)) {\n            // Complement found! Return its index and the current index\n            return [map.get(complement), i];\n        }\n        \n        // Store the current number and its index\n        map.set(current, i);\n    }\n    // Fallback if no solution found\n    return [];\n}\n\nconst nums = [2, 7, 11, 15];\nconsole.log(twoSum(nums, 9));"
    },
    "testCases": [
      {
        "input": "[2, 7, 11, 15], target = 9",
        "expected": "[0, 1]\n"
      },
      {
        "input": "[3, 2, 4], target = 6",
        "expected": "[1, 2]\n"
      },
      {
        "input": "[1, 5, 8], target = 10",
        "expected": "[0, 2]\n"
      }
    ]
  },
  {
    "id": 222,
    "title": "Sliding Window: Max Sum of Size K",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array `[1, 4, 2, 10, 23, 3, 1, 0, 20]` and a window size `K=4`, find the maximum sum of any contiguous subarray of size K using the **Sliding Window** technique.",
    "inputFormat": "Hardcoded array and K=4.",
    "outputFormat": "The program must print the maximum sum.",
    "solution": {
      "explanation": "The **Sliding Window** technique provides an $O(N)$ solution by calculating the initial window sum once. Then, for each step, it performs an $O(1)$ update: **subtracting the element that leaves** the window (`arr[i-K]`) and **adding the element that enters** the window (`arr[i]`). This avoids re-iterating over the window elements, achieving optimal linear time.",
      "code": "function maxSubarraySum(arr, K) {\n    if (K > arr.length) return 0;\n\n    // 1. Calculate sum of the initial window\n    let currentSum = 0;\n    for (let i = 0; i < K; i++) {\n        currentSum += arr[i];\n    }\n\n    let maxSum = currentSum;\n\n    // 2. Slide the window\n    for (let i = K; i < arr.length; i++) {\n        // currentSum = currentSum - arr[element leaving] + arr[element entering]\n        currentSum = currentSum - arr[i - K] + arr[i];\n        \n        maxSum = Math.max(maxSum, currentSum);\n    }\n\n    return maxSum;\n}\n\nconst arr = [1, 4, 2, 10, 23, 3, 1, 0, 20];\nconsole.log(`Max Sum: ${maxSubarraySum(arr, 4)}`);"
    },
    "testCases": [
      {
        "input": "K=4",
        "expected": "Max Sum: 38\n"
      },
      {
        "input": "arr = [10, 5, 2, 7, 8], K=3",
        "expected": "Max Sum: 17\n"
      }
    ]
  },
  {
    "id": 223,
    "title": "Promises: Basic Resolve/Reject",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Create a function `checkStatus()` that returns a **`Promise`**. The promise should randomly resolve with a success message 70% of the time and reject with an error message 30% of the time. Use `.then()` and `.catch()` to handle the result.",
    "inputFormat": "Internal function call.",
    "outputFormat": "The program must print the resolved or rejected message.",
    "solution": {
      "explanation": "A **`Promise`** represents a value that may be available now, later, or never. The function accepts `resolve` and `reject` callbacks. Based on the random number, we call either `resolve(value)` for success or `reject(reason)` for failure. This demonstrates the foundation of modern JavaScript asynchronous control flow.",
      "code": "function checkStatus() {\n    return new Promise((resolve, reject) => {\n        const success = Math.random() > 0.3; // 70% chance of success\n        \n        if (success) {\n            setTimeout(() => resolve(\"Status check passed!\"), 500);\n        } else {\n            setTimeout(() => reject(\"Status check failed: Timeout\"), 500);\n        }\n    });\n}\n\ncheckStatus()\n    .then(result => console.log(`Success: ${result}`))\n    .catch(error => console.log(`Error: ${error}`));"
    },
    "testCases": [
      {
        "input": "Internal function call",
        "expected": "Success: Status check passed!\n"
      }
    ]
  },
  {
    "id": 224,
    "title": "Async/Await with Promises",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Refactor the Promise logic from the previous problem into an `async` function named `runProcess()`. Use the **`await`** keyword to wait for the Promise result and a **`try-catch`** block to handle rejection.",
    "inputFormat": "Internal call to `runProcess()`.",
    "outputFormat": "The program must print the result or the error message.",
    "solution": {
      "explanation": "The **`async/await`** syntax provides a clean, synchronous-looking way to work with Promises. The **`await`** keyword pauses the execution of the `async` function until the Promise resolves. Rejections (errors) are naturally handled by a standard **`try-catch`** block surrounding the `await` call.",
      "code": "function mockPromise() {\n    return new Promise((resolve, reject) => {\n        const success = Math.random() > 0.3;\n        setTimeout(() => {\n            if (success) resolve(\"Data fetched successfully\");\n            else reject(\"API error occurred\");\n        }, 500);\n    });\n}\n\nasync function runProcess() {\n    try {\n        console.log(\"Fetching data...\");\n        // 'await' pauses here until the Promise resolves or rejects\n        const result = await mockPromise(); \n        console.log(`Result: ${result}`);\n    } catch (error) {\n        // Catch handles the Promise rejection\n        console.error(`Caught Error: ${error}`);\n    }\n}\n\nrunProcess();"
    },
    "testCases": [
      {
        "input": "Internal call",
        "expected": "Fetching data...\nResult: Data fetched successfully\n"
      }
    ]
  },
  {
    "id": 225,
    "title": "Closures for Private Object Methods",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Use a function factory to create a **Closure-based `Wallet` object**. The wallet should have a private variable `balance` (initial 100) and public methods `deposit(amount)` and `getBalance()`. Demonstrate that `balance` is not directly accessible.",
    "inputFormat": "Internal wallet manipulation.",
    "outputFormat": "Print the balance after deposit and the failed attempt to access the private balance.",
    "solution": {
      "explanation": "This utilizes a **Closure** to create true **data privacy**. The `balance` variable is local to the outer function's scope. The returned object's methods are closures that can access `balance`, but external code cannot, creating privacy and enforcing strict encapsulation.",
      "code": "function createWallet(initialBalance) {\n    let balance = initialBalance; // Private variable via closure\n    \n    return {\n        deposit: (amount) => {\n            balance += amount;\n        },\n        getBalance: () => {\n            return balance;\n        }\n    };\n}\n\nconst wallet = createWallet(100);\nwallet.deposit(50);\n\nconsole.log(`New Balance: ${wallet.getBalance()}`);\n// Attempt to access the private variable directly\nconsole.log(`Private access failed: ${wallet.balance}`);"
    },
    "testCases": [
      {
        "input": "Deposit 50",
        "expected": "New Balance: 150\nPrivate access failed: undefined\n"
      }
    ]
  },
  {
    "id": 226,
    "title": "Class and `this` Keyword",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Define a class `Circle` with a constructor that takes `radius`. Add a method `getArea()` that calculates the area ($\\pi \\times r^2$). Use the **`this`** keyword to access the `radius` property inside `getArea()`.",
    "inputFormat": "Internal creation of a `Circle` object.",
    "outputFormat": "The program must print the calculated area.",
    "solution": {
      "explanation": "In a JavaScript class method, the **`this`** keyword refers to the instance of the object on which the method was called. It is essential for accessing properties defined in the constructor (`this.radius`) or other methods that belong to that specific instance.",
      "code": "class Circle {\n    constructor(radius) {\n        this.radius = radius;\n    }\n    \n    getArea() {\n        // 'this.radius' refers to the instance's property\n        return Math.PI * this.radius * this.radius;\n    }\n}\n\nconst circle = new Circle(5);\nconsole.log(`Area: ${circle.getArea()}`);"
    },
    "testCases": [
      {
        "input": "radius = 5",
        "expected": "Area: 78.53981633974483\n"
      }
    ]
  },
  {
    "id": 227,
    "title": "OOP: Static Method",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Define a class `MathUtility`. Add a **`static`** method `add(a, b)` that takes two numbers and returns their sum. Call this method directly on the class itself, without creating an instance.",
    "inputFormat": "Internal call to `MathUtility.add(10, 5)`.",
    "outputFormat": "The program must print the result.",
    "solution": {
      "explanation": "Static methods belong to the class itself, not to any specific instance. They are declared using the **`static`** keyword and are called directly on the class (`MathUtility.add(...)`). Static methods are typically used for utility functions that don't depend on the object's instance data.",
      "code": "class MathUtility {\n    // Static method\n    static add(a, b) {\n        return a + b;\n    }\n}\n\n// Call the static method directly on the class\nconst result = MathUtility.add(10, 5);\nconsole.log(`Static Sum: ${result}`);"
    },
    "testCases": [
      {
        "input": "10 + 5",
        "expected": "Static Sum: 15\n"
      }
    ]
  },
  {
    "id": 228,
    "title": "Inheritance and `super`",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Define a parent class `Animal` with a constructor that takes `name` and a method `speak()`. Define a child class `Dog` that **`extends`** `Animal`. The `Dog` constructor must call the parent constructor using **`super()`** and then define a `Dog` specific method `wagTail()`.",
    "inputFormat": "Internal creation of a `Dog` object.",
    "outputFormat": "Print the output of `speak()` and `wagTail()`.",
    "solution": {
      "explanation": "The **`extends`** keyword sets up the inheritance chain. The child's constructor **must** call **`super(name)`** as its first line. This executes the parent class (`Animal`) constructor, which is responsible for initializing properties shared across the hierarchy (like `this.name`) before the child's own logic runs.",
      "code": "class Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    speak() {\n        console.log(`${this.name} makes a sound.`);\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name) {\n        // Call the parent's constructor\n        super(name);\n    }\n    wagTail() {\n        console.log(`${this.name} wags tail.`);\n    }\n}\n\nconst dog = new Dog('Buddy');\ndog.speak();\ndog.wagTail();"
    },
    "testCases": [
      {
        "input": "Dog('Buddy')",
        "expected": "Buddy makes a sound.\nBuddy wags tail.\n"
      }
    ]
  },
  {
    "id": 229,
    "title": "Prototype Chain and Inheritance",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate classical JavaScript **Prototype Inheritance**. Define a constructor function `Car(model)` and add a method `drive` to its **prototype**. Create an object using `new` and call the prototypal method.",
    "inputFormat": "Internal object creation.",
    "outputFormat": "The program must print the output of the `drive()` method.",
    "solution": {
      "explanation": "Before ES6 classes, inheritance was achieved by manipulating the **prototype chain**. Methods are added to the constructor function's **`.prototype`** property. Every object created with `new Car()` inherits these methods, and when a method is called (`myCar.drive()`), the JavaScript engine looks up the chain until it finds the method on the `Car.prototype`.",
      "code": "function Car(model) {\n    this.model = model;\n}\n\n// Add the method to the prototype\nCar.prototype.drive = function() {\n    console.log(`${this.model} is driving.`);\n};\n\nconst myCar = new Car('Tesla');\nmyCar.drive(); // The object finds 'drive' on its prototype"
    },
    "testCases": [
      {
        "input": "Car('Tesla')",
        "expected": "Tesla is driving.\n"
      }
    ]
  },
  {
    "id": 230,
    "title": "Promise.all for concurrent tasks",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Create three mock Promises that resolve after 1s, 2s, and 3s, respectively. Use **`Promise.all()`** to wait for all three promises to resolve concurrently. Print the array of results and the total time elapsed (should be close to 3s).",
    "inputFormat": "Internal promise creation.",
    "outputFormat": "The program must print the final array of results.",
    "solution": {
      "explanation": "**`Promise.all()`** executes an array of promises concurrently (in parallel). It resolves only when **all** promises in the array have successfully resolved. Crucially, the total time elapsed is determined by the **slowest** promise in the array, demonstrating concurrent execution rather than sequential execution.",
      "code": "function delay(time, value) {\n    return new Promise(resolve => setTimeout(() => resolve(value), time * 1000));\n}\n\n// Array of promises\nconst promises = [\n    delay(1, 1), \n    delay(2, 2), \n    delay(3, 3) // Longest promise determines the total time\n];\n\nconsole.time('Promise.all Time');\n\nPromise.all(promises)\n    .then(results => {\n        console.log(`All promises resolved: ${results}`);\n        console.timeEnd('Promise.all Time');\n    })\n    .catch(error => console.error(\"A promise rejected.\"));"
    },
    "testCases": [
      {
        "input": "Promises: 1s, 2s, 3s",
        "expected": "Promise.all Time: 3.xxxms\nAll promises resolved: 1, 2, 3\n"
      }
    ]
  },
  {
    "id": 231,
    "title": "Reverse Words in a Sentence",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a function `reverseWords(sentence)` that reverses the order of words in a sentence (e.g., 'hello world' becomes 'world hello'). Use array methods (`split`, `reverse`, `join`).",
    "inputFormat": "The sentence is hardcoded.",
    "outputFormat": "The program must print the reversed sentence.",
    "solution": {
      "explanation": "This functional solution reverses the order of words by treating the sentence as an array of words: 1. **`.split(' ')`** separates the sentence into words using the space delimiter. 2. **`.reverse()`** inverts the order of the word array. 3. **`.join(' ')`** stitches the words back together into a single sentence using a space delimiter.",
      "code": "function reverseWords(sentence) {\n    // 1. Split the sentence into an array of words\n    const words = sentence.split(' ');\n    \n    // 2. Reverse the order of words\n    const reversedWords = words.reverse();\n    \n    // 3. Join the words back into a sentence\n    const reversedSentence = reversedWords.join(' ');\n    \n    return reversedSentence;\n}\n\nconsole.log(reverseWords('JavaScript is fun'));"
    },
    "testCases": [
      {
        "input": "JavaScript is fun",
        "expected": "fun is JavaScript\n"
      },
      {
        "input": "Hello World",
        "expected": "World Hello\n"
      }
    ]
  },
  {
    "id": 232,
    "title": "Array: Grouping by Property (Reduce)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array of objects `[{type: 'A', value: 1}, {type: 'B', value: 2}, {type: 'A', value: 3}]`, use the **`.reduce()`** method to group the objects into a single object where keys are the `type` property and values are arrays of corresponding objects.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the grouped object.",
    "solution": {
      "explanation": "The **`.reduce()`** method is used to transform the list into a single, grouped object. The accumulator (`acc`) is initialized as `{}`. For each object, we check if its `type` key exists in the accumulator. If not, we initialize it with an empty array, then push the current object into that array, effectively grouping items by their `type` property.",
      "code": "const data = [\n    { type: 'A', value: 1 }, \n    { type: 'B', value: 2 }, \n    { type: 'A', value: 3 }\n];\n\nconst grouped = data.reduce((acc, obj) => {\n    const key = obj.type;\n    \n    // Check if the key exists, if not, initialize it to an empty array\n    if (!acc[key]) {\n        acc[key] = [];\n    }\n    \n    // Push the current object into the array corresponding to its type\n    acc[key].push(obj);\n    \n    return acc;\n}, {}); // Initialize accumulator to an empty object\n\nconsole.log(grouped);"
    },
    "testCases": [
      {
        "input": "Internal objects",
        "expected": "{ A: [ { type: 'A', value: 1 }, { type: 'A', value: 3 } ], B: [ { type: 'B', value: 2 } ] }\n"
      }
    ]
  },
  {
    "id": 233,
    "title": "Callback Function (Filter Even)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a function `filterArray(arr, callback)` that takes an array and a callback function. It should return a new array containing only the elements for which the callback returns `true`. Use this to filter out all **odd numbers** from `[1, 2, 3, 4, 5]`.",
    "inputFormat": "Internal call with a custom callback.",
    "outputFormat": "The program must print the filtered array.",
    "solution": {
      "explanation": "This demonstrates the concept of a **Callback Function** and **Higher-Order Functions**. `filterArray` is the HOF that accepts the data and a `callback` function (`isEven`). It is the responsibility of `filterArray` to iterate over the data, and the responsibility of the `callback` to define the specific logic (e.g., checking for evenness) to determine which elements are included in the result.",
      "code": "function filterArray(arr, callback) {\n    const result = [];\n    for (const element of arr) {\n        if (callback(element)) { // Execute the provided callback\n            result.push(element);\n        }\n    }\n    return result;\n}\n\n// Callback function to check for even numbers\nconst isEven = (num) => num % 2 === 0;\n\nconst numbers = [1, 2, 3, 4, 5];\nconst filtered = filterArray(numbers, isEven);\n\nconsole.log(`Filtered: ${filtered}`);"
    },
    "testCases": [
      {
        "input": "[1, 2, 3, 4, 5]",
        "expected": "Filtered: 2,4\n"
      }
    ]
  },
  {
    "id": 234,
    "title": "Remove Falsy Values",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array with various falsy values: `[0, 1, false, 2, '', 3, null, undefined, NaN]`, use the **`.filter()`** method to remove all falsy values and return an array containing only truthy elements.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the filtered array.",
    "solution": {
      "explanation": "Falsy values are those that coerce to `false` (0, `false`, `''`, `null`, `undefined`, `NaN`). By passing the native **`Boolean`** constructor (or simply `item => item`) as the filter callback, all falsy elements are automatically removed, leaving only the truthy elements.",
      "code": "const mixed = [0, 1, false, 2, '', 3, null, undefined, NaN];\n\n// The Boolean constructor coerces each element to a boolean\nconst truthy = mixed.filter(Boolean);\n\n// Alternative concise solution: mixed.filter(item => item);\n\nconsole.log(truthy);"
    },
    "testCases": [
      {
        "input": "Array with falsy values",
        "expected": "[1, 2, 3]\n"
      }
    ]
  },
  {
    "id": 235,
    "title": "Check Prime (Imperative Loop)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a JavaScript function `isPrime(n)` that determines if a number $n$ is prime using a standard `for` loop (imperative style). Optimize the loop to check only up to $\\sqrt{n}$.",
    "inputFormat": "Internal calls with $n=13$ and $n=15$.",
    "outputFormat": "The program must print the boolean result for both cases.",
    "solution": {
      "explanation": "We implement the prime check using a standard **`for` loop**. The key optimization is to check for divisors only up to the **square root** of the number $n$ (`Math.sqrt(n)`). If a number has a divisor greater than its square root, it must also have one smaller than its square root. This halves the required checks, significantly improving performance.",
      "code": "function isPrime(n) {\n    if (n <= 1) return false;\n    \n    // Loop only up to the square root of n\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(`13 is prime: ${isPrime(13)}`);\nconsole.log(`15 is prime: ${isPrime(15)}`);"
    },
    "testCases": [
      {
        "input": "13 and 15",
        "expected": "13 is prime: true\n15 is prime: false\n"
      }
    ]
  },
  {
    "id": 236,
    "title": "Class: Getters and Setters",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Define a class `Product` with a private property `_price`. Implement a **getter** `price` to retrieve the value and a **setter** `price` to ensure the price is always greater than 0 before updating `_price`.",
    "inputFormat": "Internal calls to set a valid and an invalid price.",
    "outputFormat": "Print the initial price and the price after the valid update.",
    "solution": {
      "explanation": "The **`get`** and **`set`** keywords define controlled accessors for object properties. The **setter** (`set price(newPrice)`) allows for **validation logic** (e.g., `if (newPrice > 0)`) to be executed before modifying the internal, convention-based private property (`this._price`). This is a mechanism to enforce encapsulation and maintain object state integrity.",
      "code": "class Product {\n    constructor(price) {\n        this._price = price;\n    }\n    \n    // Getter method\n    get price() {\n        return this._price;\n    }\n    \n    // Setter method\n    set price(newPrice) {\n        if (newPrice > 0) {\n            this._price = newPrice;\n        } else {\n            console.log(\"Error: Price must be greater than 0.\");\n        }\n    }\n}\n\nconst product = new Product(100);\nconsole.log(`Initial Price: ${product.price}`);\n\nproduct.price = 150;\nproduct.price = -10; // Fails validation\n\nconsole.log(`New Price: ${product.price}`);"
    },
    "testCases": [
      {
        "input": "Initial 100. Set 150. Try to set -10.",
        "expected": "Initial Price: 100\nError: Price must be greater than 0.\nNew Price: 150\n"
      }
    ]
  },
  {
    "id": 237,
    "title": "Callback Hell (Simulated)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the issue of 'Callback Hell' by simulating three dependent asynchronous database operations (`fetchUser`, `fetchOrders`, `calculateTotal`) using nested `setTimeout` functions. Print the final result.",
    "inputFormat": "Internal function calls.",
    "outputFormat": "Print the three sequential messages.",
    "solution": {
      "explanation": "**Callback Hell** is characterized by deeply nested asynchronous code where each operation depends on the result of the previous one. This structure leads to code that is difficult to read, maintain, and debug (the 'Pyramid of Doom'). It highlights the need for flatter asynchronous control flows, such as those provided by Promises or `async/await`.",
      "code": "function fetchUser(callback) { setTimeout(() => callback(null, { id: 1 }), 100); }\nfunction fetchOrders(userId, callback) { setTimeout(() => callback(null, [50, 100]), 100); }\nfunction calculateTotal(orders, callback) { setTimeout(() => callback(null, orders.reduce((a, b) => a + b, 0)), 100); }\n\n// Callback Hell demonstration\nfetchUser((err, user) => {\n    if (err) return console.error(err);\n    console.log('1. User fetched.');\n    fetchOrders(user.id, (err, orders) => {\n        if (err) return console.error(err);\n        console.log('2. Orders fetched.');\n        calculateTotal(orders, (err, total) => {\n            if (err) return console.error(err);\n            console.log(`3. Total calculated: ${total}.`);\n        });\n    });\n});"
    },
    "testCases": [
      {
        "input": "Nested setTimeouts",
        "expected": "1. User fetched.\n2. Orders fetched.\n3. Total calculated: 150.\n"
      }
    ]
  },
  {
    "id": 238,
    "title": "Promisify a Callback Function",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a function `promisify(fn)` that takes a Node.js-style asynchronous function (`fn(arg, callback)`) and converts it into a function that returns a **`Promise`**. Use this to promisify a simple `setTimeout` function.",
    "inputFormat": "Internal call to the promisified function using `.then()`.",
    "outputFormat": "The program must print the success message.",
    "solution": {
      "explanation": "**Promisification** is the process of converting a callback-based function (typically with the signature `(err, data)`) into one that returns a Promise. The `promisify` function returns a wrapper that executes the original function, providing a custom callback that either calls `resolve(data)` (if `err` is null) or `reject(err)` (if `err` exists), bridging the older callback style with modern Promise-based asynchronous flow.",
      "code": "// Mock asynchronous function (takes callback)\nfunction mockAsync(value, callback) {\n    setTimeout(() => {\n        if (value > 0) callback(null, `Success`);\n        else callback(new Error('Value is non-positive'));\n    }, 100);\n}\n\n// Promisification function\nfunction promisify(fn) {\n    return function(...args) {\n        return new Promise((resolve, reject) => {\n            // Call the original function, adding the custom callback\n            fn(...args, (err, data) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(data);\n            });\n        });\n    };\n}\n\nconst promisifiedMock = promisify(mockAsync);\n\npromisifiedMock(1)\n    .then(result => console.log(`Result: ${result}`))\n    .catch(error => console.error(`Error: ${error.message}`));"
    },
    "testCases": [
      {
        "input": "Internal promisified call",
        "expected": "Result: Success\n"
      }
    ]
  },
  {
    "id": 239,
    "title": "Destructuring and Renaming",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an object `config = {host: 'localhost', port: 8080, timeout: 5000}`, use **object destructuring** to extract `host` and rename `port` to `httpPort`. Print both variables.",
    "inputFormat": "Hardcoded object.",
    "outputFormat": "The program must print the values of the renamed and original variables.",
    "solution": {
      "explanation": "Object destructuring allows for extracting values from properties. **Renaming** during destructuring is achieved using the syntax **`{ original_key: new_variable_name }`**. This extracts the value from `config.port` and assigns it to the new local variable `httpPort`, while the value of `config.host` is assigned to a variable of the same name, `host`.",
      "code": "const config = {\n    host: 'localhost',\n    port: 8080,\n    timeout: 5000\n};\n\n// Extract 'host' and rename 'port' to 'httpPort'\nconst { host, port: httpPort } = config;\n\nconsole.log(`Host: ${host}, HTTP Port: ${httpPort}`);"
    },
    "testCases": [
      {
        "input": "config object",
        "expected": "Host: localhost, HTTP Port: 8080\n"
      }
    ]
  },
  {
    "id": 240,
    "title": "Spread Operator (Deep Clone check)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the limitation of the **Spread Operator** for deep cloning. Given `obj1 = {a: 1, nested: {b: 2}}`, create `obj2 = {...obj1}`. Change `obj2.nested.b` to 99. Print both `obj1.nested.b` and `obj2.nested.b` to show they are linked (shallow copy).",
    "inputFormat": "Internal object manipulation.",
    "outputFormat": "The program must print the linked values.",
    "solution": {
      "explanation": "The **Spread Operator** (`...`) creates only a **shallow copy**. While top-level properties are copied by value, nested objects are copied by **reference**. Therefore, modifying the nested object in the copy (`obj2`) affects the nested object in the original (`obj1`), confirming the shared reference.",
      "code": "const obj1 = { \n    a: 1, \n    nested: { b: 2 } \n};\n\n// Shallow copy using spread operator\nconst obj2 = { ...obj1 };\n\n// Modify the nested object in the copy\nobj2.nested.b = 99;\n\nconsole.log(`Obj1.nested.b: ${obj1.nested.b}`);\nconsole.log(`Obj2.nested.b: ${obj2.nested.b}`);"
    },
    "testCases": [
      {
        "input": "obj2.nested.b = 99",
        "expected": "Obj1.nested.b: 99\nObj2.nested.b: 99\n"
      }
    ]
  },
  {
    "id": 241,
    "title": "Array: Find Unique Elements (Filter/IndexOf)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array with duplicates, `[1, 2, 2, 3, 4, 3, 5]`, use the **`.filter()`** method along with **`.indexOf()`** to create a new array containing only unique elements, preserving the order of first appearance.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the unique array.",
    "solution": {
      "explanation": "This technique preserves the order of first appearance. The **`.filter()`** method is used with a callback that checks if the current element's `index` is equal to the index of its **first occurrence** found by **`.indexOf(value)`**. If the indices are the same, the element is unique (it's the first one seen); otherwise, it is a duplicate and is filtered out.",
      "code": "const data = [1, 2, 2, 3, 4, 3, 5];\n\nconst uniqueArray = data.filter((value, index, arr) => {\n    // Keep the element only if its current index matches its first index\n    return arr.indexOf(value) === index;\n});\n\nconsole.log(uniqueArray);"
    },
    "testCases": [
      {
        "input": "[1, 2, 2, 3, 4, 3, 5]",
        "expected": "[1, 2, 3, 4, 5]\n"
      },
      {
        "input": "[1, 1, 1, 1]",
        "expected": "[1]\n"
      }
    ]
  },
  {
    "id": 242,
    "title": "String to Title Case (Map/Join)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a function `toTitleCase(str)` that converts a string (e.g., 'hello world') to **Title Case** by capitalizing the first letter of each word. Use the `.split()`, `.map()`, and `.join()` methods.",
    "inputFormat": "The string is hardcoded.",
    "outputFormat": "The program must print the title cased string.",
    "solution": {
      "explanation": "This functional approach converts the string to **Title Case** by chaining array methods: 1. **`.split(' ')`** creates an array of words. 2. **`.map()`** iterates over each word and applies the transformation: capitalize the first letter and concatenate it with the rest of the word (ensured to be lowercase). 3. **`.join(' ')`** rebuilds the sentence with correct spacing.",
      "code": "function toTitleCase(str) {\n    return str.toLowerCase()\n        .split(' ')\n        .map(word => {\n            if (word.length === 0) return '';\n            // Capitalize the first letter and append the rest of the word\n            return word[0].toUpperCase() + word.slice(1);\n        })\n        .join(' ');\n}\n\nconsole.log(toTitleCase('java script is powerful'));"
    },
    "testCases": [
      {
        "input": "java script is powerful",
        "expected": "Java Script Is Powerful\n"
      }
    ]
  },
  {
    "id": 243,
    "title": "Shallow Copy vs Deep Copy (JSON)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the creation of a **Deep Copy** for the object `obj1 = {a: 1, nested: {b: 2}}` using the `JSON.parse(JSON.stringify())` method. Modify the nested property in the copy (`obj3`) and print the original (`obj1`) to confirm the objects are disconnected.",
    "inputFormat": "Internal object manipulation.",
    "outputFormat": "The program must print the disconnected values.",
    "solution": {
      "explanation": "The **`JSON.parse(JSON.stringify(obj))`** method is a common technique to perform a **Deep Copy** of simple JavaScript objects. **`JSON.stringify`** converts the object to a string, breaking all internal references. **`JSON.parse`** then reconstructs a completely new, disconnected object hierarchy from that string, ensuring that nested objects in the copy are independent of the original.",
      "code": "const obj1 = { \n    a: 1, \n    nested: { b: 2 } \n};\n\n// Deep copy using JSON serialization/deserialization\nconst obj3 = JSON.parse(JSON.stringify(obj1));\n\n// Modify the nested object in the copy\nobj3.nested.b = 99;\n\nconsole.log(`Obj1.nested.b: ${obj1.nested.b}`); // Still 2\nconsole.log(`Obj3.nested.b: ${obj3.nested.b}`); // New value 99"
    },
    "testCases": [
      {
        "input": "obj3.nested.b = 99",
        "expected": "Obj1.nested.b: 2\nObj3.nested.b: 99\n"
      }
    ]
  },
  {
    "id": 244,
    "title": "Fetch API: Simple GET Request (Simulated)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Simulate an API call using the **`fetch`** function and `async/await`. Define a simple mock API function that returns a Promise resolving with JSON data, and use `await` to handle the response and extract the data.",
    "inputFormat": "Internal call to the simulated fetch function.",
    "outputFormat": "The program must print the user's name from the JSON data.",
    "solution": {
      "explanation": "The modern structure for asynchronous requests uses **`fetch`** and **`async/await`**. The `await` keyword is used twice: once to wait for the network `response`, and again to wait for the response stream to be read and parsed into a JavaScript object using **`response.json()`**. This two-step process is crucial for handling HTTP streams.",
      "code": "// Mock fetch that returns a Promise resolving to a Response-like object\nfunction mockFetch(url) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve({ \n                json: () => Promise.resolve({ id: 1, name: 'Neo' }) \n            });\n        }, 100);\n    });\n}\n\nasync function getUserData() {\n    const response = await mockFetch('/api/user/1');\n    const data = await response.json(); // Wait for the body to be parsed\n    console.log(`Fetched User: ${data.name}`);\n}\n\ngetUserData();"
    },
    "testCases": [
      {
        "input": "Simulated fetch",
        "expected": "Fetched User: Neo\n"
      }
    ]
  },
  {
    "id": 245,
    "title": "Array: Flatten Nested Array (Recursion)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a recursive function `flatten(arr)` to flatten a deeply nested array (`[1, [2, [3, [4]], 5]]`) into a single-dimensional array.",
    "inputFormat": "Hardcoded nested array.",
    "outputFormat": "The program must print the flattened array.",
    "solution": {
      "explanation": "The recursive approach flattens a nested array. The function iterates over the input array. If an element is an array (checked using `Array.isArray()`), the function calls itself recursively and uses **`.concat()`** to merge the resulting flat array into the current result. If the element is not an array, it is pushed directly into the result.",
      "code": "function flatten(arr) {\n    let result = [];\n    for (const element of arr) {\n        if (Array.isArray(element)) {\n            // Recursively call flatten and concatenate the result\n            result = result.concat(flatten(element));\n        } else {\n            result.push(element);\n        }\n    }\n    return result;\n}\n\nconst nested = [1, [2, [3, [4]], 5]];\nconsole.log(flatten(nested));"
    },
    "testCases": [
      {
        "input": "[1, [2, [3, [4]], 5]]",
        "expected": "[1, 2, 3, 4, 5]\n"
      }
    ]
  },
  {
    "id": 246,
    "title": "Promises: Chaining (Sequential Async)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate **Promise Chaining** by creating three sequential functions that return Promises (`step1`, `step2`, `step3`). Each step should depend on the previous result and print a message. Use `.then()` to execute them sequentially.",
    "inputFormat": "Internal function calls.",
    "outputFormat": "Three sequential messages printed after short delays.",
    "solution": {
      "explanation": "**Promise Chaining** ensures sequential execution of asynchronous tasks. The `return` value from one **`.then()`** block is automatically passed as the argument to the callback of the next `.then()` block. This structure flattens the asynchronous flow and replaces Callback Hell.",
      "code": "const step1 = () => Promise.resolve(0);\nconst step2 = (value) => new Promise(resolve => {\n    setTimeout(() => {\n        console.log(`1. Initial value: ${value}`);\n        resolve(value + 10);\n    }, 200);\n});\nconst step3 = (value) => new Promise(resolve => {\n    setTimeout(() => {\n        console.log(`2. Value after step 2: ${value}`);\n        resolve(value + 10);\n    }, 200);\n});\n\nstep1()\n    .then(step2)\n    .then(step3)\n    .then(finalValue => console.log(`3. Final result: ${finalValue}`))\n    .catch(console.error); "
    },
    "testCases": [
      {
        "input": "Chained promises",
        "expected": "1. Initial value: 0\n2. Value after step 2: 10\n3. Final result: 20\n"
      }
    ]
  },
  {
    "id": 247,
    "title": "Hoisting vs TDZ (let/const)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the difference between variable **Hoisting** (`var`) and the **Temporal Dead Zone (TDZ)** (`let` and `const`) by commenting out the line that causes a `ReferenceError` when accessing a variable before its declaration.",
    "inputFormat": "Internal variable calls.",
    "outputFormat": "The program must print the hoisted variable as `undefined` and successfully execute the `let` access *after* declaration.",
    "solution": {
      "explanation": "**`var`** is **hoisted** and initialized to `undefined`, allowing pre-declaration access. **`let`** and **`const`** are also hoisted but are *not* initialized; they enter the **Temporal Dead Zone (TDZ)**. Accessing them before their declaration results in a `ReferenceError`, enforcing better coding practices.",
      "code": "/* The line 'console.log(b_let);' would throw a ReferenceError (TDZ). We comment it out to demonstrate the working code. */\n\n// var is hoisted and initialized to undefined\nconsole.log(`var result (hoisted): ${a_var}`); \nvar a_var = 5;\n\n// let is hoisted but NOT initialized (TDZ)\nlet b_let = 10;\nconsole.log(`let result (TDZ passed): ${b_let}`);"
    },
    "testCases": [
      {
        "input": "var vs let hoisting",
        "expected": "var result (hoisted): undefined\nlet result (TDZ passed): 10\n"
      }
    ]
  },
  {
    "id": 248,
    "title": "Use `reduce` to create a Map/Object",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array of pairs `[['a', 1], ['b', 2], ['c', 3]]`, use the **`.reduce()`** method to transform this array into an object/map `{a: 1, b: 2, c: 3}`.",
    "inputFormat": "Hardcoded array of pairs.",
    "outputFormat": "The program must print the resulting object.",
    "solution": {
      "explanation": "The **`.reduce()`** method transforms the array of pairs into a single object. The accumulator is initialized to an empty object (`{}`). In each iteration, the current array element is destructured into `[key, value]`, which is then assigned as a new property on the accumulator object.",
      "code": "const pairs = [['a', 1], ['b', 2], ['c', 3]];\n\nconst resultObject = pairs.reduce((acc, currentPair) => {\n    const [key, value] = currentPair; // Destructure the pair\n    acc[key] = value;\n    return acc;\n}, {}); // Initialize accumulator to an empty object\n\nconsole.log(resultObject);"
    },
    "testCases": [
      {
        "input": "[['a', 1], ['b', 2], ['c', 3]]",
        "expected": "{ a: 1, b: 2, c: 3 }\n"
      }
    ]
  },
  {
    "id": 249,
    "title": "Event Loop and Microtasks",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Demonstrate the JavaScript **Event Loop** order by using `console.log`, `setTimeout` (Macrotask), and a resolved `Promise.resolve().then()` (Microtask). Print the output in the order the messages appear.",
    "inputFormat": "Internal functions.",
    "outputFormat": "Print the messages in the correct execution order.",
    "solution": {
      "explanation": "The **Event Loop** determines the execution order: 1. **Synchronous Code** runs to completion. 2. **Microtask Queue** (Promises, `async/await`) is emptied. 3. **Macrotask Queue** (`setTimeout`, `setInterval`) is processed one item at a time. The **Promise microtask** will always execute immediately after the synchronous code, but before the **`setTimeout` macrotask**.",
      "code": "console.log('1. Sync Start');\n\nsetTimeout(() => {\n    console.log('4. Timeout Macrotask');\n}, 0);\n\nPromise.resolve().then(() => {\n    console.log('3. Promise Microtask'); // This runs BEFORE setTimeout\n});\n\nconsole.log('2. Sync End');"
    },
    "testCases": [
      {
        "input": "setTimeout, Promise, console.log",
        "expected": "1. Sync Start\n2. Sync End\n3. Promise Microtask\n4. Timeout Macrotask\n"
      }
    ]
  },
  {
    "id": 250,
    "title": "Use `async/await` to run tasks sequentially",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Create three functions (`task1`, `task2`, `task3`) that each return a Promise resolving after 100ms. Write an `async` function `runSequential()` that executes these tasks one after another using **`await`**, ensuring the total execution time is approximately 300ms.",
    "inputFormat": "Internal function calls.",
    "outputFormat": "The program must print the messages in sequence.",
    "solution": {
      "explanation": "Using **`await`** within an **`async`** function forces sequential execution of asynchronous tasks. The function pauses at each `await` until the current Promise resolves, guaranteeing that tasks complete one after another. This results in a total execution time that is the sum of the individual task times.",
      "code": "const delay = (name) => new Promise(resolve => {\n    setTimeout(() => {\n        console.log(`${name} finished.`);\n        resolve();\n    }, 100);\n});\n\nasync function runSequential() {\n    await delay('Task 1');\n    await delay('Task 2');\n    await delay('Task 3');\n    console.log('Sequence complete.');\n}\n\nrunSequential();"
    },
    "testCases": [
      {
        "input": "Sequential await calls",
        "expected": "Task 1 finished.\nTask 2 finished.\nTask 3 finished.\nSequence complete.\n"
      }
    ]
  },
  {
    "id": 251,
    "title": "Bonus: Array Reduce to count tags",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given an array of problem objects, use the **`.reduce()`** method to count the total occurrences of each unique `tag` across all problems. Print the resulting tag map.",
    "inputFormat": "Hardcoded array of problem objects.",
    "outputFormat": "The program must print the tag frequency object.",
    "solution": {
      "explanation": "The **`.reduce()`** method is used for complex aggregation. The accumulator starts as an empty object. An inner `for...of` loop iterates over the `tags` array of each problem. The accumulator object is updated for every tag, creating a frequency map of all tags across the entire dataset.",
      "code": "const problems = [\n    { id: 1, tags: ['A', 'B'] },\n    { id: 2, tags: ['A', 'C'] },\n    { id: 3, tags: ['B'] }\n];\n\nconst tagCounts = problems.reduce((acc, problem) => {\n    for (const tag of problem.tags) {\n        acc[tag] = acc[tag] + 1 || 1;\n    }\n    return acc;\n}, {});\n\nconsole.log(tagCounts);"
    },
    "testCases": [
      {
        "input": "Objects with tags: ['A', 'B'], ['A'], ['C']",
        "expected": "{ A: 2, B: 2, C: 1 }\n"
      }
    ]
  },
  {
    "id": 252,
    "title": "Bonus: Promise.race for fastest result",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Create three Promises that resolve with values 'Server A', 'Server B', and 'Server C' after 1s, 0.5s, and 2s delays, respectively. Use **`Promise.race()`** to get the result from the fastest server.",
    "inputFormat": "Internal promises.",
    "outputFormat": "The program must print the result from the fastest promise.",
    "solution": {
      "explanation": "**`Promise.race()`** is used to determine the first promise in an array to resolve or reject. It immediately settles with the fate (resolution or rejection) of the fastest promise, making it ideal for fetching data from redundant sources where you only need the quickest response.",
      "code": "function delayResolve(time, value) {\n    return new Promise(resolve => setTimeout(() => resolve(value), time * 1000));\n}\n\nconst promises = [\n    delayResolve(1, 'Server A'),    // 1.0s\n    delayResolve(0.5, 'Server B'),  // 0.5s (Winner)\n    delayResolve(2, 'Server C')     // 2.0s\n];\n\nPromise.race(promises)\n    .then(winner => console.log(`Winner: ${winner}`))\n    .catch(console.error);"
    },
    "testCases": [
      {
        "input": "Promises: 1s, 0.5s, 2s",
        "expected": "Winner: Server B\n"
      }
    ]
  },
  {
    "id": 253,
    "title": "Bonus: Recursive Fibonacci with Memoization",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a recursive function `fibonacci(n)` that calculates the N-th Fibonacci number. Implement **Memoization** using a `Map` to significantly improve performance.",
    "inputFormat": "Internal call with N=30.",
    "outputFormat": "The program must print the 30th Fibonacci number.",
    "solution": {
      "explanation": "This recursive solution calculates Fibonacci in efficient $O(N)$ time by implementing **Memoization** (Top-Down Dynamic Programming). It uses a **`Map`** to cache the results of previous function calls. Before calculating `fibonacci(n)`, the function checks the map; if the result is already present, it is returned instantly, avoiding the redundant computations that plague a pure recursive approach.",
      "code": "const memo = new Map();\n\nfunction fibonacci(n) {\n    if (n in memo) {\n        return memo.get(n);\n    }\n    if (n <= 1) {\n        return n;\n    }\n    \n    const result = fibonacci(n - 1) + fibonacci(n - 2);\n    memo.set(n, result); // Store the result\n    return result;\n}\n\nconsole.log(`Fibonacci(30): ${fibonacci(30)}`);"
    },
    "testCases": [
      {
        "input": "N=30",
        "expected": "Fibonacci(30): 832040\n"
      }
    ]
  },
  {
    "id": 254,
    "title": "Bonus: Recursive Factorial (Tail Recursion Concept)",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Write a recursive function `factorial(n, accumulator)` that calculates the factorial of N. Implement it to follow the pattern of **Tail Recursion** (where the recursive call is the final operation in the function).",
    "inputFormat": "Internal call with N=5.",
    "outputFormat": "The program must print the result.",
    "solution": {
      "explanation": "A **Tail Recursive** function is one where the recursive call is the absolute last operation performed. This pattern is essential for **Tail Call Optimization (TCO)**, which allows compliant JavaScript engines to execute the recursion iteratively, preventing stack overflow errors. The solution uses an **accumulator** parameter to carry the result of the multiplication from step to step.",
      "code": "function factorial(n, accumulator = 1) {\n    if (n <= 1) {\n        return accumulator;\n    }\n    \n    // The recursive call is the very last operation, making this tail-recursive\n    return factorial(n - 1, accumulator * n);\n}\n\nconsole.log(`Factorial of 5: ${factorial(5)}`);"
    },
    "testCases": [
      {
        "input": "N=5",
        "expected": "Factorial of 5: 120\n"
      }
    ]
  },
  {
    "id": 255,
    "title": "Bonus: Implement `flat` using Reduce",
    "language": "JavaScript",
    "difficulty": "Hard",
    "problemStatement": "Given a shallow nested array `[1, [2, 3], 4]`, use the **`.reduce()`** method and the **Spread Operator** to manually flatten the array by one level.",
    "inputFormat": "Hardcoded array.",
    "outputFormat": "The program must print the flattened array.",
    "solution": {
      "explanation": "This manual flattening is achieved using **`.reduce()`**. The reducer uses the **Spread Operator (`...`)** and the array method **`.concat()`**. If the current value (`val`) is an array, spreading it into the accumulator (`acc`) causes its elements to be inserted directly into the new array, thus flattening the level.",
      "code": "const nested = [1, [2, 3], 4];\n\nconst flattened = nested.reduce((acc, val) => {\n    // Use the spread operator to flatten the current value if it's an array\n    return acc.concat(Array.isArray(val) ? [...val] : val);\n}, []);\n\nconsole.log(flattened);"
    },
    "testCases": [
      {
        "input": "Shallow nested array",
        "expected": "[1, 2, 3, 4]\n"
      }
    ]
  }
]

